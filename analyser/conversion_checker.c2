/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module conversion_checker;

import ast local;
import ast_builder;
import diagnostics;
import ctv_analyser;
import src_loc local;

import stdio local;

//  0 = cannot happen (mostly Module/Alias type)
//  1 = Not allowed
//  2 = Builtin -> Builtin
//  3 = Builtin -> Pointer (only usize/u64/u32 -> void*)
//  4 = Pointer -> Builtin (only void* -> usize/u64/u32)
//  5 = Pointer -> Pointer
//  6 = Pointer -> Func (void* or Func*)
//  7 = Array -> Pointer
//  8 = Array -> Array
//  9 = Struct -> Struct
// 10 = Enum -> Builtin (check range)
// 11 = Func -> Pointer (void* or Func*)
// 12 = Func -> Func
// 13 = Builtin -> Enum
// 14 = Enum -> Enum
// 15 = Builtin -> Func
const u8[elemsof(TypeKind)][elemsof(TypeKind)] Conversions = {
    //  Builtin Pointer Array   Struct  Enum    Func   Alias    Module
    //  Builtin ->
    {   2,      3,      1,      1,     13,      15,      0,      0   },
    //  Pointer ->
    {   4,      5,      1,      1,      1,      6,      0,      0   },
    //  Array ->
    {   1,      7,      8,      1,      1,      1,      0,      0   },
    //  Struct ->
    {   1,      1,      1,      9,      1,      1,      0,      0   },
    //  Enum ->
    {   10,     1,      1,      1,     14,      1,      0,      0   },
    //  Function ->
    {   1,      11,     1,      1,      1,      12,     0,      0   },
    //  Alias ->
    {   0,      0,      0,      0,      0,      0,      0,      0   },
    //  Module ->
    {   0,      0,      0,      0,      0,      0,      0,      0   },
}

//  0 = should not happen? (same)
//  1 = ok
//  2 = incompatible
//  3 = sign-conversion
//  4 = loss of integer-precision
//  5 = float -> integer
//  6 = loss of FP-precision
const u8[elemsof(BuiltinKind)][elemsof(BuiltinKind)] BuiltinConversions = {
    //  Char   Int8   Int16  Int32  Int64  UInt8  UInt16 UInt32 UInt64 Flt32  Flt64  ISize  USize  Bool  Void
    //  1      2      3      4      5      6      7      8      9      10     11     12     13     14    15
    // Char ->
    {   0,     1,     1,     1,     1,     3,     3,     3,     3,     1,     1,     1,     3,     1,    2  },
    // Int8 ->
    {   1,     0,     1,     1,     1,     3,     3,     3,     3,     1,     1,     1,     3,     1,    2  },
    // Int16 ->
    {   4,     4,     0,     1,     1,     3,     3,     3,     3,     1,     1,     1,     3,     1,    2  },
    // Int32 ->
    {   4,     4,     4,     0,     1,     3,     3,     3,     3,     1,     1,     1,     3,     1,    2  },
    // Int64 ->
    {   4,     4,     4,     4,     0,     3,     3,     3,     3,     1,     1,     1,     3,     1,    2  },
    // UInt8 ->
    {   3,     3,     3,     3,     3,     0,     1,     1,     1,     1,     1,     3,     1,     1,    2  },
    // UInt16 ->
    {   3,     3,     3,     3,     3,     1,     0,     1,     1,     1,     1,     3,     1,     1,    2  },
    // UInt32 ->
    {   3,     3,     3,     3,     3,     1,     1,     0,     1,     1,     1,     3,     1,     1,    2  },
    // UInt64 ->
    {   3,     3,     3,     3,     3,     1,     1,     1,     0,     1,     1,     3,     1,     1,    2  },
    // Flt32 ->
    {   5,     5,     5,     5,     5,     5,     5,     5,     5,     0,     1,     5,     5,     2,    2  },
    // Flt64 ->
    {   5,     5,     5,     5,     5,     5,     5,     5,     5,     6,     0,     5,     5,     2,    2  },
    // ISize ->
    {   4,     4,     4,     4,     1,     3,     3,     3,     3,     1,     1,     0,     3,     1,    2  },
    // USize ->
    {   3,     3,     3,     3,     3,     1,     1,     1,     1,     1,     1,     3,     0,     1,    2  },
    // Bool ->
    {   1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     0,    2  },
    // Void ->
    {   2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,    0  },
}

public type Checker struct {
    diagnostics.Diags* diags;
    ast_builder.Builder* builder;

    // changes every check
    SrcLoc loc;
    QualType lhs;
    QualType rhs;
    Expr** expr_ptr;
}

public func void Checker.init(Checker* c, diagnostics.Diags* diags, ast_builder.Builder* builder) {
    c.diags = diags;
    c.builder = builder;
}

public func bool Checker.check(Checker* c, QualType lhs,  QualType rhs, Expr** e_ptr, SrcLoc loc) {
    assert(lhs.ptr);
    assert(rhs.ptr);

    if ((*e_ptr).isCtv()) {
        return ctv_analyser.check(c.diags, lhs, *e_ptr);
    }

    QualType t1 = lhs.getCanonicalType();
    QualType t2 = rhs.getCanonicalType();
    const Type* lcanon = t1.getTypeOrNil();
    const Type* rcanon = t2.getTypeOrNil();

    if (lcanon == rcanon) {
        u32 lquals = lhs.getQuals();
        u32 rquals = rhs.getQuals();
        if (lcanon.getKind() == TypeKind.Pointer && ((~lquals & 0x3) & rquals)) {
            c.diags.error(c.loc, "conversion discards const qualifier");
            return false;
        }
        return true;
    }

    c.lhs = lhs;
    c.rhs = rhs;
    c.expr_ptr = e_ptr;
    c.loc = loc;

    return c.checkTypes(lcanon, rcanon);
}

func bool Checker.checkTypes(Checker* c, const Type* lcanon, const Type* rcanon) {

    u8 res = Conversions[rcanon.getKind()][lcanon.getKind()];

    switch (res) {
    case 0: // cannot happen
        c.diags.error(c.loc, "SHOULD NOT HAPPEN (%u - %u)\n", lcanon.getKind(), rcanon.getKind());
        c.lhs.dump_full();
        c.rhs.dump_full();
        assert(0);
        return false;
    case 1: // not allowed
        c.diags.error(c.loc, "invalid type conversion from '%s' to '%s'", c.rhs.diagName(), c.lhs.diagName());
        return false;
    case 2: //  2 = Builtin -> Builtin
        return c.checkBuiltins(lcanon, rcanon);
    case 3: //  3 = Builtin -> Pointer (only if usize/u64/u32)
        return c.checkBuiltin2Pointer(lcanon, rcanon);
    case 4: //  4 = Pointer -> Builtin (only if usize/u64/u32)
        return c.checkPointer2Builtin(lcanon, rcanon);
    case 5: //  5 = Pointer -> Pointer
        return c.checkPointers(lcanon, rcanon);
    case 6: //  6 = Pointer -> Func (void* or Func*)
        return c.checkPointer2Func(lcanon, rcanon);
    case 7: //  7 = Array -> Pointer
        c.diags.note(c.loc, "SHOULD NOT HAPPEN (Array -> Ptr)");
        assert(0);
        return false;
    case 8: //  8 = Array -> Array
        c.diags.error(c.loc, "invalid type conversion from '%s' to '%s'", c.rhs.diagName(), c.lhs.diagName());
        return false;
    case 9: //  9 = Struct -> Struct
        c.diags.error(c.loc, "conversion between struct of different types ('%s' to '%s')", c.rhs.diagName(), c.lhs.diagName());
        return false;
    case 10: // 10 = Enum -> Builtin (check range)
        return c.checkEnum2Int(lcanon, rcanon);
    // 11 = Func -> Pointer (void* or Func*)
    case 12: // Func -> Func
        bool ok = checkFunc2Func(lcanon, rcanon);
        // TODO report exact location
        if (!ok) c.diags.error(c.loc, "invalid function conversion from '%s' to '%s'", c.rhs.diagName(), c.lhs.diagName());
        return ok;
    case 13: // Builtin -> Enum
        c.diags.error(c.loc, "invalid type conversion from '%s' to '%s'", c.rhs.diagName(), c.lhs.diagName());
        return false;
    case 14: // Enum -> Enum
        // is not allowed, since the ptr check already filters out the allowed ones
        c.diags.error(c.loc, "invalid type conversion from '%s' to '%s'", c.rhs.diagName(), c.lhs.diagName());
        return false;
    case 15: // Builtin -> Func
        c.diags.error(c.loc, "invalid type conversion from '%s' to '%s'", c.rhs.diagName(), c.lhs.diagName());
        return false;
    default:
        c.diags.note(c.loc, "TODO CONVERSION  %u)", res);
        return false;
    }

    return true;
}

func bool Checker.checkBuiltins(Checker* c, const Type* lcanon, const Type* rcanon) {
    // Note: lhs and rhs are not the same, otherwise ptr-check would have succeeded
    const BuiltinType* lbuiltin = cast<BuiltinType*>(lcanon);
    const BuiltinType* rbuiltin = cast<BuiltinType*>(rcanon);

    if ((*c.expr_ptr).isCtv()) {
        // TODO check value instead of type
        return true;
    }

    u8 res = BuiltinConversions[rbuiltin.getKind()][lbuiltin.getKind()];
    switch (res) {
    case 0:     // should not happen
        printf("BUILTIN SHOULD NOT HAPPEN (%u - %u)\n", lcanon.getKind(), rcanon.getKind());
        assert(0);
        return false;
    case 1:     // ok
        break;
    case 2:     // incompatible
        c.diags.error(c.loc, "invalid type conversion from '%s' to '%s'", c.rhs.diagName(), c.lhs.diagName());
        return false;
    case 3:     // sign-conversion
        //c.diags.note(c.loc, "sign conversion");
        break;
    case 4:     // loss of integer-precision
        c.diags.warn(c.loc, "implicit conversion loses integer precision: '%s' to '%s'", c.rhs.diagName(), c.lhs.diagName());
        break;
    case 5:     // float -> integer
        c.diags.note(c.loc, "float to integer conversion");
        break;
    case 6:     // loss of FP-precision
        c.diags.note(c.loc, "loss of floating-point precision");
        break;
    }

    return true;
}

func bool Checker.checkBuiltin2Pointer(Checker* c, const Type* lcanon, const Type* rcanon) {
    // Note: only allow usize/(u32/u64) -> void*
    const PointerType* ptr = cast<PointerType*>(lcanon);
    const BuiltinType* bi = cast<BuiltinType*>(rcanon);

    QualType inner = ptr.getInner();
    bool ok = inner.isVoidType();

    BuiltinKind kind = bi.getKind();
    // TODO or u32
    ok &= (kind == BuiltinKind.USize || kind == BuiltinKind.UInt64);

    if (!ok) {
        c.diags.error(c.loc, "incompatible integer to pointer conversion '%s' to '%s'",
                c.rhs.diagName(), c.lhs.diagName());
        return false;
    }
    return true;
}

func bool Checker.checkPointer2Builtin(Checker* c, const Type* lcanon, const Type* rcanon) {
    // Note: only allow void* -> usize/(u32/u64) / bool
    const BuiltinType* bi = cast<BuiltinType*>(lcanon);

    BuiltinKind kind = bi.getKind();
    if (kind == BuiltinKind.Bool) {
        c.builder.insertImplicitCast(ImplicitCastKind.PointerToBoolean, c.expr_ptr, g_bool);
        return true;
    }

    const PointerType* ptr = cast<PointerType*>(rcanon);
    QualType inner = ptr.getInner();

    // TODO or u32 (arch)
    bool ok = inner.isVoidType();
    ok &= (kind == BuiltinKind.USize || kind == BuiltinKind.UInt64);

    if (!ok) {
        c.try_to_fix_type();
        c.diags.error(c.loc, "incompatible pointer to integer conversion '%s' to '%s'",
                c.rhs.diagName(), c.lhs.diagName());
        return false;
    }

    c.builder.insertImplicitCast(ImplicitCastKind.PointerToInteger, c.expr_ptr, g_usize);
    return true;
}

func bool Checker.checkPointer2Func(Checker* c, const Type* lcanon, const Type* rcanon) {
    // only allow if pointer is void*
    const PointerType* ptr = cast<PointerType*>(rcanon);
    QualType inner = ptr.getInner();
    if (!inner.isVoidType()) {
        c.diags.error(c.loc, "incompatible pointer to function conversion '%s' to '%s'",
                c.rhs.diagName(), c.lhs.diagName());
        return false;
    }
    c.builder.insertImplicitCast(ImplicitCastKind.BitCast, c.expr_ptr, c.lhs);
    return true;
}

// Note: try to fix array type that has been decayed to a pointer
func void Checker.try_to_fix_type(Checker* c) {
    Expr* e = *c.expr_ptr;

    if (e.isImplicitCast()) {
        const ImplicitCastExpr* ic = cast<ImplicitCastExpr*>(e);
        if (ic.isArrayToPointerDecay()) {
            e = ic.getInner();
            c.rhs = e.getType();
        }
    }
}

func bool Checker.checkPointers(Checker* c, const Type* lcanon, const Type* rcanon) {

    const PointerType* ltype = cast<PointerType*>(lcanon);
    const PointerType* rtype = cast<PointerType*>(rcanon);
/*
    if (ltype == rtype) { // this will only happen with AliasTypes
        printf("  SAME, diff quals\n");
        // TODO check quals
        return true;
    }
*/

    QualType linner = ltype.getInner();
    QualType rinner = rtype.getInner();
    // Note: no need to fully compare, since otherwise the pointers above would have been the same
    const Type* in1 = linner.getTypeOrNil();
    const Type* in2 = rinner.getTypeOrNil();
    if (in1 == in2) {
        u32 rquals = rinner.getQuals();
        if (rquals == 0) return true;

        u32 lquals = linner.getQuals();
        if (((~lquals) & rquals) & 0x3) {
            c.diags.error(c.loc, "pointer conversion discards const qualifier");
            return false;
        }
        return true;
    }

    // TODO dont allow ptr** -> void* or reverse
    if (in1.isVoidType()) return true; // ptr -> void* is allowed
    if (in2.isVoidType()) return true; // void* -> ptr is allowed


    // allow i8* -> char* and reverse
    if (linner.isInt8() && rinner.isChar()) return true;
    if (linner.isChar() && rinner.isInt8()) return true;

    // TODO check ptr-ptr, use ptr-inner-table

    c.try_to_fix_type();
    c.diags.error(c.loc, "invalid pointer conversion from '%s' to '%s'", c.rhs.diagName(), c.lhs.diagName());
    return false;
}

func bool Checker.checkEnum2Int(Checker* c, const Type* lcanon, const Type* rcanon) {
    // Note: enum constant values can never be negative
    const BuiltinType* bi = cast<BuiltinType*>(lcanon);
    u32 width = bi.getWidth();
    if (width == 64) return true;  // 64-bit

    // NOTE: EnumConstDecls are CTV, but variables of the type are not!
    if ((*c.expr_ptr).isCtv()) {
        return ctv_analyser.check(c.diags, c.lhs, *c.expr_ptr);
    } else {
        // compare impl type
        const EnumType* et = cast<EnumType*>(rcanon);
        const EnumTypeDecl* etd = et.getDecl();
        QualType impl = etd.getImplType();

        return c.check(c.lhs, impl, c.expr_ptr, c.loc);
    }

    return true;
}

func bool checkFunc2Func(const Type* lcanon, const Type* rcanon) {
    FunctionType* ftl = cast<FunctionType*>(lcanon);
    FunctionDecl* fdl = ftl.getDecl();
    FunctionType* ftr = cast<FunctionType*>(rcanon);
    FunctionDecl* fdr = ftr.getDecl();

    // compare rtype
    QualType ql = fdl.getRType();
    QualType qr = fdr.getRType();
    if (ql.ptr != qr.ptr) return false;

    u32 num1 = fdl.getNumParams();
    u32 num2 = fdr.getNumParams();
    if (num1 != num2) return false;

    Decl** args1 = cast<Decl**>(fdl.getParams());
    Decl** args2 = cast<Decl**>(fdr.getParams());
    for (u32 i=0; i<num1; i++) {
        Decl* a1 = args1[i];
        Decl* a2 = args2[i];
        ql = a1.getType();
        qr = a2.getType();
        if (ql.ptr != qr.ptr) return false;
    }

    if (fdl.isVariadic() != fdr.isVariadic()) return false;

    return true;
}




public func bool Checker.checkCast(Checker* c, QualType lhs, QualType rhs, SrcLoc lhsLoc, SrcLoc rhsLoc) {
    c.lhs = lhs;
    c.rhs = rhs;
    c.loc = lhsLoc;
    c.expr_ptr = nil;
    // NOTE: expr_ptr used in some calls below!!
    // TODO sometimes use rhsLoc
    if (lhsLoc == 0) c.loc = rhsLoc; // TEMP HACK

    QualType t1 = lhs.getCanonicalType();
    QualType t2 = rhs.getCanonicalType();
    const Type* lcanon = t1.getTypeOrNil();
    const Type* rcanon = t2.getTypeOrNil();

    u8 res = Conversions[rcanon.getKind()][lcanon.getKind()];
    switch (res) {
    case 0: // cannot happen
        c.diags.error(lhsLoc, "SHOULD NOT HAPPEN (%u - %u)\n", lcanon.getKind(), rcanon.getKind());
        c.lhs.dump_full();
        c.rhs.dump_full();
        assert(0);
        return false;
    case 1: // not allowed
        c.diags.error(c.loc, "invalid cast from '%s' to '%s'", c.rhs.diagName(), c.lhs.diagName());
        return false;
    case 2: //  2 = Builtin -> Builtin
        // Allow all, except to/from void
        return true;
    case 3: //  3 = Builtin -> Pointer (only if usize/u64/u32)
        return c.checkBuiltin2PointerCast(lcanon, rcanon);
    case 4: //  4 = Pointer -> Builtin (only if usize/u64/u32)
        return c.checkPointer2BuiltinCast(lcanon, rcanon);
    case 5: //  5 = Pointer -> Pointer
        return true;    // always allow
    case 6: //  6 = Pointer -> Func (void* or Func*)
        return true;    // always allow
    case 7: //  7 = Array -> Pointer
        c.diags.note(c.loc, "SHOULD NOT HAPPEN (Array -> Ptr)");
        assert(0);
        return false;
    case 8: //  8 = Array -> Array
        c.diags.error(lhsLoc, "SHOULD NOT HAPPEN (%u - %u)\n", lcanon.getKind(), rcanon.getKind());
        assert(0);
        return false;
    case 9: //  9 = Struct -> Struct
        c.diags.error(lhsLoc, "SHOULD NOT HAPPEN (%u - %u)\n", lcanon.getKind(), rcanon.getKind());
        assert(0);
        return false;
    case 10: // 10 = Enum -> Builtin
        return true;    // always allow
    case 11: // 11 = Func -> Pointer (void* or Func*)
        return true;    // always allow
    case 12: // Func -> Func
        return true;    // always allow
    case 13: // Builtin -> Enum
        return true;    // always allow
    case 14: // Enum -> Enum
        return true;    // always allow
    case 15: // Builtin -> Func
        return c.checkBuiltin2PointerCast(lcanon, rcanon);
    default:
        c.diags.note(c.loc, "TODO CONVERSION  %u)", res);
        return false;
    }

    return true;
}

func bool Checker.checkBuiltin2PointerCast(Checker* c, const Type* lcanon, const Type* rcanon) {
    // only allow cast from pointer-size int (u32/u64 depending on arch) to pointer
    u32 wordsize = ast.getWordSize();
    const BuiltinType* bi = cast<BuiltinType*>(rcanon);

    BuiltinKind kind = bi.getKind();
    if (kind == BuiltinKind.USize) return true;
    // Note: we dont allow cast from pointer to bool! (implicit conversion is ok)
    if (wordsize == 4 && kind == BuiltinKind.UInt32) return true;
    if (wordsize == 8 && kind == BuiltinKind.UInt64) return true;

    QualType valid = (wordsize == 8) ? g_u64 : g_u32;
    c.diags.error(c.loc, "only integers of type '%s' may be cast to a pointer", valid.diagName());

    return false;
}

func bool Checker.checkPointer2BuiltinCast(Checker* c, const Type* lcanon, const Type* rcanon) {
    // only allow cast from pointer to pointer-size int (u32/u64 depending on arch)
    u32 wordsize = ast.getWordSize();
    const BuiltinType* bi = cast<BuiltinType*>(lcanon);

    BuiltinKind kind = bi.getKind();
    if (kind == BuiltinKind.USize) return true;
    // Note: we dont allow cast from pointer to bool! (implicit conversion is ok)
    if (wordsize == 4 && kind == BuiltinKind.UInt32) return true;
    if (wordsize == 8 && kind == BuiltinKind.UInt64) return true;

    QualType valid = (wordsize == 8) ? g_u64 : g_u32;
    c.diags.error(c.loc, "pointers may only be cast to integer type '%s'", valid.diagName());

    return false;
}


/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module module_analyser;

import ast_context;
import ast_builder;
import ast local;
import attr;
import ctv_analyser;
import conversion_checker as conv;
import diagnostics;
import module_list;
import src_loc local;
import scope;
import string_pool;
import warning_flags;
import struct_func_list as sf_list;
import incr_array_list as ia_list;

import ctype;
import stdarg local;
import stdlib;
import string;

const u32 MaxDepth = 8;
const u32 LHS = 0x01;
const u32 RHS = 0x02;

public type Analyser struct {
    diagnostics.Diags* diags;
    conv.Checker checker;
    ast_context.Context* context;
    string_pool.Pool* astPool;
    ast_builder.Builder* builder;
    module_list.List* allmodules;
    const warning_flags.Flags* warnings;

    // variables below differs per run
    Module* mod;
    bool usedPublic;    // set to false during function body analysis or during non-public analysis

    // collect struct-functions
    u32 prefix_cache_name;
    u32 prefix_cache_idx;
    NameVector prefixes;
    sf_list.List* struct_decls;   // only set during SF collection

    ia_list.List* incr_values;   // only set during incremental-array value collection

    LabelVector labels;

    // Type + Vars analysis
    StackLayer[MaxDepth] checkStack;
    u32 checkIndex;
    scope.Scope* scope; // points to top layer in stack

    // for each function-body analysis
    FunctionDecl* curFunction; // set when analysing a function-body
    bool has_error;
} @(opaque)

public func Analyser* create(diagnostics.Diags* diags,
                             ast_context.Context* context,
                             string_pool.Pool* astPool,
                             ast_builder.Builder* builder,
                             module_list.List* allmodules,
                             const warning_flags.Flags* warnings)
{
    Analyser* ma = stdlib.calloc(1, sizeof(Analyser));
    ma.diags = diags;
    ma.checker.init(diags, builder);
    ma.context = context;
    ma.astPool = astPool;
    ma.builder = builder;
    ma.allmodules = allmodules;
    ma.warnings = warnings;
    return ma;
}

public func void Analyser.free(Analyser* ma) {
    ma.prefixes.free();  // Note: safe to be freed twice
    ma.labels.free();
    stdlib.free(ma);
}

public func void Analyser.check(Analyser* ma, Module* mod)
{
    ma.mod = mod;
    ma.prefix_cache_name = 0;
    ma.prefix_cache_idx = 0;
    ma.prefixes.free();  // Note: safe to be freed twice
    ma.labels.reset();
    ma.checkIndex = 0;
    ma.scope = nil;
    ma.curFunction = nil;
    ma.has_error = false;
    ma.usedPublic = false;

    mod.visitASTs(Analyser.createGlobalScope, ma);

    if (ma.diags.hasErrors()) return;

    // TODO use mod.visitArrayValues(Analyser.handleEnumValue, ma);

    ma.collectStructFunctions();
    if (ma.has_error) return;

    // analyse types
    ma.collectIncrementalArrays();

    if (ma.has_error) return;

    mod.visitTypeDecls(Analyser.handleTypeDecl, ma);

    mod.visitVarDecls(Analyser.handleVarDecl, ma);

    ma.usedPublic = false;
    mod.visitStaticAsserts(Analyser.handleStaticAssert, ma);

    mod.visitFunctions(Analyser.analyseFunctionProto, ma);

    if (ma.has_error) return;

    // TODO only for non-interface components
    mod.visitFunctions(Analyser.analyseFunctionBodies, ma);

    // check that exported modules only use other exported-modules publicly
    if (!mod.isExternal() && mod.isExported()) {
        mod.visitImports(Analyser.handleImport, ma);
    }

    mod.visitASTs(Analyser.deleteScope, ma);
}

func void Analyser.collectStructFunctions(Analyser* ma) {
    sf_list.List struct_decls = { }
    // Note: set temporarily pointer to local variable (used by visitor functions)
    ma.struct_decls = &struct_decls;
    ma.mod.visitStructFunctions(Analyser.handleStructFunc, ma);
    if (ma.has_error) return;

    for (u32 i=0; i<struct_decls.count; i++) {
        const sf_list.Info* info = &struct_decls.data[i];
        StructTypeDecl* fd = cast<StructTypeDecl*>(info.decl);
        fd.setStructFunctions(ma.context, info.functions.getDecls(), info.functions.size());
    }

    ma.prefixes.free();  // Note: free here already (safe to be freed twice)
    struct_decls.free();
    ma.struct_decls = nil;
}

func void Analyser.handleArrayValue(void* arg, ArrayValue* avd) {
    Analyser* ma = arg;
    ma.incr_values.add(avd.getNameIdx(), avd.getLoc(), avd.getValue());
}

func void Analyser.collectIncrementalArrays(Analyser* ma) {
    ia_list.List ialist = { }
    // Note: set temporarily pointer to local variable (used by visitor functions)
    ma.incr_values = &ialist;
    ma.mod.visitArrayValues(Analyser.handleArrayValue, ma);
    for (u32 i=0; i<ialist.count; i++) {
        ma.handleIncrEntry(&ialist.entries[i]);
    }
    ialist.free();
    ma.incr_values = nil;
}

func void Analyser.handleIncrEntry(Analyser* ma, ia_list.Info* entry) {
    u32 name = entry.name;
    // find array Decl
    Decl* d = ma.mod.findSymbol(name);
    if (!d) {
        ma.error(entry.loc, "module '%s' has no symbol '%s'", ma.mod.getName(), ast.idx2name(name));
        return;
    }
    // check if incremental array/enum
    if (d.isVariable()) {
        // Note: type has not been analysed yet, only use TypeRef
        VarDecl* vd = cast<VarDecl*>(d);
        TypeRef* ref = vd.getTypeRef();
        if (!ref.isIncrArray()) {
            ma.error(entry.loc, "'%s' is not an incremental array", ast.idx2name(name));
            ma.note(d.getLoc(), "'%s' is defined here", ast.idx2name(name));
            return;
        }

        // create an InitListExpr here and add to VarDecl, dont analyse yet
        u32 num_values = entry.values.size();
        Expr** values = entry.values.getExprs();
        Expr* init_expr = ma.builder.actOnInitList(0, 0, values, num_values);
        vd.setInit(init_expr);
    } else if (d.isEnum()) {
        // dont analyse yet, just check if Identifier and convert to EnumConstantDecl
        EnumTypeDecl* etd = cast<EnumTypeDecl*>(d);
        if (!etd.isIncremental()) {
            ma.error(entry.loc, "'%s' is not an incremental enum", ast.idx2name(name));
            ma.note(d.getLoc(), "'%s' is defined here", ast.idx2name(name));
            return;
        }

        u32 num_values = entry.values.size();
        Expr** values = entry.values.getExprs();
        bool error = false;
        for (u32 j=0; j<num_values; j++) {
            Expr* e = values[j];
            if (!e.isIdentifier()) {
                ma.error(e.getLoc(), "expected identifier");
                return;
            }
        }
        etd.setIncrConstants(ma.context, cast<IdentifierExpr**>(values), num_values);
    } else {
        ma.error(entry.loc, "'%s' is not an incremental array/enum", ast.idx2name(name));
        ma.note(d.getLoc(), "'%s' is defined here", ast.idx2name(name));
    }
}

func void Analyser.handleImport(void* arg, ast.ImportDecl* id) {
    Analyser* ma = arg;
    Decl* d = cast<Decl*>(id);
    if (!d.isUsedPublic()) return;

    Module* dest = id.getDest();
    if (dest.isExternal()) return;
    if (!dest.isExported()) {
        ma.error(d.getLoc(), "exported module '%s' publicly uses non-exported module '%s'", ma.mod.getName(), dest.getName());
    }
}

func void Analyser.setMod(Analyser* ma, Module* mod) {
    ma.mod = mod;
}

// TEMP here until we have templates
type NameVector struct {
    u32* data;
    u32 count;
    u32 capacity;
}

func void NameVector.init(NameVector* v, u32 capacity) {
    v.data = nil;
    v.count = 0;
    v.capacity = capacity / 2; // workaround resize
    v.resize();
}

func void NameVector.free(NameVector* v) {
    stdlib.free(v.data);
    v.count = 0;
    v.capacity = 0;
    v.data = nil;
}

func void NameVector.resize(NameVector* v) {
    v.capacity = v.capacity == 0 ? 4 : v.capacity * 2;
    void* data2 = stdlib.malloc(v.capacity * sizeof(u32));
    if (v.data) {
        string.memcpy(data2, v.data, v.count * sizeof(u32));
        stdlib.free(v.data);
    }
    v.data = data2;
}

func u32 NameVector.add(NameVector* v, u32 name_idx) {
    if (v.count == v.capacity) v.resize();

    u32 index = v.count;
    v.data[index] = name_idx;
    v.count++;
    return index;
}

func u32 NameVector.get(const NameVector* v, u32 idx) {
    return v.data[idx];
}

func bool NameVector.find(NameVector* v, u32 name_idx, u32* index) {
    for (u32 i=0; i<v.count; i++) {
        if (v.data[i] == name_idx) {
            *index = i;
            return true;
        }
    }
    return false;
}

// TEMP here until we have templates

type Label struct {
    u32 name_idx;
    SrcLoc loc;
    bool used;
    bool is_label; // otherwise goto
}

type LabelVector struct {
    Label* labels;
    u32 count;
    u32 capacity;
}

func void LabelVector.init(LabelVector* v, u32 capacity) {
    v.labels = nil;
    v.count = 0;
    v.capacity = capacity / 2; // workaround resize
}

func void LabelVector.free(LabelVector* v) {
    if (v.labels) stdlib.free(v.labels);
    v.count = 0;
    v.capacity = 0;
    v.labels = nil;
}

func void LabelVector.reset(LabelVector* v) {
    v.count = 0;
}

func void LabelVector.resize(LabelVector* v) {
    v.capacity = v.capacity == 0 ? 4 : v.capacity * 2;
    void* data2 = stdlib.malloc(v.capacity * sizeof(Label));
    if (v.labels) {
        string.memcpy(data2, v.labels, v.count * sizeof(Label));
        stdlib.free(v.labels);
    }
    v.labels = data2;
}

func Label* LabelVector.add(LabelVector* v, u32 name_idx, SrcLoc loc, bool is_label) {
    Label* l = v.find(name_idx);
    if (!l) {
        if (v.count == v.capacity) v.resize();

        u32 index = v.count;
        l = &v.labels[index];
        l.name_idx = name_idx;
        l.loc = loc;
        l.is_label = is_label;
        l.used = !is_label;
        v.count++;
    }
    return l;
}

func u32 LabelVector.getCount(const LabelVector* v) {
    return v.count;
}

func const Label* LabelVector.getLabels(const LabelVector* v) {
    return v.labels;
}

func Label* LabelVector.find(LabelVector* v, u32 name_idx) {
    for (u32 i=0; i<v.count; i++) {
        if (v.labels[i].name_idx == name_idx) return &v.labels[i];
    }
    return nil;
}



type StackLayer struct {
    Decl* decl;
    scope.Scope* scope;
    FunctionDecl* function; // only set when analysing function bodies
    bool usedPublic;
}

func void Analyser.note(Analyser* ma, SrcLoc loc, const char* format, ...) @(printf_format=3) {
    Va_list args;
    va_start(args, format);
    ma.diags.note2(loc, format, args);
    va_end(args);
}

func void Analyser.warn(Analyser* ma, SrcLoc loc, const char* format, ...) @(printf_format=3) {
    Va_list args;
    va_start(args, format);
    ma.diags.warn2(loc, format, args);
    va_end(args);
}

func void Analyser.error(Analyser* ma, SrcLoc loc, const char* format, ...) @(printf_format=3) {
    Va_list args;
    va_start(args, format);
    ma.diags.error2(loc, format, args);
    va_end(args);

    ma.has_error = true;
    // TODO use JmpBuf here? (dont have to check anything then)
}

func void Analyser.errorRange(Analyser* ma, SrcLoc loc, SrcRange range, const char* format, ...) @(printf_format=4) {
    Va_list args;
    va_start(args, format);
    ma.diags.errorRange2(loc, range, format, args);
    va_end(args);

    ma.has_error = true;
    // TODO use JmpBuf here? (dont have to check anything then)
}

func void Analyser.createGlobalScope(void* arg, AST* a) {
    Analyser* ma = arg;
    scope.Scope* s = scope.create(ma.allmodules,
                                  ma.diags,
                                  a.getImports(),
                                  ma.mod,
                                  ma.mod.getSymbols(),
                                  !ma.warnings.no_unused_variable);
    a.setPtr(s);
}

func void Analyser.deleteScope(void* /*arg*/, AST* a) {
    scope.Scope* s = a.getPtr();
    a.setPtr(nil);
    s.free();
}

func void Analyser.handleStructFunc(void* arg, FunctionDecl* fd) {
    Analyser* ma = arg;
    Ref* prefix = fd.getPrefix();
    Decl* d = cast<Decl*>(fd);
    assert(prefix);
    u32 prefix_name_idx = prefix.name_idx;

    assert(ma.struct_decls);
    u32 index = 0;
    if (prefix_name_idx == ma.prefix_cache_name) {
        index = ma.prefix_cache_idx;
    } else {
        // search data structure
        bool found = false;
        found = ma.prefixes.find(prefix_name_idx, &index);

        if (!found) {
            Decl* decl = ma.mod.findType(prefix_name_idx);
            if (!decl) {
                decl = ma.mod.findSymbol(prefix_name_idx);
                if (decl) {
                    ma.error(prefix.loc, "a struct-function type must be a struct/union");
                } else {
                    ma.error(prefix.loc, "module '%s' has no symbol '%s'", ma.mod.getName(), prefix.getName());
                }
                return;
            }
            if (!decl.isStructType()) {
                ma.error(prefix.loc, "a struct-function type must be a struct/union");
                return;
            }
            if (d.isPublic() && !decl.isPublic()) {
                ma.error(prefix.loc, "public struct-functions need a public struct/union");
                return;
            }
            index = ma.prefixes.add(prefix_name_idx);
            ma.struct_decls.addDecl(decl);
        }
        ma.prefix_cache_name = prefix_name_idx;
        ma.prefix_cache_idx = index;
    }

    // check for duplicate struct functions
    FunctionDecl* other = ma.struct_decls.findFunc(index, d.getNameIdx());
    if (other) {
        ma.error(d.getLoc(), "redefinition of '%s'", d.getFullName());
        ma.note(other.asDecl().getLoc(), "previous definition is here");
        return;
    }

    // check for name clashes with regular members
    prefix.decl = ma.struct_decls.getDecl(index);
    StructTypeDecl* std = cast<StructTypeDecl*>(prefix.decl);
    Decl* match = std.findMember(d.getNameIdx(), nil);
    if (match) {
        ma.error(match.getLoc(), "member '%s' conflicts with struct-function '%s'", match.getName(), d.getFullName());
        ma.note(d.getLoc(), "previous declaration is here");
        return;
    }

    ma.struct_decls.addFunc(index, fd);
}

func void Analyser.analyseFunctionProto(void* arg, FunctionDecl* d) {
    Analyser* ma = arg;

    ma.analyseGlobalDecl(cast<Decl*>(d));
}

func void Analyser.analyseFunctionBodies(void* arg, FunctionDecl* d) {
    Analyser* ma = arg;

    ma.analyseFunctionBody(d, d.asDecl().getAST().getPtr());
}

func bool Analyser.analyseGlobalDecl(Analyser* ma, Decl* d) {
    if (d.isChecked()) return true;

    if (!ma.pushCheck(d, d.getAST().getPtr(), nil)) return false;

    if (d.isExported() && !d.isPublic()) {
        ma.error(d.getLoc(), "attribute 'export' can only be applied to public declarations");
        return false;
    }

    // TODO note numErrors here and compare after, return before==after

    switch (d.getKind()) {
    case Function:
        ma.analyseFunction(cast<FunctionDecl*>(d));
        break;
    case Import:
        break;
    case StructType:
        ma.analyseStructType(cast<StructTypeDecl*>(d));
        break;
    case EnumType:
        ma.analyseEnumType(cast<EnumTypeDecl*>(d));
        break;
    case EnumConstant:
        assert(0);
        break;
    case FunctionType:
        ma.analyseFunctionType(d);
        break;
    case AliasType:
        ma.analyseAliasType(cast<AliasTypeDecl*>(d));
        break;
    case Var:
        ma.analyseGlobalVarDecl(cast<VarDecl*>(d));
        break;
    }

    d.setChecked();
    ma.popCheck();
    return true;
}

func void Analyser.handleTypeDecl(void* arg, Decl* d) {
    Analyser* ma = arg;
    ma.analyseGlobalDecl(d);
}

func void Analyser.handleStaticAssert(void* arg, StaticAssert* d) {
    Analyser* ma = arg;
    ma.scope = d.getAST().getPtr();

    StaticAssert* sa = cast<StaticAssert*>(d);
    Expr* lhs = sa.getLhs();
    Expr* rhs = sa.getRhs();

    QualType t1 = ma.analyseExpr(&lhs, false, RHS);
    QualType t2 = ma.analyseExpr(&rhs, false, RHS);
    if (t1.isInvalid() || t2.isInvalid()) return;

    bool error = false;
    if (!lhs.isCtv()) {
        ma.errorRange(lhs.getLoc(), lhs.getRange(), "static_assert element is not a compile-time value");
        error = true;
    }
    if (!rhs.isCtv()) {
        ma.errorRange(rhs.getLoc(), rhs.getRange(), "static_assert element is not a compile-time value");
        error = true;
    }

    if (error) return;

    Value val1 = ctv_analyser.get_value(lhs);
    Value val2 = ctv_analyser.get_value(rhs);

    if (!val1.equals(&val2)) {
        ma.errorRange(rhs.getStartLoc(), rhs.getRange(), "static_assert failed, expected %s, got %s", val1.str(), val2.str());
    }
}

func void Analyser.handleVarDecl(void* arg, VarDecl* v) {
    Analyser* ma = arg;
    ma.analyseGlobalDecl(v.asDecl());
}

func void Analyser.checkName(Analyser* ma, Decl* d, bool is_constant) {
    const char* name = d.getName();
    if (is_constant) {
        if (ctype.islower(name[0])) {
            ma.error(d.getLoc(), "a global constant name must start with an upper case character");
        }
    } else {
        if (ctype.isupper(name[0])) {
            ma.error(d.getLoc(), "a variable name must start with a lower case character");
        }
    }
}

func void Analyser.analyseGlobalVarDecl(Analyser* ma, VarDecl* v) {
    Decl* d = cast<Decl*>(v);

    // Note: d.getType() is 0 here! (use refType)
    TypeRef* ref = v.getTypeRef();

    Expr* init_expr = v.getInit();
    // convert incremental array types to normal ones
    QualType res;
    if (ref.isIncrArray()) {
        u32 size = 0;
        if (init_expr) {
            InitListExpr* ile = cast<InitListExpr*>(init_expr);
            size = ile.getNumValues();
        }
        res = ma.analyseIncrTypeRef(ref, size);
    } else {
        res = ma.analyseTypeRef(ref);
    }
    if (res.isInvalid()) return;

    QualType canon = res.getCanonicalType();
    if (canon.isVoid()) {
        ma.error(ref.getLoc(), "%s has invalid type 'void'", res.isConst() ? "constant" : "variable");
        return;
    }
    if (canon.isArray() && !ref.isIncrArray()) {
        const ArrayType* at = canon.getArrayType();
        if (at.hasSize()) {
            if (at.getSize() == 0) {
                ma.error(ref.getLoc(), "only struct members may have array size zero");
                return;
            }
        } else {
            if (!init_expr) {
                ma.error(d.getLoc(), "array-type variable '%s' needs an explicit size or an initializer", d.getFullName());
                return;
            }
        }
    }

    d.setType(res);

    ma.checkName(d, res.isConstant());

    if (d.isPublic()) setTypePublicUsed(res);

    if (init_expr) {
        if (!res.isConstant()) {
            ma.checkStack[ma.checkIndex-1].usedPublic = false;
            ma.usedPublic = false;
        }
        ma.analyseInitExpr(v.getInit2(), res, v.getAssignLoc());
    } else {
        if (res.isConstant()) {
            ma.error(d.getLoc(), "constant variable '%s' must be initialized", d.getFullName());
        }
    }

    ma.checkVarDeclAttributes(v);
}

func void Analyser.checkVarDeclAttributes(Analyser* ma, VarDecl* v) {
    Decl* d = cast<Decl*>(v);
    QualType qt = d.getType();
    if (qt.isConst() && qt.isBuiltin()) {
        if (v.hasAttrWeak()) {
            ma.error(d.getLoc(), "attribute 'weak' cannot be applied to constants");
        }
        if (!d.hasAttr()) return;

        const AST* a = d.getAST();

        const attr.Value* section = a.getAttr(d, attr.AttrKind.Section);
        if (section) {
            ma.error(section.loc, "attribute 'section' cannot be applied to constants");
        }

        const attr.Value* aligned = a.getAttr(d, attr.AttrKind.Aligned);
        if (aligned) {
            ma.error(aligned.loc, "attribute 'aligned' cannot be applied to constants");
        }
    }
}

// Note: fd is only set if analysing function bodies
func bool Analyser.pushCheck(Analyser* ma, Decl* d, scope.Scope* s, FunctionDecl* fd) {
    for (u32 i=0; i<ma.checkIndex; i++) {
        if (ma.checkStack[i].decl == d) {
            for (u32 j=i; j<ma.checkIndex; j++) {
                ma.error(d.getLoc(), "circular declaration dependency '%s'", d.getName());
            }
            // TODO use longjmp here?
            return false;
        }
    }
    // set correct scope for the current Decl (might be in different file than current Decl)
    ma.scope = s;
    StackLayer* top = &ma.checkStack[ma.checkIndex];
    top.decl = d;
    top.scope = ma.scope;
    top.function = fd;
    top.usedPublic = d.isPublic();
    if (fd) ma.curFunction = fd;
    ma.usedPublic = top.usedPublic;
    ma.checkIndex++;
    // for function bodies
    if (!d.isChecked()) d.setCheckState(DeclCheckState.InProgress);
    assert(ma.checkIndex <= MaxDepth);
    return true;
}

func void Analyser.popCheck(Analyser* ma) {
    assert(ma.checkIndex > 0);
    ma.checkIndex--;
    if (ma.checkIndex > 0) {
        StackLayer* top = &ma.checkStack[ma.checkIndex-1];
        ma.scope = top.scope;
        ma.curFunction = top.function;
        ma.usedPublic = top.usedPublic;
    } else {
        ma.scope = nil;
        ma.curFunction = nil;
    }
}

func bool Analyser.globalScope(const Analyser* ma) {
    return ma.curFunction == nil;
}

type MainMarker struct {
    u32 name_idx;
    Decl* main;
}

func void findMainFunction(void* arg, FunctionDecl* fd) {
    MainMarker* m = (arg);
    Decl* d = cast<Decl*>(fd);
    if (d.getNameIdx() == m.name_idx) {
        if (m.main) {
            //ma.error(d.getLoc(), "duplicate main function");
            // TODO prev
            return;
        }
        m.main = d;
    }
}

public func Decl* Analyser.findMain(Analyser* ma, Module* top, u32 name_idx) {
    top.setUsed();
    MainMarker marker = { name_idx, nil }
    top.visitFunctions(findMainFunction, &marker);
    if (marker.main) {
        marker.main.setUsed();
        marker.main.setUsedPublic();
        marker.main.setAttrExport();

        // TODO check return type + args
    }

    return marker.main;
}


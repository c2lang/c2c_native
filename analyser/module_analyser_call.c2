/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module module_analyser;

import ast local;
import ctype;
import scope;
import src_loc local;

import stdio;

func QualType Analyser.analyseCallExpr(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    CallExpr* call = cast<CallExpr*>(e);
    Expr** fn = call.getFunc2();
    Expr* origFn = call.getFunc();  // store here to avoid the likely inserted FunctionPointerDecay cast
    QualType qt = ma.analyseExpr(fn, true, RHS);
    if (qt.isInvalid()) return QualType_Invalid;

    if (origFn.isNValue()) {
        ma.errorRange(origFn.getLoc(), origFn.getRange(), "called object is not a function of function pointer");
        return QualType_Invalid;
    }

    FunctionType* ft = qt.getFunctionTypeOrNil();
    if (!ft) {
        Expr* fn2 = call.getFunc();
        ma.errorRange(fn2.getLoc(), fn2.getRange(), "called object type %s is not a function or function pointer", qt.diagName());

        return QualType_Invalid;
    }

    /* two ways of calling a struct function:
        1. Struct.test(s);
        2. Struct s; s.test();
    */

    FunctionDecl* fd = ft.getDecl();
    fd.asDecl().setUsed();

    if (fd.isTemplate()) {
        if (!call.getTemplateArg()) {
            ma.errorRange(e.getLoc(), e.getRange(), "function %s requires a template argument", fd.asDecl().getFullName());
            return QualType_Invalid;
        }
        fd = ma.instantiateTemplateFunction(call, fd);
        if (!fd) return QualType_Invalid;
    } else {
        if (call.getTemplateArg()) {
            ma.errorRange(e.getLoc(), e.getRange(), "function %s is not a template function", fd.asDecl().getFullName());
            return QualType_Invalid;
        }
    }

    u32 func_num_args = fd.getNumParams();
    u32 call_num_args = call.getNumArgs();

    u32 funcIndex = 0;

    bool isStructFuncCall = false;  // Not for static struct functions!
    SrcLoc loc = e.getLoc();

    QualType baseType;
    if (origFn.isMember()) {
        // Note: use origFn to avoid the added FunctionPointerDecay cast
        const MemberExpr* m = cast<MemberExpr*>(origFn);
        if (m.isStaticStructFunc()) {
            call.setCallsStaticStructFunc();
        }
        if (m.isStructFunc()) {
            isStructFuncCall = true;
            call.setCallsStructFunc();
            baseType = m.getBaseType();
            loc = m.getEndLoc();
            func_num_args--;
            funcIndex = 1;
        }
    }

    VarDecl** func_args = fd.getParams();
    Expr** call_args = call.getArgs();

    if (isStructFuncCall) {
        assert(fd.getNumParams() >= 1);
        // check for pointer conversion (const -> non-const)
        VarDecl* arg0 = func_args[0];
        QualType expectedType = arg0.asDecl().getType();
        // make it pointer type if not, because struct function calls are allowed on non-ptr type
        if (!baseType.isPointer()) {
            baseType = ma.builder.actOnPointerType(baseType);
        }
        // TODO FIX loc, will always be memberExpr, so loc should be last one in member
        bool ok = ma.checker.check(expectedType, baseType, e_ptr, loc);
        if (!ok) return QualType_Invalid;
    }

    u32 min_args = (func_num_args < call_num_args) ? func_num_args : call_num_args;

    for (u32 i=0; i<min_args; i++) {
        QualType callType = ma.analyseExpr(&call_args[i], true, RHS);
        if (callType.isInvalid()) return QualType_Invalid;

        VarDecl* vd = func_args[funcIndex];

        Expr* call_arg = call_args[i];
        bool ok = ma.checker.check(vd.asDecl().getType(), callType, &call_args[i], call_arg.getLoc());
        if (!ok) return QualType_Invalid;
        funcIndex++;
    }

    if (call_num_args > func_num_args) {
        if (!fd.isVariadic()) {
            Expr* call_arg = call_args[func_num_args];
            ma.error(call_arg.getLoc(), "too many arguments to %sfunction call, expected %u, have %u", fd.getDiagKind(), func_num_args, call_num_args);
            ma.note(fd.asDecl().getLoc(), "'%s' declared here", fd.asDecl().getFullName());
            return QualType_Invalid;
        }
        for (u32 i=min_args; i<call_num_args; i++) {
            QualType callType = ma.analyseExpr(&call_args[i], true, RHS);
            if (callType.isInvalid()) return QualType_Invalid;
            if (callType.isVoid()) {
                Expr* call_arg = call_args[i];
                ma.error(call_arg.getLoc(), "passing 'void' as variadic argument is invalid");
                return QualType_Invalid;
            }
        }
    } else if (call_num_args < func_num_args) {
        ma.error(call.getEndLoc(), "too few arguments to %sfunction call, expected %u, have %u", fd.getDiagKind(), func_num_args, call_num_args);
        ma.note(fd.asDecl().getLoc(), "'%s' declared here", fd.asDecl().getFullName());
        return QualType_Invalid;
    }

    if (fd.isVariadic()) {
        u8 printf_arg = fd.getAttrPrintf();
        if (printf_arg) {
            u32 format_idx = printf_arg -1;
            if (isStructFuncCall) format_idx--;
            ma.checkPrintArgs(call_args[format_idx], call_num_args - format_idx -1, &call_args[format_idx+1]);
        }
    }

    return fd.getRType();
}

func const char* get_format_text(Expr* format, SrcLoc* format_loc) {
    const char* format_text = nil;
    switch (format.getKind()) {
    case StringLiteral:
        StringLiteral* s = cast<StringLiteral*>(format);
        format_text = s.getText();
        *format_loc = format.getLoc() + 1;
        break;
    case Identifier:
        QualType qt = format.getType();
        assert(qt.isArray());
        ArrayType* at = qt.getArrayType();
        qt = at.getElemType();
        if (!qt.isConst()) return nil;

        IdentifierExpr* id = cast<IdentifierExpr*>(format);
        Decl* decl = id.getDecl();
        assert(decl.isVariable());
        VarDecl* vd = cast<VarDecl*>(decl);
        Expr* initExpr = vd.getInit();
        assert(initExpr);
        return get_format_text(initExpr, format_loc);
    case Member:
        QualType qt = format.getType();
        assert(qt.isArray());
        ArrayType* at = qt.getArrayType();
        qt = at.getElemType();
        if (!qt.isConst()) return nil;

        MemberExpr* m = cast<MemberExpr*>(format);
        Decl* decl = m.getFullDecl();
        assert (decl.isVariable());
        VarDecl* vd = cast<VarDecl*>(decl);
        Expr* initExpr = vd.getInit();
        assert(initExpr);
        return get_format_text(initExpr, format_loc);
    default:
        assert(0);
        break;
    }
    return format_text;
}

type Specifier enum u8 {
    Other,          // %% or unknown
    String,         // %s, %-s, %4s
    Char,           // %c
    Integer,        // %i, %-i, %-8i, %08i, %x, %o
    FloatingPoint,  // %f
    Pointer,        // %p
    Invalid,        // other
}

// cp points after first %
func Specifier getFormatSpecifier(const char* specifier, u32* len) {
    const char* cp = specifier;
    while (1) {
        switch (*cp) {
        case '*':
            // TODO support %*d -> * is extra arg specifying width
            assert(0);
            break;
        case '%':
            // only if it is first char
            cp++;
            *len = cast<u32>(cp - specifier);
            if (*len == 1) return Specifier.Other;
            return Specifier.Invalid;
        case 'c':
            cp++;
            *len = cast<u32>(cp - specifier);
            return Specifier.Char;
        case 'f':
            cp++;
            *len = cast<u32>(cp - specifier);
            return Specifier.FloatingPoint;
        case 'p':
            cp++;
            *len = cast<u32>(cp - specifier);
            return Specifier.Pointer;
        case 's':
            cp++;
            *len = cast<u32>(cp - specifier);
            return Specifier.String;
        case 'd': fallthrough;
        case 'o': fallthrough;
        case 'x': fallthrough;
        case 'X':
            cp++;
            *len = cast<u32>(cp - specifier);
            return Specifier.Integer;
        default:
            if (ctype.isalpha(*cp)) {
                cp++;
                *len = cast<u32>(cp - specifier);
                return Specifier.Invalid;
            }
            break;
        }
        cp++;
    }
    return Specifier.Other;
}

func void Analyser.checkPrintArgs(Analyser* ma, Expr* format, u32 num_args, Expr** args) {
    // if format is StringLiteral or vardecl of type char[], it will wrapped in ArrayToPointerDecay
    // otherwise it's a VarDecl of type (const) char* we cannot check
    assert(format.isImplicitCast());
    ImplicitCastExpr* ic = cast<ImplicitCastExpr*>(format);
    if (!ic.isArrayToPointerDecay()) return;
    format = ic.getInner();

    SrcLoc format_loc;
    const char* format_text = get_format_text(format, &format_loc);
    if (!format_text) return;

    const char* cp = format_text;
    u32 idx = 0;
    while (*cp) {
        if (*cp == '%') {
            u32 len = 0;
            cp++;
            Specifier s = getFormatSpecifier(cp, &len);
            if (s != Specifier.Other && idx >= num_args) {
                u32 offset = cast<u32>(cp - format_text);
                ma.error(format_loc + offset, "too many format specifiers or not enough arguments");
                return;
            }
            QualType qt = args[idx].getType();
            switch (s) {
            case Other:
                break;
            case String:
                if (!qt.isCharPointer()) {
                    ma.error(args[idx].getLoc(), "format '%%s' expects a string argument");
                }
                break;
            case Char:
                // TODO check can be more efficient
                if (!qt.isChar() && !qt.isInt8() && !qt.isUInt8()) {
                    ma.error(args[idx].getLoc(), "format '%%c' expects a character argument");
                }
                break;
            case Integer:
                BuiltinType* bi = qt.getBuiltinTypeOrNil();
                if (!bi || !bi.isIntegerOrBool()) {
                    char c = cp[len-1];
                    ma.error(args[idx].getLoc(), "format '%%%c' expects an integer argument", c);
                }
                break;
            case FloatingPoint:
                // TODO
                break;
            case Pointer:
                if (!qt.isPointer()) {
                    ma.error(args[idx].getLoc(), "format '%%p' expects a pointer argument");
                }
                break;
            case Invalid:
                char c = cp[len-1];
                u32 offset = cast<u32>(cp - format_text) -1;
                switch (c) {
                case 'i': fallthrough;
                case 'l': fallthrough;
                case 'u':
                    ma.error(format_loc + offset, "invalid format specifier '%%%c', did you mean '%%d'?", c);
                    break;
                default:
                    ma.error(format_loc + offset, "invalid format specifier '%%%c'", c);
                    break;
                }
                return;
            }

            cp += len;
            if (s != Specifier.Other) idx++;
        } else {
            cp++;
        }
    }
    if (idx < num_args) {
        ma.error(args[idx].getLoc(), "too many arguments for format");
    }
}

func void create_template_name(char* name, const char* orig, u16 idx) {
    stdio.sprintf(name, "%s_%u_", orig, idx);
}

func void Analyser.opaque_callback(void* arg, SrcLoc loc, Decl* d) {
    Analyser* ma = arg;
    QualType qt = d.getType(); // lazy way to get from decl -> fullname
    ma.error(loc," using opaque type '%s'", qt.diagName());
}

func FunctionDecl* Analyser.instantiateTemplateFunction(Analyser* ma, CallExpr* call, FunctionDecl* fd) {
    TypeRef* template_arg = call.getTemplateArg();
    QualType templateType = ma.analyseTypeRef(template_arg);
    if (templateType.isInvalid()) return nil;

    FunctionDecl* instance = ma.mod.findInstance(fd, templateType);
    if (!instance) {
        // note: template_arg decl is set here
        bool used_opaque = false;
        StructType* st = templateType.getStructTypeOrNil();
        if (st) {
            StructTypeDecl* std = st.getDecl();
            Decl* d = cast<Decl*>(std);
            used_opaque = (std.isOpaque() && d.getModule() != ma.mod);
        }
        Instantiator inst = {
            .c = ma.context,
            .ref = template_arg,
            .template_name = fd.getTemplateNameIdx(),
            .used_opaque = used_opaque,
            .arg = ma,
            .on_error = Analyser.opaque_callback,
        }
        instance = fd.instantiate(&inst);
        Decl* d = cast<Decl*>(instance);
        ma.analyseFunction(instance);
        if (ma.has_error) return nil;
        d.setChecked();

        // Note: we need a separate scope for the body
        Module* template_mod = fd.asDecl().getModule();
        Analyser* analyser = create(ma.diags, ma.context, ma.astPool, ma.builder, ma.allmodules, ma.warnings);
        analyser.setMod(template_mod);
        scope.Scope* tmpScope = scope.create(ma.allmodules,
                                             ma.diags,
                                             d.getAST().getImports(),
                                             template_mod,
                                             template_mod.getSymbols(),
                                             !ma.warnings.no_unused_variable);
        analyser.analyseFunctionBody(instance, tmpScope);
        tmpScope.free();
        analyser.free();

        if (ma.has_error) return nil;

        u16 instance_idx = ma.mod.addInstance(fd, templateType, instance);
        instance.setTemplateInstanceIdx(instance_idx);
        char[64] name;
        create_template_name(name, d.getName(), instance_idx);
        instance.setInstanceName(ma.astPool.addStr(name, true));
    }
    call.setTemplateIdx(instance.getTemplateInstanceIdx());

    return instance;
}


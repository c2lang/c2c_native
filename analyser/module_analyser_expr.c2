/* Copyright 2022 Bas van den Berg
*/

module module_analyser;

import ast_context;
import ast local;
import ctv_analyser;
import source_mgr;

import string;
import stdlib;
import stdio; // TEMP

func QualType ModuleAnalyser.analyseExpr(ModuleAnalyser* ma, Expr* e) {
    switch (e.getKind()) {
    case ExprKind.IntegerLiteral:
        // TODO determine kind based on value, for now just return u32
        return g_u32;
    case ExprKind.BooleanLiteral:
        return g_bool;
    case ExprKind.CharLiteral:
        return g_i8;
    case ExprKind.StringLiteral:
        // char* (const?)
        break;
    case ExprKind.Nil:
        // void*
        break;
    case ExprKind.Identifier:
        return ma.analyseIdentifier(cast<IdentifierExpr*>(e));
    case ExprKind.Type:
        break;
    case ExprKind.Call:
        break;
    case ExprKind.InitList:
        // TODO need to know type
        break;
    case ExprKind.FieldDesignatedInit:
        break;
    case ExprKind.ArrayDesignatedInit:
        break;
    case ExprKind.BinaryOperator:
        break;
    case ExprKind.UnaryOperator:
        return ma.analyseUnaryOperator(cast<UnaryOperator*>(e));
    case ExprKind.ConditionalOperator:
        break;
    case ExprKind.Builtin:
        return ma.analyseBuiltin(cast<BuiltinExpr*>(e));
    case ExprKind.ArraySubscript:
        break;
    case ExprKind.Member:
        break;
    case ExprKind.Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        return ma.analyseExpr(p.getInner());
    case ExprKind.BitOffset:
        break;
    case ExprKind.ExplicitCast:
        break;
    case ExprKind.ImplicitCast:
        break;
    }
    return QualType.init0();
}

func QualType ModuleAnalyser.analyseIdentifier(ModuleAnalyser* ma, IdentifierExpr* e) {
    Decl* d = ma.scope.find(e.getNameIdx());
    if (!d) return QualType.init0();

    if (!d.isChecked()) {
        // TODO need to have correct scope
        ma.analyseGlobalDecl(d);
        // TODO need result
    }
    // if function, mark is CTC / CTV

    return QualType.init0();
}

func QualType ModuleAnalyser.analyseUnaryOperator(ModuleAnalyser* ma, UnaryOperator* e) {
    QualType t = ma.analyseExpr(e.getInner());
    if (t.isInvalid()) return QualType.init0();

    // TODO need rvalue stuff
    switch (e.getKind()) {
    case UnaryOpcode.PostInc:
        break;
    case UnaryOpcode.PostDec:
        break;
    case UnaryOpcode.PreInc:
        break;
    case UnaryOpcode.PreDec:
        break;
    case UnaryOpcode.AddrOf:
        // TODO check inner
        e.asExpr().isCtc();
        break;
    case UnaryOpcode.Deref:
        break;
    case UnaryOpcode.Minus:
        // TODO check inner
        e.asExpr().copyConstantFlags(e.getInner());
        break;
    case UnaryOpcode.Not:
        // TODO check inner
        e.asExpr().copyConstantFlags(e.getInner());
        break;
    case UnaryOpcode.LNot:
        // TODO check inner
        e.asExpr().copyConstantFlags(e.getInner());
        break;
    }
    return QualType.init0();
}

func QualType ModuleAnalyser.analyseBuiltin(ModuleAnalyser* ma, BuiltinExpr* e) {
    switch (e.getKind()) {
    case BuiltinExprKind.Sizeof:
        return ma.analyseSizeof(e);
    case BuiltinExprKind.Elemsof:
        break;
    case BuiltinExprKind.EnumMin:
        break;
    case BuiltinExprKind.EnumMax:
        break;
    case BuiltinExprKind.OffsetOf:
        break;
    case BuiltinExprKind.ToContainer:
        break;
    }

    return QualType.init0();
}

func QualType ModuleAnalyser.analyseSizeof(ModuleAnalyser* ma, BuiltinExpr* e) {
    Expr* inner = e.getInner();
    assert(inner);
    // TODO switch
    if (inner.getKind() == ExprKind.Type) {
        TypeExpr* te = cast<TypeExpr*>(inner);
        QualType qt = te.getType();
        // TODO
        e.setValue(4);
    }
    return QualType.init0();
}


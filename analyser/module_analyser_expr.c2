/* Copyright 2022 Bas van den Berg
*/

module module_analyser;

import ast local;
import ast_builder;
import size_analyser;
import src_loc local;

import stdio local; // TEMP

// TODO move to AnalyserUtils
func QualType getPointerFromArray(ast_builder.Builder* builder, QualType q) {
    // Dont get canonical
    const ArrayType* a = cast<ArrayType*>(q.getTypeOrNil());
    QualType elem = a.getElemType();
    QualType res = builder.actOnPointerType(elem);
    return res;
}

func QualType Analyser.analyseExpr(Analyser* ma, Expr** e_ptr, bool need_rvalue) {
    assert(e_ptr);
    QualType result = ma.analyseExprInner(e_ptr);
    if (result.isInvalid()) return result;

    Expr* e = *e_ptr;
    e.setType(result);

    if (need_rvalue && e.isLValue()) {
        QualType qt = result;

        if (qt.isArrayType()) {
            result = getPointerFromArray(ma.builder, qt);
            ma.builder.insertImplicitCast(ImplicitCastKind.ArrayToPointerDecay, e_ptr, result);
        } else {
            ma.builder.insertImplicitCast(ImplicitCastKind.LValueToRValue, e_ptr, qt);
        }
    }

    return result;
}

func QualType Analyser.analyseExprInner(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;

    switch (e.getKind()) {
    case IntegerLiteral:
        return e.getType();
    case BooleanLiteral:
        return g_bool;
    case CharLiteral:
        return g_i8;
    case StringLiteral:
        return e.getType(); // already set in creator
    case Nil:
        return g_void_ptr;
    case Identifier:
        Decl* d = ma.analyseIdentifier(e_ptr);
        if (!d) break;
        return d.getType();
    case Type:
        break;
    case Call:
        return ma.analyseCallExpr(e_ptr);
    case InitList:
        (*e_ptr).dump();
        assert(0);
        break;
    case FieldDesignatedInit:
        (*e_ptr).dump();
        assert(0);
        break;
    case ArrayDesignatedInit:
        assert(0);
        break;
    case BinaryOperator:
        return ma.analyseBinaryOperator(e_ptr);
    case UnaryOperator:
        return ma.analyseUnaryOperator(e_ptr);
    case ConditionalOperator:
        break;
    case Builtin:
        return ma.analyseBuiltin(e_ptr);
    case ArraySubscript:
        return ma.analyseArraySubscriptExpr(e_ptr);
    case Member:
        return ma.analyseMemberExpr(e_ptr);
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        QualType qt = ma.analyseExpr(p.getInner2(), false);
        e.copyConstantFlags(p.getInner());
        return qt;
    case BitOffset:
        break;
    case ExplicitCast:
        return ma.analyseExplicitCast(e_ptr);
    case ImplicitCast:
        break;
    }
    return QualType_Invalid;
}

func Decl* Analyser.analyseIdentifier(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    IdentifierExpr* i = cast<IdentifierExpr*>(e);
    Decl* d = ma.scope.find(i.getNameIdx(), e.getLoc());
    if (!d) {
        ma.has_error = true;
        return nil;
    }

    if (!d.isChecked()) {
        ma.analyseGlobalDecl(d);
        // TODO need result
    }

    QualType qt = d.getType();
    assert(qt.isValid());
    e.setType(qt);
    i.setDecl(d);
    d.setUsed();

    IdentifierKind kind = ma.setExprFlags(e_ptr, d);
    i.setKind(kind);

    if (e.isCtv()) e.setRValue();

    return d;
}

func QualType Analyser.analyseCallExpr(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    CallExpr* call = cast<CallExpr*>(e);
    Expr** fn = call.getFunc2();
    QualType qt = ma.analyseExpr(fn, true);
    if (qt.isInvalid()) return QualType_Invalid;

    FunctionType* ft = qt.getFunctionTypeOrNil();
    if (!ft) {
        Expr* fn2 = call.getFunc();
        ma.errorRange(fn2.getLoc(), fn2.getRange(), "called object type %s is not a function or function pointer", qt.diagName(false));

        return QualType_Invalid;
    }

    FunctionDecl* fd = ft.getDecl();
    fd.asDecl().setUsed();

    u32 func_num_args = fd.getNumParams();
    u32 call_num_args = call.getNumArgs();

    u32 funcIndex = 0;
    u32 callIndex =0;

    /* two ways of calling a struct function:
        1. Struct.test(s);
        2. Struct s;
           s.test();
    */

    Expr** call_args = call.getArgs();
    for (u32 i=0; i<call_num_args; i++) {
        ma.analyseExpr(&call_args[i], true);
    }
    // TODO analyse args

    return fd.getRType();
}

func IdentifierKind Analyser.setExprFlags(Analyser* ma, Expr** e_ptr, Decl* d) {
    Expr* e = *e_ptr;
    IdentifierKind kind = IdentifierKind.Unresolved;
    switch (d.getKind()) {
    case Function:
        e.setCtc();
        e.setRValue();
        ma.builder.insertImplicitCast(ImplicitCastKind.FunctionToPointerDecay, e_ptr, d.getType());
        const FunctionDecl* fd = cast<FunctionDecl*>(d);
        if (fd.hasPrefix()) kind = IdentifierKind.StructFunction;
        else kind = IdentifierKind.Function;
        break;
    case Import:
        e.setCtc();
        e.setRValue();
        kind = IdentifierKind.Module;
        break;
    case StructType:
        e.setRValue();
        kind = IdentifierKind.Type;
        break;
    case EnumType:
        e.setCtc();
        e.setRValue();
        kind = IdentifierKind.Type;
        break;
    case EnumConstant:
        e.setCtc();
        e.setCtv();
        kind = IdentifierKind.EnumConstant;
        break;
    case FunctionType:
        e.setCtc();
        kind = IdentifierKind.Type;
        break;
    case AliasType:
        kind = IdentifierKind.Type;
        break;
    case Var:
        VarDecl* vd = cast<VarDecl*>(d);
        QualType t = vd.asDecl().getType();
        e.setCtc();
        const Expr* init_ = vd.getInit();
        if (init_ && t.isConst() && init_.isCtv()) e.setCtv();
        switch (vd.getKind()) {
        case GlobalVar: fallthrough;
        case LocalVar:  fallthrough;
        case FunctionParam:
            kind = IdentifierKind.Var;
            break;
        case StructMember:
            kind = IdentifierKind.StructMember;
            break;
        }
        break;
    case StaticAssert:
        break;
    }
    return kind;
}

// Note: this function should only be called from analyseInitListArray directly!
func bool Analyser.analyseArrayDesignatedInit(Analyser* ma, Expr* e, QualType expectedType) {
    ArrayDesignatedInitExpr* ad = cast<ArrayDesignatedInitExpr*>(e);

    Expr* bb = ad.getDesignator();
    QualType qt = ma.analyseExpr(ad.getDesignator2(), false);
    if (qt.isInvalid()) return false;

    Expr* de = ad.getDesignator();
    if (!de.isCtv()) {
        ma.diags.reportRange(de.getLoc(), de.getRange(), "array index is not a compile-time value");
        return false;
    }

    qt = ma.analyseExpr(ad.getInit2(), false);
    if (qt.isInvalid()) return false;

    Expr* val = ad.getInit();

    if (!ma.curFunction) {
        if (!val.isCtc()) {
            ma.diags.reportRange(val.getLoc(), val.getRange(), "initializer element is not a compile-time constant");
            return false;
        }

        if (!val.isCtv() && expectedType.needsCtvInit()) {
            ma.diags.reportRange(val.getLoc(), val.getRange(), "initializer element is not a compile-time value");
            return false;
        }
    }

    ma.checker.check(expectedType, qt, ad.getInit2(), val.getLoc());

    val = ad.getInit(); // re-read because of ImplicitCasts
    e.copyConstantFlags(val);
    e.setType(expectedType);
    return true;
}

func bool validBinOpKind(QualType t) {
    switch (t.getKind()) {
    case Builtin:
        return true;
    case Pointer:
        return true;
    case Array:
        assert(0);
        break;
    case Struct:
        // valid for a = b
        break;
    case Enum:
        return true;
    case Function:
        break;
    case Alias:
        return validBinOpKind(t.getCanonicalType());
    case Module:
        break;
    }
    return false;
}

/*
    // convert aliasType + enum to impl for check
    // ignoring Floats for now
    Multiply,       int
    Divide          int
    Reminder,       int
    Add,            ptr(l/r), int
    Subtract,       ptr(l/r/both), int
    ShiftLeft,      int
    ShiftRight,     int
    LessThan,       ptr(both), int (both)
    GreaterThan,    ptr(both), int (both)
    LessEqual,      ptr(both), int (both)
    GreaterEqual,   ptr(both), int (hoth)
    Equal,          ptr(both), int (both)
    NotEqual,       ptr(both), int (both)
    And,            int
    Xor,            int
    Or,             int
    LAnd,           ptr, int
    LOr,            ptr, int
    Assign,         struct(both), ptr, int
    MulAssign,      int
    DivAssign,      int
    RemAssign,      int
    AddAssign,      ptr(l), int
    SubASsign,      ptr(l), int
    ShlAssign,      int
    ShrASsign,      int
    AndAssign,      int
    XorAssign,      int
    OrAssign,       int
*/

    /*
        int + int -> integer promotions
        const int + int -> int
        const int + const int -> int
        int + enum -> int
        enumA + enumA -> enumA

        Not Allowed
        enumA + enumB
    */
// Both sides must be integers (Enum is allowed)
func QualType Analyser.checkBinopIntArgs(Analyser* ma, BinaryOperator* b, QualType lhs, QualType rhs) {
    // TODO alias/enum

    BuiltinType* lb = lhs.getBuiltinTypeOrNil();
    BuiltinType* rb = rhs.getBuiltinTypeOrNil();
    if (!lb || !rb || lhs.isVoidType() || rhs.isVoidType()) {
        Expr* e = cast<Expr*>(b);
        ma.error(e.getLoc(), "invalid operands to binary expression (%s and %s)", lhs.diagName(true), rhs.diagName(true));
        return QualType_Invalid;
    }

    //TODO do integer promotion
    return g_i32;
}

// 0  cannot happen
// 1  invalid
// 2  builtin + builtin
// 3  builtin/enum + ptr
// 4  ptr + builtin/enum
// 5  builtin +  enum
// 6  enum +  builtin
// TODO remove Alias/Module (+Array, need to move) since already checked
// TODO need to fix C2C.c++ (asserts of elemsof(..) -2), then table can be 5x5
const u8[elemsof(TypeKind)][elemsof(TypeKind)] BinOpConvAdd = {
    //  Builtin Pointer Array   Struct  Enum    Func   Alias  Module
    //  Builtin +
    {   2,      3,      0,      1,      5,      0,     0,     0  },
    //  Pointer +
    {   4,      1,      0,      1,      4,      6,     0,     0  },
    //  Array +
    {   0,      0,      0,      0,      0,      0,     0,     0  },
    //  Struct +
    {   1,      1,      0,      1,      1,      1,     0,     0  },
    //  Enum +
    {   6,      3,      0,      1,      1,      1,     0,     0  },
    //  Function +
    {   0,      0,      0,      1,      0,      0,     0,     0  },
    // Alias + Module are zero
}

func QualType Analyser.checkBinopAddArgs(Analyser* ma, BinaryOperator* b, QualType lhs, QualType rhs) {
    u8 res = BinOpConvAdd[lhs.getKind()][rhs.getKind()];
    switch (res) {
    case 0: // cannot happen
        assert(0);
        break;
    case 1: // invalid
        Expr* e = cast<Expr*>(b);
        ma.error(e.getLoc(), "invalid operands to binary expression (%s and %s)", rhs.diagName(true), rhs.diagName(true));
        break;
    case 2: // builtin + builtin
        // TODO do integer promotion, int -> float conversion
        return lhs; // TEMP
    case 3: // builtin/enum + ptr
        // TODO check float
        return rhs;
    case 4: // ptr + builtin/enum
        // TODO check float
        return lhs;
    case 5: // 5  builtin + enum
        return rhs;
    case 6: // 6  enum +  builtin
        return lhs;
    }
    assert(0);
    return QualType_Invalid;
}

func QualType Analyser.analyseBinaryOperator(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    BinaryOperator* b = cast<BinaryOperator*>(e);

    bool need_lhs_rvalue = true;
    if (b.getOpcode() >= BinaryOpcode.Assign) need_lhs_rvalue = false;

    QualType ltype = ma.analyseExpr(b.getLHS2(), need_lhs_rvalue);
    if (ltype.isInvalid()) return QualType_Invalid;

    QualType rtype = ma.analyseExpr(b.getRHS2(), true);
    if (rtype.isInvalid()) return QualType_Invalid;

    Expr* lhs = b.getLHS();
    Expr* rhs = b.getRHS();

    // check any invalid kind
    // TODO check if either type is void, give error
    if (!validBinOpKind(ltype) || !validBinOpKind(rtype) || ltype.isVoidType() || rtype.isVoidType()) {
        QualType tl = lhs.getType();
        QualType tr = rhs.getType();
        ma.error(e.getLoc(), "invalid operands to binary expression (%s and %s)", tl.diagName(true), tr.diagName(true));
        return QualType_Invalid;
    }

    QualType result = QualType_Invalid;
    switch (b.getOpcode()) {
    case Multiply:  fallthrough;
    case Divide:    fallthrough;
    case Reminder:
        break;
    case Add:
        result = ma.checkBinopAddArgs(b, ltype, rtype);
        break;
    case Subtract:
        result = ltype; // TEMP
        if (result.isInvalid()) {
            QualType tl = lhs.getType();
            QualType tr = rhs.getType();
            ma.error(e.getLoc(), "invalid operands to binary expression (%s and %s)", tl.diagName(true), tr.diagName(true));
            return QualType_Invalid;
        }
        break;
    case ShiftLeft: fallthrough;
    case ShiftRight:
        result = ltype;
        break;
    case LessThan:      fallthrough;
    case GreaterThan:   fallthrough;
    case LessEqual:     fallthrough;
    case GreaterEqual:  fallthrough;
    case Equal:         fallthrough;
    case NotEqual:
        result = g_bool;
        break;
    case And:       fallthrough;
    case Xor:       fallthrough;
    case Or:
        result = ma.checkBinopIntArgs(b, ltype, rtype);
        break;
    case LAnd:      fallthrough;
    case LOr:
        result = g_bool;
        break;
    case Assign:    fallthrough;
    case MulAssign: fallthrough;
    case DivAssign: fallthrough;
    case RemAssign: fallthrough;
    case AddAssign: fallthrough;
    case SubASsign: fallthrough;
    case ShlAssign: fallthrough;
    case ShrASsign: fallthrough;
    case AndAssign: fallthrough;
    case XorAssign: fallthrough;
    case OrAssign:
        // need RHS expr + loc for assignment (can differ, eg BinaryOperator)
        ma.checker.check(ltype, rtype, b.getRHS2(), e.getLoc());
        result = ltype;
        break;
    }

    e.combineConstantFlags(lhs, rhs);

    return result;
}

func IdentifierKind getInnerExprAddressOf(Expr* e) {
    // TODO change return type to IdentifierKind, use Unresolved for not-IdentifiersExpr/MemberExpr

    switch (e.getKind()) {
    case IntegerLiteral:    fallthrough;
    case BooleanLiteral:    fallthrough;
    case CharLiteral:       fallthrough;
    case StringLiteral:     fallthrough;
    case Nil:
        break;
    case Identifier:
        IdentifierExpr* i = cast<IdentifierExpr*>(e);
        return i.getKind();
    case Type:              fallthrough;
    case Call:              fallthrough;
    case InitList:          fallthrough;
    case FieldDesignatedInit:   fallthrough;
    case ArrayDesignatedInit:
        break;
    case BinaryOperator:
        // TODO
        break;
    case UnaryOperator:
        // TODO
        break;
    case ConditionalOperator:
        // TODO
        break;
    case Builtin:
        break;
    case ArraySubscript:
        ArraySubscriptExpr* a = cast<ArraySubscriptExpr*>(e);
        return getInnerExprAddressOf(a.getBase());
    case Member:
        MemberExpr* m = cast<MemberExpr*>(e);
        // TODO MemberExpr doesn't have an IdentifierExpr anymore!!
        // Caller only needs RefKind, so return that from this function?
        return m.getKind();
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        return getInnerExprAddressOf(p.getInner());
    case BitOffset:
        return IdentifierKind.Unresolved;
    case ExplicitCast:
        ExplicitCastExpr* c = cast<ExplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    case ImplicitCast:
        ImplicitCastExpr* c = cast<ImplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    }

    return IdentifierKind.Unresolved;
}

func bool Analyser.getIdentifierKind(Analyser* ma, Expr* e) {
    IdentifierKind kind = getInnerExprAddressOf(e);
    const char* arg = "";
    switch (kind) {
    case Unresolved:
        QualType qt = e.getType();
        ma.error(e.getLoc(), "cannot take the address of an rvalue of type %s", qt.diagName());
        return false;
    case Module:
        arg = "a module";
        break;
    case Function:
        // NOTE: C2 does not allow address of function like C
        arg = "a function";
        break;
    case Type:
        arg = "a type";
        break;
    case Var:
        return true;
    case EnumConstant:
        arg = "an enum constant";
        break;
    case StructMember:
        return true;
    case StructFunction:
        arg = "a function";
        break;
    case Label:
        arg = "a label";
        break;
    }
    ma.error(e.getLoc(), "cannot take the address of %s", arg);
    return false;
}

func QualType Analyser.analyseUnaryOperator(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    UnaryOperator* u = cast<UnaryOperator*>(e);

    bool need_rvalue = true;

    // TODO need rvalue stuff
    switch (u.getOpcode()) {
    case PostInc:   fallthrough;
    case PostDec:   fallthrough;
    case PreInc:    fallthrough;
    case PreDec:
        if (!ma.curFunction) {
            ma.diags.reportRange(e.getLoc(), e.getRange(), "initializer element is not a compile-time constant");
            return QualType_Invalid;
        }
        need_rvalue = false;
        break;
    case AddrOf:
        need_rvalue = false;
        break;
    case Deref:     fallthrough;
    case Minus:     fallthrough;
    case Not:       fallthrough;
    case LNot:
        break;
    }

    QualType t = ma.analyseExpr(u.getInner2(), need_rvalue);
    if (t.isInvalid()) {
        return QualType_Invalid;
    }

    e = *e_ptr; // re-read in case of ImplicitCast insertions
    Expr* inner = u.getInner();

    if (t.isVoidType()) {
        ma.error(e.getLoc(), "invalid argument type %s to unary expression", "'void'");
        return QualType_Invalid;
    }

    switch (u.getOpcode()) {
    case PostInc:
        // TODO check if ptr/builtin
        if (!ma.checkAssignment(inner, t, "increment operand", e.getLoc())) return QualType_Invalid;
        break;
    case PostDec:
        // TODO check if ptr/builtin
        if (!ma.checkAssignment(inner, t, "decrement operand", e.getLoc())) return QualType_Invalid;
        break;
    case PreInc:
        // TODO check if ptr/builtin
        if (!ma.checkAssignment(inner, t, "increment operand", e.getLoc())) return QualType_Invalid;
        break;
    case PreDec:
        // TODO check if ptr/builtin
        if (!ma.checkAssignment(inner, t, "decrement operand", e.getLoc())) return QualType_Invalid;
        break;
    case AddrOf:
        if (!ma.getIdentifierKind(inner)) return QualType_Invalid;
        QualType canon = t.getCanonicalType();
        t = ma.builder.actOnPointerType(canon);
        e.setCtc();
        break;
    case Deref:
        if (!t.isPointerType()) {
            ma.error(e.getLoc(), "indirection requires pointer operand (%s invalid)", t.diagName());
            return QualType_Invalid;
        } else {
            t = t.getCanonicalType();
            const PointerType* p = t.getPointerType();
            // TODO copy flags from outer
            return p.getInner();
        }
        break;
    case Minus:     fallthrough;
    case Not:
        e.copyConstantFlags(inner);
        t = usualUnaryConversions(inner);
        break;
    case LNot:
        e.copyConstantFlags(inner);
        return g_bool;
    }

    return t;
}

func bool Analyser.checkAssignment(Analyser* ma, Expr* assignee, QualType tleft, const char* msg, SrcLoc loc) {
    if (tleft.isConst()) {
        ma.error(loc, "cannot assign to variable with const-qualified type '%s'", tleft.diagName(true));
        return false;
    }

    if (!assignee.isLValue()) {
        ma.error(loc, "lvalue required as %s", msg);
        return false;
    }

    // TODO check arraytype

    return true;
}

// TODO move
func QualType usualUnaryConversions(Expr* e) {
    QualType qt = e.getType();
    QualType canon = qt.getCanonicalType();

    if (canon.isBuiltinType()) {
        BuiltinType* bi = canon.getBuiltinType();
        if (bi.isPromotableIntegerType()) return g_i32;
    } else if (canon.isPointerType()) {
        // TODO depend on arch width
        return g_u64;
    }

    return qt;
}

func QualType Analyser.analyseMemberExpr(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    MemberExpr* m =cast<MemberExpr*>(e);

    Decl* base = nil;
    SrcLoc lastLoc = 0;
    bool is_ctc = false;
    bool is_ctv = false;

    Expr* exprBase = m.getExprBase();
    if (exprBase) {
        // note: no ImplicitCast can be added
        QualType qt = ma.analyseExpr(&exprBase, false);
        if (qt.isInvalid()) return QualType_Invalid;

        base = ma.analyseMemberBase(exprBase.getLoc(), qt, false);
        if (!base) return QualType_Invalid;
    }

    u32 refcount = m.getNumRefs();
    for (u32 i=0; i<refcount; i++) {
        u32 name_idx = m.getNameIdx(i);
        SrcLoc loc = m.getLoc(i);

        Decl* d = nil;
        if (!base) {
            d = ma.scope.find(name_idx, loc);
        } else {
            if (base.getKind() == DeclKind.Var) {
                // for variables, take Type's kind
                base = ma.analyseMemberBase(loc, base.getType(), false);
                if (!base) return QualType_Invalid;
            }
            QualType baseType = base.getType();
            switch (base.getKind()) {
            case Function:
                const FunctionDecl* fd = cast<FunctionDecl*>(base);
                //if (fd.hasPrefix()) kind = IdentifierKind.StructFunction;
                //else kind = IdentifierKind.Function;
                // always error?
                break;
            case Import:
                ImportDecl* id = cast<ImportDecl*>(base);
                d = ma.scope.findGlobalSymbolInModule(id.getDest(), name_idx, loc);
                break;
            case StructType:
                // TODO check if opaque
                StructType* st = baseType.getStructType();
                d = ma.findStructMember(st.getDecl(), name_idx, loc);
                break;
            case EnumType:
                EnumTypeDecl* etd = cast<EnumTypeDecl*>(base);
                EnumConstantDecl* ecd = etd.findConstant(name_idx);
                if (!ecd) {
                    ma.error(e.getLoc(), "enum %s has no constant %s", base.getName(), m.getName(0));
                    return QualType_Invalid;
                }
                // TODO do self-initialization checking

                d = cast<Decl*>(ecd);
                //kind = IdentifierKind.EnumConstant; (set below)
                break;
            case EnumConstant:
                ma.error(lastLoc, "invalid member reference base");
                return QualType_Invalid;
            case FunctionType:
                // can this happen?
                break;
            case AliasType:
                break;
            case Var:
                // cannot happen?
                assert(0); // can this happen?
                //if (ma.curFunction) {
                break;
            case StaticAssert:
                assert(0);
                break;
            }
        }

        if (!d) {
            ma.has_error = true;
            return QualType_Invalid;
        }

        lastLoc = loc;
        // Note: this can happen in arraysizeExpr: var[test.number] a; (as global/struct-member)
        if (!d.isChecked()) {
            ma.analyseGlobalDecl(d);
            // TODO need result
        }

        d.setUsed();
        m.setDecl(d, i);
        base = d;
    }

    IdentifierKind kind = ma.setExprFlags(e_ptr, base);
    //e.setKind(kind);
    e.setType(base.getType());
    if (e.isCtv()) e.setRValue();
    return base.getType();
}

func Decl* Analyser.analyseMemberBase(Analyser* ma, SrcLoc loc, QualType baseType, bool ptr_deref) {
    const Type* t = baseType.getTypeOrNil();
    switch (t.getKind()) {
    case Builtin:
        break;
    case Pointer:
        if (ptr_deref) break;
        PointerType* pt = cast<PointerType*>(t);
        return ma.analyseMemberBase(loc, pt.getInner(), true);
    case Array:
        break;
    case Struct:
        // TODO check if opaque
        StructType* st = baseType.getStructType();
        return cast<Decl*>(st.getDecl());
    case Enum:
        // TODO
        break;
    case Function:
        break;
    case Alias:
        // TODO
        break;
    case Module:
        assert(0);
        break;
    }
    ma.error(loc, "invalid member reference base");
    return nil;
}

func QualType Analyser.analyseExplicitCast(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    ExplicitCastExpr* c = cast<ExplicitCastExpr*>(e);
    TypeRef* ref = c.getTypeRef();
    QualType destType = ma.analyseTypeRef(ref);

    QualType srcType = ma.analyseExpr(c.getInner2(), true);

    if (srcType.isInvalid() || destType.isInvalid()) return QualType_Invalid;

    Expr* inner = c.getInner();
    e.copyConstantFlags(inner);

    // TODO check if explicit is allowed between types
    // ma.checker.checkCast(destType, srcType, inner);

    return destType;
}

func QualType Analyser.analyseBuiltin(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    BuiltinExpr* b = cast<BuiltinExpr*>(e);

    switch (b.getKind()) {
    case Sizeof:
        return ma.analyseSizeof(b);
    case Elemsof:
        return ma.analyseElemsof(b);
    case EnumMin:   fallthrough;
    case EnumMax:
        return ma.analyseEnumMinMax(b);
    case OffsetOf:
        break;
    case ToContainer:
        break;
    }

    return QualType_Invalid;
}

func QualType Analyser.analyseArraySubscriptExpr(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    ArraySubscriptExpr* sub = cast<ArraySubscriptExpr*>(e);

    QualType q = ma.analyseExpr(sub.getBase2(), true);
    if (q.isInvalid()) return q;

    // Derefence alias types
    // TODO

    if (!q.isPointerType()) {
        ma.diags.reportRange(e.getLoc(), e.getRange(), "subscripted value is not an array or pointer");
        return QualType_Invalid;
    }

    QualType qidx = ma.analyseExpr(sub.getIndex2(), true);
    if (qidx.isInvalid()) return qidx;

    PointerType* pt = q.getPointerType();
    return pt.getInner();
}

func QualType Analyser.analyseEnumMinMax(Analyser* ma, BuiltinExpr* e) {
    return QualType_Invalid;
}

func QualType Analyser.analyseSizeof(Analyser* ma, BuiltinExpr* e) {
    Expr* inner = e.getInner();
    assert(inner);

    QualType qt;
    if (inner.getKind() == ExprKind.Type) {
        TypeExpr* te = cast<TypeExpr*>(inner);
        TypeRef* ref = te.getTypeRef();
        qt = ma.analyseTypeRef(ref);
    } else {
        // is Identifier/memberExpr, could still be Type!
        qt = ma.analyseExpr(&inner, false);
    }
    if (qt.isInvalid()) return QualType_Invalid;

    size_analyser.TypeSize info = size_analyser.sizeOfType(qt);
    e.setValue(info.size);
    return g_u32;
}

func QualType Analyser.analyseElemsof(Analyser* ma, BuiltinExpr* b) {
    // could be EnumType or array VarDecl

    Expr* inner = b.getInner();
    QualType qt = ma.analyseExpr(&inner, false);
    if (qt.isInvalid()) return qt;

    const ArrayType* at = qt.getArrayTypeOrNil();
    if (at) {
        b.setValue(at.getSize());
        return g_u32;
    }
    const EnumType* et = qt.getEnumTypeOrNil();
    if (et) {
        const EnumTypeDecl* etd = et.getDecl();
        b.setValue(etd.getNumConstants());
        return g_u32;
    }
    ma.error(inner.getLoc(), "elemsof can only be used on arrays/enums");
    return QualType_Invalid;
}

// TODO move somewhere else
func Decl* Analyser.findStructMember(Analyser* ma, StructTypeDecl* s, u32 name_idx, SrcLoc loc) {
    // TODO could be a (static) struct function or a member

    Decl* d = s.find(name_idx);
    if (!d) {
        ma.error(loc, "%s %s does not have a member %s",
            s.isStruct() ? "struct" : "union", s.asDecl().getName(), idx2name(name_idx));
        return nil;
    }

    // TODO check if struct member

    return d;
}



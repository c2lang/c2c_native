/* Copyright 2022 Bas van den Berg
*/

module module_analyser;

import ast local;

import stdio; // TEMP

func QualType ModuleAnalyser.analyseExpr(ModuleAnalyser* ma, Expr* e) {
    switch (e.getKind()) {
    case IntegerLiteral:
        // TODO determine kind based on value, for now just return u32
        return g_u32;
    case BooleanLiteral:
        return g_bool;
    case CharLiteral:
        return g_i8;
    case StringLiteral:
        // char* (const?)
        break;
    case Nil:
        // void*
        break;
    case Identifier:
        return ma.analyseIdentifier(cast<IdentifierExpr*>(e));
    case Type:
        break;
    case Call:
        break;
    case InitList:
        // TODO need to know type
        break;
    case FieldDesignatedInit:
        break;
    case ArrayDesignatedInit:
        break;
    case BinaryOperator:
        break;
    case UnaryOperator:
        return ma.analyseUnaryOperator(cast<UnaryOperator*>(e));
    case ConditionalOperator:
        break;
    case Builtin:
        return ma.analyseBuiltin(cast<BuiltinExpr*>(e));
    case ArraySubscript:
        break;
    case Member:
        break;
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        return ma.analyseExpr(p.getInner());
    case BitOffset:
        break;
    case ExplicitCast:
        break;
    case ImplicitCast:
        break;
    }
    return QualType.init0();
}

func QualType ModuleAnalyser.analyseIdentifier(ModuleAnalyser* ma, IdentifierExpr* e) {
    //stdio.printf("FIND %s (%u) idx %u\n", e.getName(), e.getNameIdx(), ma.checkIndex);
    Decl* d = ma.scope.find(e.getNameIdx());
    //stdio.printf("D  %p\n", d);
    if (!d) return QualType.init0();

    if (!d.isChecked()) {
        // TODO need to have correct scope
        ma.analyseGlobalDecl(d);
        // TODO need result
    }
    // if function, mark is CTC / CTV

    return QualType.init0();
}

func QualType ModuleAnalyser.analyseUnaryOperator(ModuleAnalyser* ma, UnaryOperator* e) {
    QualType t = ma.analyseExpr(e.getInner());
    if (t.isInvalid()) return QualType.init0();

    // TODO need rvalue stuff
    switch (e.getKind()) {
    case PostInc:
        break;
    case PostDec:
        break;
    case PreInc:
        break;
    case PreDec:
        break;
    case AddrOf:
        // TODO check inner
        e.asExpr().isCtc();
        break;
    case Deref:
        break;
    case Minus:
        // TODO check inner
        e.asExpr().copyConstantFlags(e.getInner());
        break;
    case Not:
        // TODO check inner
        e.asExpr().copyConstantFlags(e.getInner());
        break;
    case LNot:
        // TODO check inner
        e.asExpr().copyConstantFlags(e.getInner());
        break;
    }
    return QualType.init0();
}

func QualType ModuleAnalyser.analyseBuiltin(ModuleAnalyser* ma, BuiltinExpr* e) {
    switch (e.getKind()) {
    case Sizeof:
        return ma.analyseSizeof(e);
    case Elemsof:
        break;
    case EnumMin:
        break;
    case EnumMax:
        break;
    case OffsetOf:
        break;
    case ToContainer:
        break;
    }

    return QualType.init0();
}

func QualType ModuleAnalyser.analyseSizeof(ModuleAnalyser* ma, BuiltinExpr* e) {
    Expr* inner = e.getInner();
    assert(inner);
    // TODO switch
    if (inner.getKind() == ExprKind.Type) {
        TypeExpr* te = cast<TypeExpr*>(inner);
        QualType qt = te.getType();
        // TODO
        e.setValue(4);
    }
    return QualType.init0();
}


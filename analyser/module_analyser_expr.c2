/* Copyright 2022 Bas van den Berg
*/

module module_analyser;

import ast local;

//import stdio; // TEMP

func QualType ModuleAnalyser.analyseExpr(ModuleAnalyser* ma, Expr** e_ptr, bool need_rvalue) {
    QualType result = ma.analyseExprInner(e_ptr);
    if (result.isInvalid()) return result;

    Expr* e = *e_ptr;
    e.setType(result);

    if (need_rvalue && e.isLValue()) {
        QualType qt = e.getType();

        if (qt.isArrayType()) {
            QualType ptr_type; // = // usegetPointerFromArray(Context, Q);
            ma.builder.insertImplicitCast(ImplicitCastKind.ArrayToPointerDecay, e_ptr, ptr_type);
        } else {
            ma.builder.insertImplicitCast(ImplicitCastKind.LValueToRValue, e_ptr, qt);
        }
    }

    return result;
}

func QualType ModuleAnalyser.analyseExprInner(ModuleAnalyser* ma, Expr** e_ptr) {
    assert(e_ptr);
    Expr* e = *e_ptr;

    switch (e.getKind()) {
    case IntegerLiteral:
        // TODO determine kind based on value, for now just return u32
        return g_u32;
    case BooleanLiteral:
        return g_bool;
    case CharLiteral:
        return g_i8;
    case StringLiteral:
        // char* (const?)
        break;
    case Nil:
        // void*
        break;
    case Identifier:
        Decl* d = ma.analyseIdentifier(e_ptr);
        if (!d) break;
        // TODO
        return d.getType();
    case Type:
        break;
    case Call:
        return g_void; // to get CTC check in analyseInitExpr
    case InitList:
        assert(0);
        break;
    case FieldDesignatedInit:
        assert(0);
        break;
    case ArrayDesignatedInit:
        assert(0);
        break;
    case BinaryOperator:
        return ma.analyseBinaryOperator(e);
    case UnaryOperator:
        return ma.analyseUnaryOperator(cast<UnaryOperator*>(e));
    case ConditionalOperator:
        break;
    case Builtin:
        return ma.analyseBuiltin(cast<BuiltinExpr*>(e));
    case ArraySubscript:
        break;
    case Member:
        return ma.analyseMemberExpr(cast<MemberExpr*>(e));
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        QualType qt = ma.analyseExpr(p.getInner2(), false);
        e.copyConstantFlags(p.getInner());
        return qt;
    case BitOffset:
        break;
    case ExplicitCast:
        break;
    case ImplicitCast:
        break;
    }
    return QualType.init0();
}

func Decl* ModuleAnalyser.analyseIdentifier(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    IdentifierExpr* i = cast<IdentifierExpr*>(e);
    //stdio.printf("FIND %s (%u) idx %u\n", i.getName(), i.getNameIdx(), ma.checkIndex);
    Decl* d = ma.scope.find(i.getNameIdx(), e.getLoc());
    //stdio.printf("D  %p\n", d);
    if (!d) return nil;

    if (!d.isChecked()) {
        ma.analyseGlobalDecl(d);
        // TODO need result
    }

    QualType qt = d.getType();
    assert(qt.isValid());
    e.setType(qt);
    i.setDecl(d);
    d.setUsed();

    IdentifierKind kind = IdentifierKind.Unresolved;
    switch (d.getKind()) {
    case Function:
        e.setCtc();
        e.setRValue();
        ma.builder.insertImplicitCast(ImplicitCastKind.FunctionToPointerDecay, e_ptr, d.getType());
        const FunctionDecl* fd = cast<FunctionDecl*>(d);
        if (fd.hasPrefix()) kind = IdentifierKind.StructFunction;
        else kind = IdentifierKind.Function;
        break;
    case Import:
        break;
    case StructType:
        e.setRValue();
        kind = IdentifierKind.Type;
        break;
    case EnumType:
        e.setCtc();
        e.setRValue();
        kind = IdentifierKind.Type;
        break;
    case EnumConstant:
        e.setCtc();
        e.setCtv();
        kind = IdentifierKind.EnumConstant;
        break;
    case FunctionType:
        e.setCtc();
        kind = IdentifierKind.Type;
        break;
    case AliasType:
        kind = IdentifierKind.Type;
        break;
    case Var:
        const VarDecl* vd = cast<VarDecl*>(d);
        QualType t = vd.asDecl().getType();
        e.setCtc();
        const Expr* init_ = vd.getInit();
        if (init_ && t.isConst() && init_.isCtv()) e.setCtv();
        switch (vd.getKind()) {
        case GlobalVar: fallthrough;
        case LocalVar:  fallthrough;
        case FunctionParam:
            kind = IdentifierKind.Var;
            break;
        case StructMember:
            kind = IdentifierKind.StructMember;
            break;
        }
        break;
    case StaticAssert:
        break;
    }
    i.setKind(kind);

    if (e.isCtv()) e.setRValue();

    return d;
}

func QualType ModuleAnalyser.analyseBinaryOperator(ModuleAnalyser* ma, Expr* e) {
    BinaryOperator* b = cast<BinaryOperator*>(e);
    QualType ltype = ma.analyseExpr(b.getLHS2(), true);
    if (ltype.isInvalid()) return QualType.init0();

    QualType rtype = ma.analyseExpr(b.getRHS2(), true);
    if (rtype.isInvalid()) return QualType.init0();

    Expr* lhs = b.getLHS();
    Expr* rhs = b.getRHS();

    // TODO check if either type is void, give error

    QualType result = QualType.init0();
    switch (b.getKind()) {
    case Multiply:  fallthrough;
    case Divide:    fallthrough;
    case Reminder:  fallthrough;
    case Add:       fallthrough;
    case Subtract:
        break;
    case ShiftLeft: fallthrough;
    case ShiftRight:
        result = ltype;
        break;
    case LessThan:      fallthrough;
    case GreaterThan:   fallthrough;
    case LessEqual:     fallthrough;
    case GreaterEqual:  fallthrough;
    case Equal:         fallthrough;
    case NotEqual:
        result = g_bool;
        break;
    case And:       fallthrough;
    case Xor:       fallthrough;
    case Or:
        result = ltype;
        break;
    case LAnd:      fallthrough;
    case LOr:
        result = g_bool;
        break;
    case Assign:    fallthrough;
    case MulAssign: fallthrough;
    case DivAssign: fallthrough;
    case RemAssign: fallthrough;
    case AddAssign: fallthrough;
    case SubASsign: fallthrough;
    case ShlAssign: fallthrough;
    case ShrASsign: fallthrough;
    case AndAssign: fallthrough;
    case XorAssign: fallthrough;
    case OrAssign:
        assert(0);
        break;
    }

    e.combineConstantFlags(lhs, rhs);

    return result;
}

func QualType ModuleAnalyser.analyseUnaryOperator(ModuleAnalyser* ma, UnaryOperator* e) {
    QualType t = ma.analyseExpr(e.getInner2(), true);
    if (t.isInvalid()) return QualType.init0();

    // TODO need rvalue stuff
    switch (e.getKind()) {
    case PostInc:
        break;
    case PostDec:
        break;
    case PreInc:
        break;
    case PreDec:
        break;
    case AddrOf:
        // TODO check inner
        e.asExpr().isCtc();
        break;
    case Deref:
        break;
    case Minus:
        // TODO check inner
        e.asExpr().copyConstantFlags(e.getInner());
        break;
    case Not:
        // TODO check inner
        e.asExpr().copyConstantFlags(e.getInner());
        break;
    case LNot:
        // TODO check inner
        e.asExpr().copyConstantFlags(e.getInner());
        break;
    }
    return QualType.init0();
}

func QualType ModuleAnalyser.analyseMemberExpr(ModuleAnalyser* ma, MemberExpr* m) {
    Expr* e = cast<Expr*>(m);

    QualType lhs = ma.analyseExpr(m.getBase2(), false);
    if (lhs.isInvalid()) return lhs;

    // we dont know what we're looking at here, it could be:
    // mod.Type
    // mod.var
    // mod.func
    // var<Type=struct>.member
    // var<Type=struct>.struct_function
    // var[index].member
    // var.member (= error)
    // Type.struct_function
    // Enum.Constant (eg. Color.Red)

    u32 rhs_idx = m.getNameIdx();

    Type* t = lhs.getType();
    switch(t.getKind()) {
    case Builtin:
        // cannot happen?
        break;
    case Pointer:
        // TODO can happen?
        break;
    case Array:
        // TODO can happen?
        break;
    case Ref:
        // IdentifierKind.Var or IdentifierKind.StructMember or IdentifierKind.EnumConstant
        break;
    case Struct:
        // TODO
        break;
    case Enum:
        EnumType* et = cast<EnumType*>(t);
        EnumTypeDecl* etd = et.getDecl();
        Decl* d = cast<Decl*>(etd);
        d.setUsed();
        EnumConstantDecl* ecd = etd.findConstant(rhs_idx);
        if (!ecd) {
            ma.diags.report(e.getLoc(), "enum %s has no constant %s", d.getName(), m.getName());
            return QualType.init0();
        }
        // TODO do self-initialization checking

        Decl* cd = cast<Decl*>(ecd);
        cd.setUsed();
        m.setDecl(cd);
        // TODO set ref kind (like IdentifierExpr)
        e.setCtv();
        e.setCtc();
        QualType rhs = cd.getType();
        e.setType(rhs);


        return rhs;
    case Function:
        // TODO
        break;
    case Module:
        // TODO
        break;
    }
    // TODO check for ModuleType

    // TODO check for EnumType

    // TODO var/struct


    return QualType.init0();
}

func QualType ModuleAnalyser.analyseBuiltin(ModuleAnalyser* ma, BuiltinExpr* e) {
    switch (e.getKind()) {
    case Sizeof:
        return ma.analyseSizeof(e);
    case Elemsof:
        break;
    case EnumMin:
        break;
    case EnumMax:
        break;
    case OffsetOf:
        break;
    case ToContainer:
        break;
    }

    return QualType.init0();
}

func QualType ModuleAnalyser.analyseSizeof(ModuleAnalyser* ma, BuiltinExpr* e) {
    Expr* inner = e.getInner();
    assert(inner);
    // TODO switch
    if (inner.getKind() == ExprKind.Type) {
        TypeExpr* te = cast<TypeExpr*>(inner);
        QualType qt = te.getType();
        // TODO
        e.setValue(4);
    }
    return QualType.init0();
}


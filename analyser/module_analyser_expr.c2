/* Copyright 2022 Bas van den Berg
*/

module module_analyser;

import ast local;
import ast_builder;
import size_analyser;
import src_loc local;

import stdio local; // TEMP

// TODO move to AnalyserUtils
func QualType getPointerFromArray(ast_builder.Builder* builder, QualType q) {
    q = q.getCanonicalType();
    const ArrayType* a = cast<ArrayType*>(q.getTypeOrNil());
    QualType elem = a.getElemType();
    QualType res = builder.actOnPointerType(elem);
    return res;
}

func QualType Analyser.analyseExpr(Analyser* ma, Expr** e_ptr, bool need_rvalue) {
    assert(e_ptr);
    QualType result = ma.analyseExprInner(e_ptr);
    if (result.isInvalid()) return result;

    Expr* e = *e_ptr;
    e.setType(result);

    if (need_rvalue && e.isLValue()) {
        QualType qt = e.getType();

        if (qt.isArrayType()) {
            result = getPointerFromArray(ma.builder, qt);
            ma.builder.insertImplicitCast(ImplicitCastKind.ArrayToPointerDecay, e_ptr, result);
        } else {
            ma.builder.insertImplicitCast(ImplicitCastKind.LValueToRValue, e_ptr, qt);
        }
    }

    return result;
}

func QualType Analyser.analyseExprInner(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;

    switch (e.getKind()) {
    case IntegerLiteral:
        // TODO determine kind based on value, for now just return u32
        return g_u32;
    case BooleanLiteral:
        return g_bool;
    case CharLiteral:
        return g_i8;
    case StringLiteral:
        return e.getType(); // already set in creator
    case Nil:
        return g_void_ptr;
    case Identifier:
        Decl* d = ma.analyseIdentifier(e_ptr);
        if (!d) break;
        return d.getType();
    case Type:
        break;
    case Call:
        return g_void; // to get CTC check in analyseInitExpr
    case InitList:
        (*e_ptr).dump();
        assert(0);
        break;
    case FieldDesignatedInit:
        (*e_ptr).dump();
        assert(0);
        break;
    case ArrayDesignatedInit:
        assert(0);
        break;
    case BinaryOperator:
        return ma.analyseBinaryOperator(e_ptr);
    case UnaryOperator:
        return ma.analyseUnaryOperator(e_ptr);
    case ConditionalOperator:
        break;
    case Builtin:
        return ma.analyseBuiltin(e_ptr);
    case ArraySubscript:
        return ma.analyseArraySubscriptExpr(e_ptr);
    case Member:
        return ma.analyseMemberExpr(e_ptr);
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        QualType qt = ma.analyseExpr(p.getInner2(), false);
        e.copyConstantFlags(p.getInner());
        return qt;
    case BitOffset:
        break;
    case ExplicitCast:
        break;
    case ImplicitCast:
        break;
    }
    return QualType_Invalid;
}

func Decl* Analyser.analyseIdentifier(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    IdentifierExpr* i = cast<IdentifierExpr*>(e);
    //stdio.printf("FIND %s (%u) idx %u\n", i.getName(), i.getNameIdx(), ma.checkIndex);
    Decl* d = ma.scope.find(i.getNameIdx(), e.getLoc());
    //stdio.printf("D  %p\n", d);
    if (!d) return nil;

    if (!d.isChecked()) {
        ma.analyseGlobalDecl(d);
        // TODO need result
    }

    QualType qt = d.getType();
    assert(qt.isValid());
    e.setType(qt);
    i.setDecl(d);
    d.setUsed();

    IdentifierKind kind = ma.setExprFlags(e_ptr, d);
    i.setKind(kind);

    if (e.isCtv()) e.setRValue();

    return d;
}

func IdentifierKind Analyser.setExprFlags(Analyser* ma, Expr** e_ptr, Decl* d) {
    Expr* e = *e_ptr;
    IdentifierKind kind = IdentifierKind.Unresolved;
    switch (d.getKind()) {
    case Function:
        e.setCtc();
        e.setRValue();
        ma.builder.insertImplicitCast(ImplicitCastKind.FunctionToPointerDecay, e_ptr, d.getType());
        const FunctionDecl* fd = cast<FunctionDecl*>(d);
        if (fd.hasPrefix()) kind = IdentifierKind.StructFunction;
        else kind = IdentifierKind.Function;
        break;
    case Import:
        e.setCtc();
        e.setRValue();
        kind = IdentifierKind.Module;
        break;
    case StructType:
        e.setRValue();
        kind = IdentifierKind.Type;
        break;
    case EnumType:
        e.setCtc();
        e.setRValue();
        kind = IdentifierKind.Type;
        break;
    case EnumConstant:
        e.setCtc();
        e.setCtv();
        kind = IdentifierKind.EnumConstant;
        break;
    case FunctionType:
        e.setCtc();
        kind = IdentifierKind.Type;
        break;
    case AliasType:
        kind = IdentifierKind.Type;
        break;
    case Var:
        VarDecl* vd = cast<VarDecl*>(d);
        QualType t = vd.asDecl().getType();
        e.setCtc();
        const Expr* init_ = vd.getInit();
        if (init_ && t.isConst() && init_.isCtv()) e.setCtv();
        switch (vd.getKind()) {
        case GlobalVar: fallthrough;
        case LocalVar:  fallthrough;
        case FunctionParam:
            kind = IdentifierKind.Var;
            break;
        case StructMember:
            kind = IdentifierKind.StructMember;
            break;
        }
        break;
    case StaticAssert:
        break;
    }
    return kind;
}

func QualType getBinOpType(BinaryOperator* b) {
    const Expr* lhs = b.getLHS();
    const Expr* rhs = b.getRHS();
    QualType tleft = lhs.getType();
    QualType tright = rhs.getType();

    // TODO

    if (b.getOpcode() == BinaryOpcode.Subtract) return g_i32; // TEMP

    return tleft;
}

// Note: this function should only be called from analyseInitListArray directly!
func bool Analyser.analyseArrayDesignatedInit(Analyser* ma, Expr* e, QualType expectedType) {
    ArrayDesignatedInitExpr* ad = cast<ArrayDesignatedInitExpr*>(e);

    Expr* bb = ad.getDesignator();
    QualType qt = ma.analyseExpr(ad.getDesignator2(), false);
    if (qt.isInvalid()) return false;

    Expr* de = ad.getDesignator();
    if (!de.isCtv()) {
        ma.diags.reportRange(de.getLoc(), de.getRange(), "array index is not a compile-time value");
        return false;
    }

    qt = ma.analyseExpr(ad.getInit2(), false);
    if (qt.isInvalid()) return false;

    Expr* val = ad.getInit();

    if (!val.isCtc()) {
        ma.diags.reportRange(val.getLoc(), val.getRange(), "initializer element is not a compile-time constant");
        return false;
    }

    if (!val.isCtv() && expectedType.needsCtvInit()) {
        ma.diags.reportRange(val.getLoc(), val.getRange(), "initializer element is not a compile-time value");
        return false;
    }

    ma.checker.check(expectedType, qt, val);

    e.copyConstantFlags(val);
    e.setType(expectedType);
    return true;
}

func QualType Analyser.analyseBinaryOperator(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    BinaryOperator* b = cast<BinaryOperator*>(e);
    QualType ltype = ma.analyseExpr(b.getLHS2(), true);
    if (ltype.isInvalid()) return QualType_Invalid;

    QualType rtype = ma.analyseExpr(b.getRHS2(), true);
    if (rtype.isInvalid()) return QualType_Invalid;

    Expr* lhs = b.getLHS();
    Expr* rhs = b.getRHS();

    // TODO check if either type is void, give error

    QualType result = QualType_Invalid;
    switch (b.getOpcode()) {
    case Multiply:  fallthrough;
    case Divide:    fallthrough;
    case Reminder:  fallthrough;
    case Add:       fallthrough;
    case Subtract:
        break;
    case ShiftLeft: fallthrough;
    case ShiftRight:
        result = ltype;
        break;
    case LessThan:      fallthrough;
    case GreaterThan:   fallthrough;
    case LessEqual:     fallthrough;
    case GreaterEqual:  fallthrough;
    case Equal:         fallthrough;
    case NotEqual:
        result = g_bool;
        break;
    case And:       fallthrough;
    case Xor:       fallthrough;
    case Or:
        result = ltype;
        break;
    case LAnd:      fallthrough;
    case LOr:
        result = g_bool;
        break;
    case Assign:    fallthrough;
    case MulAssign: fallthrough;
    case DivAssign: fallthrough;
    case RemAssign: fallthrough;
    case AddAssign: fallthrough;
    case SubASsign: fallthrough;
    case ShlAssign: fallthrough;
    case ShrASsign: fallthrough;
    case AndAssign: fallthrough;
    case XorAssign: fallthrough;
    case OrAssign:
        assert(0);
        break;
    }

    e.combineConstantFlags(lhs, rhs);
    result = getBinOpType(b);

    return result;
}

func IdentifierKind getInnerExprAddressOf(Expr* e) {
    // TODO change return type to IdentifierKind, use Unresolved for not-IdentifiersExpr/MemberExpr

    switch (e.getKind()) {
    case IntegerLiteral:    fallthrough;
    case BooleanLiteral:    fallthrough;
    case CharLiteral:       fallthrough;
    case StringLiteral:     fallthrough;
    case Nil:
        break;
    case Identifier:
        IdentifierExpr* i = cast<IdentifierExpr*>(e);
        return i.getKind();
    case Type:              fallthrough;
    case Call:              fallthrough;
    case InitList:          fallthrough;
    case FieldDesignatedInit:   fallthrough;
    case ArrayDesignatedInit:
        break;
    case BinaryOperator:
        // TODO
        break;
    case UnaryOperator:
        // TODO
        break;
    case ConditionalOperator:
        // TODO
        break;
    case Builtin:
        break;
    case ArraySubscript:
        ArraySubscriptExpr* a = cast<ArraySubscriptExpr*>(e);
        return getInnerExprAddressOf(a.getBase());
    case Member:
        MemberExpr* m = cast<MemberExpr*>(e);
        // TODO MemberExpr doesn't have an IdentifierExpr anymore!!
        // Caller only needs RefKind, so return that from this function?
        return m.getKind();
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        return getInnerExprAddressOf(p.getInner());
    case BitOffset:
        return IdentifierKind.Unresolved;
    case ExplicitCast:
        ExplicitCastExpr* c = cast<ExplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    case ImplicitCast:
        ImplicitCastExpr* c = cast<ImplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    }

    return IdentifierKind.Unresolved;
}

func bool Analyser.getIdentifierKind(Analyser* ma, Expr* e) {
    IdentifierKind kind = getInnerExprAddressOf(e);
    const char* arg = "";
    switch (kind) {
    case Unresolved:
        QualType qt = e.getType();
        ma.diags.report(e.getLoc(), "cannot take the address of an rvalue of type %s", qt.diagName());
        return false;
    case Module:
        arg = "a module";
        break;
    case Function:
        // NOTE: C2 does not allow address of function like C
        arg = "a function";
        break;
    case Type:
        arg = "a type";
        break;
    case Var:
        return true;
    case EnumConstant:
        arg = "an enum constant";
        break;
    case StructMember:
        return true;
    case StructFunction:
        arg = "a function";
        break;
    case Label:
        arg = "a label";
        break;
    }
    ma.diags.report(e.getLoc(), "cannot take the address of %s", arg);
    return false;
}

func QualType Analyser.analyseUnaryOperator(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    UnaryOperator* u = cast<UnaryOperator*>(e);

    bool need_rvalue = true;

    // TODO need rvalue stuff
    switch (u.getOpcode()) {
    case PostInc:   fallthrough;
    case PostDec:   fallthrough;
    case PreInc:    fallthrough;
    case PreDec:
        ma.diags.reportRange(e.getLoc(), e.getRange(), "initializer element is not a compile-time constant");
        return QualType_Invalid;
    case AddrOf:
        need_rvalue = false;
        break;
    case Deref:     fallthrough;
    case Minus:     fallthrough;
    case Not:       fallthrough;
    case LNot:
        break;
    }

    QualType t = ma.analyseExpr(u.getInner2(), need_rvalue);
    if (t.isInvalid()) {
        return QualType_Invalid;
    }

    e = *e_ptr; // re-read in case of ImplicitCast insertions
    Expr* inner = u.getInner();

    if (t.isVoidType()) {
        ma.diags.report(e.getLoc(), "invalid argument type %s to unary expression", "'void'");
        return QualType_Invalid;
    }

    switch (u.getOpcode()) {
    case PostInc:   fallthrough;
    case PostDec:   fallthrough;
    case PreInc:    fallthrough;
    case PreDec:
        assert(0);
        return QualType_Invalid;
    case AddrOf:
        if (!ma.getIdentifierKind(inner)) return QualType_Invalid;
        QualType canon = t.getCanonicalType();
        t = ma.builder.actOnPointerType(canon);
        e.setCtc();
        break;
    case Deref:
        if (!t.isPointerType()) {
            ma.diags.report(e.getLoc(), "indirection requires pointer operand (%s invalid)", t.diagName());
            return QualType_Invalid;
        } else {
            t = t.getCanonicalType();
            const PointerType* p = t.getPointerType();
            // TODO copy flags from outer
            return p.getInner();
        }
        break;
    case Minus:     fallthrough;
    case Not:
        e.copyConstantFlags(inner);
        t = usualUnaryConversions(inner);
        break;
    case LNot:
        e.copyConstantFlags(inner);
        return g_bool;
    }

    return t;
}

// TODO move
func QualType usualUnaryConversions(Expr* e) {
    QualType qt = e.getType();
    QualType canon = qt.getCanonicalType();

    if (canon.isBuiltinType()) {
        BuiltinType* bi = canon.getBuiltinType();
        if (bi.isPromotableIntegerType()) return g_i32;
    } else if (canon.isPointerType()) {
        // TODO depend on arch width
        return g_u64;
    }

    return qt;
}

func QualType Analyser.analyseMemberExpr(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    MemberExpr* m =cast<MemberExpr*>(e);

    // we dont know what we're looking at here, it could be:
    // mod.Type
    // mod.var
    // mod.func
    // var<Type=struct>.member
    // var<Type=struct>.struct_function
    // var[index].member
    // var.member (= error)
    // Type.struct_function
    // Enum.Constant (eg. Color.Red)

    // There are 2 modes: single (the above) or multi (a.b.c.d...)

    if (!m.isSingle()) {
        return ma.analyseMultiMemberExpr(e_ptr);
    }
    QualType lhs = ma.analyseExpr(m.getBase2(), false);
    if (lhs.isInvalid()) return lhs;

    u32 rhs_idx = m.getNameIdx(0);

    // TODO cleanup case below, since Enum.Constant is always a multi-member, etc
    // TODO check rest
    // TODO convert to d.getKind(), not type (see analyseIdentifier)
    Type* t = lhs.getType();
    switch(t.getKind()) {
    case Builtin:
        // cannot happen?
        break;
    case Pointer:
        // TODO can happen?
        break;
    case Array:
        // TODO can happen?
        break;
    case Struct:
        // TODO
        break;
    case Enum:
        EnumType* et = cast<EnumType*>(t);
        EnumTypeDecl* etd = et.getDecl();
        Decl* d = cast<Decl*>(etd);
        d.setUsed();
        EnumConstantDecl* ecd = etd.findConstant(rhs_idx);
        if (!ecd) {
            ma.diags.report(e.getLoc(), "enum %s has no constant %s", d.getName(), m.getName(0));
            return QualType_Invalid;
        }
        // TODO do self-initialization checking

        Decl* cd = cast<Decl*>(ecd);
        cd.setUsed();
        m.setDecl(cd, 0);
        // TODO set ref kind (like IdentifierExpr)
        e.setCtv();
        e.setCtc();
        QualType rhs = cd.getType();
        e.setType(rhs);
        m.setKind(IdentifierKind.EnumConstant);
        return rhs;
    case Function:
        // TODO
        break;
    case Alias:
        // TODO
        break;
    case Module:
        ModuleType* mt = cast<ModuleType*>(t);
        Module* mod = mt.getModule();
        assert(mod);

        Decl* d = ma.scope.findGlobalSymbolInModule(mod, rhs_idx, e.getLoc());
        if (!d.isChecked()) {
            ma.analyseGlobalDecl(d);
            // TODO need result
        }

        m.setDecl(d, 0);
        QualType rhs = d.getType();
        e.setType(rhs);
        IdentifierKind kind = ma.setExprFlags(e_ptr, d);
        m.setKind(kind);
        return rhs;
    }

    return QualType_Invalid;
}

func QualType Analyser.analyseMultiMemberExpr(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    MemberExpr* m =cast<MemberExpr*>(e);

    Decl* base = nil;
    SrcLoc lastLoc = 0;
    bool is_ctc = false;
    bool is_ctv = false;

    u32 refcount = m.getNumRefs();
    for (u32 i=0; i<refcount; i++) {
        u32 name_idx = m.getNameIdx(i);
        SrcLoc loc = m.getLoc(i);

        Decl* d = nil;
        if (!base) {
            d = ma.scope.find(name_idx, loc);
        } else {
            if (base.getKind() == DeclKind.Var) {
                // for variables, take Type's kind
                base = ma.analyseMemberBase(loc, base.getType(), false);
                if (!base) return QualType_Invalid;
            }
            QualType baseType = base.getType();
            switch (base.getKind()) {
            case Function:
                const FunctionDecl* fd = cast<FunctionDecl*>(base);
                //if (fd.hasPrefix()) kind = IdentifierKind.StructFunction;
                //else kind = IdentifierKind.Function;
                // always error?
                break;
            case Import:
                ImportDecl* id = cast<ImportDecl*>(base);
                d = ma.scope.findGlobalSymbolInModule(id.getDest(), name_idx, loc);
                break;
            case StructType:
                // TODO check if opaque
                StructType* st = baseType.getStructType();
                d = ma.findStructMember(st.getDecl(), name_idx, loc);
                break;
            case EnumType:
                EnumTypeDecl* etd = cast<EnumTypeDecl*>(base);
                EnumConstantDecl* ecd = etd.findConstant(name_idx);
                if (!ecd) {
                    ma.diags.report(e.getLoc(), "enum %s has no constant %s", base.getName(), m.getName(0));
                    return QualType_Invalid;
                }
                // TODO do self-initialization checking

                d = cast<Decl*>(ecd);
                //kind = IdentifierKind.EnumConstant; (set below)
                break;
            case EnumConstant:
                ma.diags.report(lastLoc, "invalid member reference base");
                return QualType_Invalid;
            case FunctionType:
                // can this happen?
                break;
            case AliasType:
                break;
            case Var:
                // cannot happen?
                assert(0); // can this happen?
                //if (ma.curFunction) {
                break;
            case StaticAssert:
                assert(0);
                break;
            }
        }

        if (!d) return QualType_Invalid;

        lastLoc = loc;
        // Note: this can happen in arraysizeExpr: var[test.number] a; (as global/struct-member)
        if (!d.isChecked()) {
            ma.analyseGlobalDecl(d);
            // TODO need result
        }

        d.setUsed();
        m.setDecl(d, i);
        base = d;
    }

    IdentifierKind kind = ma.setExprFlags(e_ptr, base);
    //e.setKind(kind);
    e.setType(base.getType());
    if (e.isCtv()) e.setRValue();
    return base.getType();
}

func Decl* Analyser.analyseMemberBase(Analyser* ma, SrcLoc loc, QualType baseType, bool ptr_deref) {
    const Type* t = baseType.getTypeOrNil();
    switch (t.getKind()) {
    case Builtin:
        break;
    case Pointer:
        if (ptr_deref) break;
        PointerType* pt = cast<PointerType*>(t);
        return ma.analyseMemberBase(loc, pt.getInner(), true);
    case Array:
        break;
    case Struct:
        // TODO check if opaque
        StructType* st = baseType.getStructType();
        return cast<Decl*>(st.getDecl());
    case Enum:
        // TODO
        break;
    case Function:
        break;
    case Alias:
        // TODO
        break;
    case Module:
        assert(0);
        break;
    }
    ma.diags.report(loc, "invalid member reference base");
    return nil;
}

func QualType Analyser.analyseBuiltin(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    BuiltinExpr* b = cast<BuiltinExpr*>(e);

    switch (b.getKind()) {
    case Sizeof:
        return ma.analyseSizeof(b);
    case Elemsof:
        return ma.analyseElemsof(b);
    case EnumMin:   fallthrough;
    case EnumMax:
        return ma.analyseEnumMinMax(b);
    case OffsetOf:
        break;
    case ToContainer:
        break;
    }

    return QualType_Invalid;
}

func QualType Analyser.analyseArraySubscriptExpr(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    ArraySubscriptExpr* sub = cast<ArraySubscriptExpr*>(e);

    QualType q = ma.analyseExpr(sub.getBase2(), true);
    if (q.isInvalid()) return q;

    // Deference alias types
    // TODO

    if (!q.isPointerType()) {
        ma.diags.reportRange(e.getLoc(), e.getRange(), "subscripted value is not an array or pointer");
        return QualType_Invalid;
    }

    QualType qidx = ma.analyseExpr(sub.getIndex2(), true);
    if (qidx.isInvalid()) return qidx;

    PointerType* pt = q.getPointerType();
    return pt.getInner();
}

func QualType Analyser.analyseEnumMinMax(Analyser* ma, BuiltinExpr* e) {
    return QualType_Invalid;
}

func QualType Analyser.analyseSizeof(Analyser* ma, BuiltinExpr* e) {
    Expr* inner = e.getInner();
    assert(inner);

    QualType qt;
    if (inner.getKind() == ExprKind.Type) {
        TypeExpr* te = cast<TypeExpr*>(inner);
        TypeRef* ref = te.getTypeRef();
        qt = ma.analyseTypeRef(ref);
    } else {
        // is Identifier/memberExpr, could still be Type!
        qt = ma.analyseExpr(&inner, false);
    }
    if (qt.isInvalid()) return QualType_Invalid;

    size_analyser.TypeSize info = size_analyser.sizeOfType(qt);
    e.setValue(info.size);
    return g_u32;
}

func QualType Analyser.analyseElemsof(Analyser* ma, BuiltinExpr* b) {
    // could be EnumType or array VarDecl

    Expr* inner = b.getInner();
    QualType qt = ma.analyseExpr(&inner, false);
    if (qt.isInvalid()) return qt;

    const ArrayType* at = qt.getArrayTypeOrNil();
    if (at) {
        b.setValue(at.getSize());
        return g_u32;
    }
    const EnumType* et = qt.getEnumTypeOrNil();
    if (et) {
        const EnumTypeDecl* etd = et.getDecl();
        b.setValue(etd.getNumConstants());
        return g_u32;
    }
    ma.diags.report(inner.getLoc(), "elemsof can only be used on arrays/enums");
    return QualType_Invalid;
}

// TODO move somewhere else
func Decl* Analyser.findStructMember(Analyser* ma, StructTypeDecl* s, u32 name_idx, SrcLoc loc) {
    // TODO could be a (static) struct function or a member

    Decl* d = s.find(name_idx);
    if (!d) {
        ma.diags.report(loc, "%s %s does not have a member %s",
            s.isStruct() ? "struct" : "union", s.asDecl().getName(), idx2name(name_idx));
        return nil;
    }

    // TODO check if struct member

    return d;
}



/* Copyright 2022 Bas van den Berg
*/

module module_analyser;

import ast local;
import ast_builder;

import stdio; // TEMP

// TODO move to AnalyserUtils
func QualType getPointerFromArray(ast_builder.Builder* builder, QualType q) {
    q = q.getCanonicalType();
    const ArrayType* a = cast<ArrayType*>(q.getTypeOrNil());
    QualType elem = a.getElemType();
    QualType res = builder.actOnPointerType(elem, q.getQualifiers());
    //TODO:  canonical is already done in actOnPointerType now
/*
    // canonical can be either self or a pointer to elem's canonical type
    QualType canon = elem.getCanonicalType();
    if (elem.getTypeOrNil() == canon.getTypeOrNil()) {
        res.setCanonicalType(res);
    } else {
        // TODO use type.getPointerType()!
        QualType c = builder.actOnPointerType(canon, q.getQualifiers());
        res.setCanonicalType(c);
    }
*/
    return res;
}

func QualType ModuleAnalyser.analyseExpr(ModuleAnalyser* ma, Expr** e_ptr, bool need_rvalue) {
    assert(e_ptr);
    QualType result = ma.analyseExprInner(e_ptr);
    if (result.isInvalid()) return result;

    Expr* e = *e_ptr;
    e.setType(result);

    if (need_rvalue && e.isLValue()) {
        QualType qt = e.getType();

        if (qt.isArrayType()) {
            result = getPointerFromArray(ma.builder, qt);
            ma.builder.insertImplicitCast(ImplicitCastKind.ArrayToPointerDecay, e_ptr, result);
        } else {
            ma.builder.insertImplicitCast(ImplicitCastKind.LValueToRValue, e_ptr, qt);
        }
    }

    return result;
}

func QualType ModuleAnalyser.analyseExprInner(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;

    switch (e.getKind()) {
    case IntegerLiteral:
        // TODO determine kind based on value, for now just return u32
        return g_u32;
    case BooleanLiteral:
        return g_bool;
    case CharLiteral:
        return g_i8;
    case StringLiteral:
        // char* (const?)
        break;
    case Nil:
        // void*
        break;
    case Identifier:
        Decl* d = ma.analyseIdentifier(e_ptr);
        if (!d) break;
        return d.getType();
    case Type:
        break;
    case Call:
        return g_void; // to get CTC check in analyseInitExpr
    case InitList:
        (*e_ptr).dump();
        assert(0);
        break;
    case FieldDesignatedInit:
        (*e_ptr).dump();
        assert(0);
        break;
    case ArrayDesignatedInit:
        return ma.analyseArrayDesignatedInit(e_ptr);
    case BinaryOperator:
        return ma.analyseBinaryOperator(e_ptr);
    case UnaryOperator:
        return ma.analyseUnaryOperator(e_ptr);
    case ConditionalOperator:
        break;
    case Builtin:
        return ma.analyseBuiltin(e_ptr);
    case ArraySubscript:
        return ma.analyseArraySubscriptExpr(e_ptr);
    case Member:
        return ma.analyseMemberExpr(e_ptr);
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        QualType qt = ma.analyseExpr(p.getInner2(), false);
        e.copyConstantFlags(p.getInner());
        return qt;
    case BitOffset:
        break;
    case ExplicitCast:
        break;
    case ImplicitCast:
        break;
    }
    return QualType.init0();
}

func Decl* ModuleAnalyser.analyseIdentifier(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    IdentifierExpr* i = cast<IdentifierExpr*>(e);
    //stdio.printf("FIND %s (%u) idx %u\n", i.getName(), i.getNameIdx(), ma.checkIndex);
    Decl* d = ma.scope.find(i.getNameIdx(), e.getLoc());
    //stdio.printf("D  %p\n", d);
    if (!d) return nil;

    if (!d.isChecked()) {
        ma.analyseGlobalDecl(d);
        // TODO need result
    }

    QualType qt = d.getType();
    assert(qt.isValid());
    e.setType(qt);
    i.setDecl(d);
    d.setUsed();

    IdentifierKind kind = ma.setExprFlags(e_ptr, d);
    i.setKind(kind);

    if (e.isCtv()) e.setRValue();

    return d;
}

func IdentifierKind ModuleAnalyser.setExprFlags(ModuleAnalyser* ma, Expr** e_ptr, Decl* d) {
    Expr* e = *e_ptr;
    IdentifierKind kind = IdentifierKind.Unresolved;
    switch (d.getKind()) {
    case Function:
        e.setCtc();
        e.setRValue();
        ma.builder.insertImplicitCast(ImplicitCastKind.FunctionToPointerDecay, e_ptr, d.getType());
        const FunctionDecl* fd = cast<FunctionDecl*>(d);
        if (fd.hasPrefix()) kind = IdentifierKind.StructFunction;
        else kind = IdentifierKind.Function;
        break;
    case Import:
        e.setCtc();
        e.setRValue();
        kind = IdentifierKind.Module;
        break;
    case StructType:
        e.setRValue();
        kind = IdentifierKind.Type;
        break;
    case EnumType:
        e.setCtc();
        e.setRValue();
        kind = IdentifierKind.Type;
        break;
    case EnumConstant:
        e.setCtc();
        e.setCtv();
        kind = IdentifierKind.EnumConstant;
        break;
    case FunctionType:
        e.setCtc();
        kind = IdentifierKind.Type;
        break;
    case AliasType:
        kind = IdentifierKind.Type;
        break;
    case Var:
        VarDecl* vd = cast<VarDecl*>(d);
        QualType t = vd.asDecl().getType();
        e.setCtc();
        const Expr* init_ = vd.getInit();
        if (init_ && t.isConst() && init_.isCtv()) e.setCtv();
        switch (vd.getKind()) {
        case GlobalVar: fallthrough;
        case LocalVar:  fallthrough;
        case FunctionParam:
            kind = IdentifierKind.Var;
            break;
        case StructMember:
            kind = IdentifierKind.StructMember;
            break;
        }
        break;
    case StaticAssert:
        break;
    }
    return kind;
}

func QualType getBinOpType(BinaryOperator* b) {
    const Expr* lhs = b.getLHS();
    const Expr* rhs = b.getRHS();
    QualType tleft = lhs.getType();
    QualType tright = rhs.getType();

    // TODO

    if (b.getOpcode() == BinaryOpcode.Subtract) return g_i32; // TEMP

    return tleft;
}

func QualType ModuleAnalyser.analyseArrayDesignatedInit(ModuleAnalyser* ma, Expr** e_ptr) {
    // TODO this function should only be called from analyseInitListExpr directly! (so we know the type)
    Expr* e = *e_ptr;
    ArrayDesignatedInitExpr* ad = cast<ArrayDesignatedInitExpr*>(e);

    ma.analyseExpr(ad.getDesignator2(), true);

    Expr* de = ad.getDesignator(); // re-read in case of ImplicitCast insertion
    if (!de.isCtv()) {
        ma.diags.reportRange(de.getLoc(), de.getRange(), "array index is not a compile-time value");
        return QualType.init0();
    }

    // TODO set CTC/CTV flags
    QualType qt = ma.analyseExpr(ad.getInit2(), true);
    e.copyConstantFlags(ad.getInit());
    return qt;
}

func QualType ModuleAnalyser.analyseBinaryOperator(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    BinaryOperator* b = cast<BinaryOperator*>(e);
    QualType ltype = ma.analyseExpr(b.getLHS2(), true);
    if (ltype.isInvalid()) return QualType.init0();

    QualType rtype = ma.analyseExpr(b.getRHS2(), true);
    if (rtype.isInvalid()) return QualType.init0();

    Expr* lhs = b.getLHS();
    Expr* rhs = b.getRHS();

    // TODO check if either type is void, give error

    QualType result = QualType.init0();
    switch (b.getOpcode()) {
    case Multiply:  fallthrough;
    case Divide:    fallthrough;
    case Reminder:  fallthrough;
    case Add:       fallthrough;
    case Subtract:
        break;
    case ShiftLeft: fallthrough;
    case ShiftRight:
        result = ltype;
        break;
    case LessThan:      fallthrough;
    case GreaterThan:   fallthrough;
    case LessEqual:     fallthrough;
    case GreaterEqual:  fallthrough;
    case Equal:         fallthrough;
    case NotEqual:
        result = g_bool;
        break;
    case And:       fallthrough;
    case Xor:       fallthrough;
    case Or:
        result = ltype;
        break;
    case LAnd:      fallthrough;
    case LOr:
        result = g_bool;
        break;
    case Assign:    fallthrough;
    case MulAssign: fallthrough;
    case DivAssign: fallthrough;
    case RemAssign: fallthrough;
    case AddAssign: fallthrough;
    case SubASsign: fallthrough;
    case ShlAssign: fallthrough;
    case ShrASsign: fallthrough;
    case AndAssign: fallthrough;
    case XorAssign: fallthrough;
    case OrAssign:
        assert(0);
        break;
    }

    e.combineConstantFlags(lhs, rhs);
    result = getBinOpType(b);

    return result;
}

func IdentifierKind getInnerExprAddressOf(Expr* e) {
    // TODO change return type to IdentifierKind, use Unresolved for not-IdentifiersExpr/MemberExpr

    switch (e.getKind()) {
    case IntegerLiteral:    fallthrough;
    case BooleanLiteral:    fallthrough;
    case CharLiteral:       fallthrough;
    case StringLiteral:     fallthrough;
    case Nil:
        break;
    case Identifier:
        IdentifierExpr* i = cast<IdentifierExpr*>(e);
        return i.getKind();
    case Type:              fallthrough;
    case Call:              fallthrough;
    case InitList:          fallthrough;
    case FieldDesignatedInit:   fallthrough;
    case ArrayDesignatedInit:
        break;
    case BinaryOperator:
        // TODO
        break;
    case UnaryOperator:
        // TODO
        break;
    case ConditionalOperator:
        // TODO
        break;
    case Builtin:
        break;
    case ArraySubscript:
        ArraySubscriptExpr* a = cast<ArraySubscriptExpr*>(e);
        return getInnerExprAddressOf(a.getBase());
    case Member:
        MemberExpr* m = cast<MemberExpr*>(e);
        // TODO MemberExpr doesn't have an IdentifierExpr anymore!!
        // Caller only needs RefKind, so return that from this function?
        return m.getKind();
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        return getInnerExprAddressOf(p.getInner());
    case BitOffset:
        return IdentifierKind.Unresolved;
    case ExplicitCast:
        ExplicitCastExpr* c = cast<ExplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    case ImplicitCast:
        ImplicitCastExpr* c = cast<ImplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    }

    return IdentifierKind.Unresolved;
}

func bool ModuleAnalyser.getIdentifierKind(ModuleAnalyser* ma, Expr* e) {
    IdentifierKind kind = getInnerExprAddressOf(e);
    const char* arg = "";
    switch (kind) {
    case Unresolved:
        QualType qt = e.getType();
        ma.diags.report(e.getLoc(), "cannot take the address of an rvalue of type %s", qt.diagName());
        return false;
    case Module:
        arg = "a module";
        break;
    case Function:
        // NOTE: C2 does not allow address of function like C
        arg = "a function";
        break;
    case Type:
        arg = "a type";
        break;
    case Var:
        return true;
    case EnumConstant:
        arg = "an enum constant";
        break;
    case StructMember:
        return true;
    case StructFunction:
        arg = "a function";
        break;
    case Label:
        arg = "a label";
        break;
    }
    ma.diags.report(e.getLoc(), "cannot take the address of %s", arg);
    return false;
}

func QualType ModuleAnalyser.analyseUnaryOperator(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    UnaryOperator* u = cast<UnaryOperator*>(e);

    bool need_rvalue = true;

    // TODO need rvalue stuff
    switch (u.getOpcode()) {
    case PostInc:   fallthrough;
    case PostDec:   fallthrough;
    case PreInc:    fallthrough;
    case PreDec:
        ma.diags.reportRange(e.getLoc(), e.getRange(), "initializer element is not a compile-time constant");
        return QualType.init0();
    case AddrOf:
        need_rvalue = false;
        break;
    case Deref:     fallthrough;
    case Minus:     fallthrough;
    case Not:       fallthrough;
    case LNot:
        break;
    }

    QualType t = ma.analyseExpr(u.getInner2(), need_rvalue);
    if (t.isInvalid()) {
        return QualType.init0();
    }

    e = *e_ptr; // re-read in case of ImplicitCast insertions
    Expr* inner = u.getInner();

    if (t.isVoidType()) {
        ma.diags.report(e.getLoc(), "invalid argument type %s to unary expression", "'void'");
        return QualType.init0();
    }

    switch (u.getOpcode()) {
    case PostInc:   fallthrough;
    case PostDec:   fallthrough;
    case PreInc:    fallthrough;
    case PreDec:
        assert(0);
        return QualType.init0();
    case AddrOf:
        if (!ma.getIdentifierKind(inner)) return QualType.init0();
        QualType canon = t.getCanonicalType();
        t = ma.builder.actOnPointerType(canon, canon.getQualifiers());
        e.setCtc();
        break;
    case Deref:
        if (!t.isPointerType()) {
            ma.diags.report(e.getLoc(), "indirection requires pointer operand (%s invalid)", t.diagName());
            return QualType.init0();
        } else {
            t = t.getCanonicalType();
            const PointerType* p = t.getPointerType();
            // TODO copy flags from outer
            return p.getInner();
        }
        break;
    case Minus:     fallthrough;
    case Not:
        e.copyConstantFlags(inner);
        t = usualUnaryConversions(inner);
        break;
    case LNot:
        e.copyConstantFlags(inner);
        return g_bool;
    }

    return t;
}

// TODO move
func QualType usualUnaryConversions(Expr* e) {
    QualType qt = e.getType();
    QualType canon = qt.getCanonicalType();

    if (canon.isBuiltinType()) {
        BuiltinType* bi = canon.getBuiltinType();
        if (bi.isPromotableIntegerType()) return g_i32;
    } else if (canon.isPointerType()) {
        // TODO depend on arch width
        return g_u64;
    }

    return qt;
}

func QualType ModuleAnalyser.analyseMemberExpr(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    MemberExpr* m =cast<MemberExpr*>(e);

    QualType lhs = ma.analyseExpr(m.getBase2(), false);
    if (lhs.isInvalid()) return lhs;

    // we dont know what we're looking at here, it could be:
    // mod.Type
    // mod.var
    // mod.func
    // var<Type=struct>.member
    // var<Type=struct>.struct_function
    // var[index].member
    // var.member (= error)
    // Type.struct_function
    // Enum.Constant (eg. Color.Red)

    u32 rhs_idx = m.getNameIdx();

    // TODO check rest
    // TODO convert to d.getKind(), not type (see analyseIdentifier)
    Type* t = lhs.getType();
    switch(t.getKind()) {
    case Builtin:
        // cannot happen?
        break;
    case Pointer:
        // TODO can happen?
        break;
    case Array:
        // TODO can happen?
        break;
    case Struct:
        // TODO
        break;
    case Enum:
        EnumType* et = cast<EnumType*>(t);
        EnumTypeDecl* etd = et.getDecl();
        Decl* d = cast<Decl*>(etd);
        d.setUsed();
        EnumConstantDecl* ecd = etd.findConstant(rhs_idx);
        if (!ecd) {
            ma.diags.report(e.getLoc(), "enum %s has no constant %s", d.getName(), m.getName());
            return QualType.init0();
        }
        // TODO do self-initialization checking

        Decl* cd = cast<Decl*>(ecd);
        cd.setUsed();
        m.setDecl(cd);
        // TODO set ref kind (like IdentifierExpr)
        e.setCtv();
        e.setCtc();
        QualType rhs = cd.getType();
        e.setType(rhs);
        m.setKind(IdentifierKind.EnumConstant);
        return rhs;
    case Function:
        // TODO
        break;
    case Alias:
        // TODO
        break;
    case Module:
        ModuleType* mt = cast<ModuleType*>(t);
        Module* mod = mt.getModule();
        assert(mod);

        Decl* d = ma.scope.findGlobalSymbolInModule(mod, rhs_idx, e.getLoc());
        if (!d.isChecked()) {
            ma.analyseGlobalDecl(d);
            // TODO need result
        }

        m.setDecl(d);
        QualType rhs = d.getType();
        e.setType(rhs);
        IdentifierKind kind = ma.setExprFlags(e_ptr, d);
        m.setKind(kind);
        return rhs;
    }

    return QualType.init0();
}

func QualType ModuleAnalyser.analyseBuiltin(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    BuiltinExpr* b = cast<BuiltinExpr*>(e);

    switch (b.getKind()) {
    case Sizeof:
        return ma.analyseSizeof(b);
    case Elemsof:
        break;
    case EnumMin:
        break;
    case EnumMax:
        break;
    case OffsetOf:
        break;
    case ToContainer:
        break;
    }

    return QualType.init0();
}

func QualType ModuleAnalyser.analyseArraySubscriptExpr(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    ArraySubscriptExpr* sub = cast<ArraySubscriptExpr*>(e);

    QualType q = ma.analyseExpr(sub.getBase2(), true);
    if (q.isInvalid()) return q;

    // Deference alias types
    // TODO

    if (!q.isPointerType()) {
        ma.diags.reportRange(e.getLoc(), e.getRange(), "subscripted value is not an array or pointer");
        return QualType.init0();
    }

    QualType qidx = ma.analyseExpr(sub.getIndex2(), true);
    if (qidx.isInvalid()) return qidx;

    PointerType* pt = q.getPointerType();
    return pt.getInner();
}

func QualType ModuleAnalyser.analyseSizeof(ModuleAnalyser* ma, BuiltinExpr* e) {
    Expr* inner = e.getInner();
    assert(inner);
    // TODO switch
    if (inner.getKind() == ExprKind.Type) {
        TypeExpr* te = cast<TypeExpr*>(inner);
        // TODO
        e.setValue(4);
    }
    return g_u32;
}


/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module module_analyser;

import ast local;
import ast_builder;
import ctv_analyser;
import src_loc local;

func QualType Analyser.analyseExpr(Analyser* ma, Expr** e_ptr, bool need_rvalue, u32 side) {
    assert(e_ptr);
    QualType result = ma.analyseExprInner(e_ptr, side);
    if (result.isInvalid()) return result;

    Expr* e = *e_ptr;
    e.setType(result);

    if (need_rvalue && e.isLValue()) {
        QualType canon = result.getCanonicalType();
        assert(canon.isValid());

        if (canon.isArrayType()) {
            result = getPointerFromArray(ma.builder, canon);
            ma.builder.insertImplicitCast(ImplicitCastKind.ArrayToPointerDecay, e_ptr, result);
        } else {
            // LValueToRValue conversion strips const of type
            result.unsetConst();
            ma.builder.insertImplicitCast(ImplicitCastKind.LValueToRValue, e_ptr, result);
        }
    }

    return result;
}

func QualType Analyser.analyseExprInner(Analyser* ma, Expr** e_ptr, u32 side) {
    Expr* e = *e_ptr;

    switch (e.getKind()) {
    case IntegerLiteral:
        return e.getType();
    case FloatLiteral:
        return e.getType();
    case BooleanLiteral:
        return g_bool;
    case CharLiteral:
        return g_i8;
    case StringLiteral:
        return e.getType(); // already set in creator
    case Nil:
        return g_void_ptr;
    case Identifier:
        Decl* d = ma.analyseIdentifier(e_ptr, side);
        if (!d) break;
        return d.getType();
    case Type:
        break;
    case Call:
        return ma.analyseCallExpr(e_ptr);
    case InitList:
        (*e_ptr).dump();
        assert(0);
        break;
    case FieldDesignatedInit:
        (*e_ptr).dump();
        assert(0);
        break;
    case ArrayDesignatedInit:
        (*e_ptr).dump();
        assert(0);
        break;
    case BinaryOperator:
        return ma.analyseBinaryOperator(e_ptr);
    case UnaryOperator:
        return ma.analyseUnaryOperator(e_ptr, side);
    case ConditionalOperator:
        return ma.analyseConditionalOperator(e_ptr);
    case Builtin:
        return ma.analyseBuiltin(e_ptr);
    case ArraySubscript:
        return ma.analyseArraySubscriptExpr(e_ptr, side);
    case Member:
        return ma.analyseMemberExpr(e_ptr, side);
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        QualType qt = ma.analyseExpr(p.getInner2(), false, side);
        Expr* inner = p.getInner();
        e.copyConstantFlags(inner);
        e.copyValType(inner);
        return qt;
    case BitOffset:
        break;
    case ExplicitCast:
        return ma.analyseExplicitCast(e_ptr);
    case ImplicitCast:
        break;
    }
    return QualType_Invalid;
}

func Decl* Analyser.analyseIdentifier(Analyser* ma, Expr** e_ptr, u32 side) {
    Expr* e = *e_ptr;
    IdentifierExpr* i = cast<IdentifierExpr*>(e);
    Decl* d = ma.scope.find(i.getNameIdx(), e.getLoc(), ma.usedPublic);
    if (!d) {
        ma.has_error = true;
        return nil;
    }

    if (!d.isChecked()) {
        ma.analyseGlobalDecl(d);
        // TODO need result
    }

    QualType qt = d.getType();
    assert(qt.isValid());
    e.setType(qt);
    i.setDecl(d);

    if (side & RHS || side == 0) d.setUsed();
    else {
        // parameters are used if LHS|RHS
        if (d.isVarDecl()) {
            VarDecl* vd = cast<VarDecl*>(d);
            if (vd.isParameter()) d.setUsed();
        }
    }

    IdentifierKind kind = ma.setExprFlags(e_ptr, d);
    i.setKind(kind);

    return d;
}

func IdentifierKind Analyser.setExprFlags(Analyser* ma, Expr** e_ptr, Decl* d) {
    Expr* e = *e_ptr;
    IdentifierKind kind = IdentifierKind.Unresolved;
    switch (d.getKind()) {
    case Function:
        e.setCtc();
        e.setRValue();
        ma.builder.insertImplicitCast(ImplicitCastKind.FunctionToPointerDecay, e_ptr, d.getType());
        kind = IdentifierKind.Function;
        break;
    case Import:
        e.setCtc();
        kind = IdentifierKind.Module;
        break;
    case StructType:
        kind = IdentifierKind.Type;
        break;
    case EnumType:
        e.setCtc();
        kind = IdentifierKind.Type;
        break;
    case EnumConstant:
        e.setCtc();
        e.setCtv();
        e.setRValue();
        kind = IdentifierKind.EnumConstant;
        break;
    case FunctionType:
        e.setCtc();
        kind = IdentifierKind.Type;
        break;
    case AliasType:
        kind = IdentifierKind.Type;
        break;
    case Var:
        VarDecl* vd = cast<VarDecl*>(d);
        QualType t = vd.asDecl().getType();
        if (vd.isGlobal()) e.setCtc();
        e.setLValue();
        const Expr* init_ = vd.getInit();
        if (init_ && t.isConst() && init_.isCtv()) e.setCtv();
        switch (vd.getKind()) {
        case GlobalVar: fallthrough;
        case LocalVar:  fallthrough;
        case FunctionParam:
            kind = IdentifierKind.Var;
            break;
        case StructMember:
            kind = IdentifierKind.StructMember;
            break;
        }
        break;
    }
    return kind;
}

func IdentifierKind getInnerExprAddressOf(Expr* e) {
    // TODO change return type to IdentifierKind, use Unresolved for not-IdentifiersExpr/MemberExpr

    switch (e.getKind()) {
    case IntegerLiteral:    fallthrough;
    case FloatLiteral:      fallthrough;
    case BooleanLiteral:    fallthrough;
    case CharLiteral:       fallthrough;
    case StringLiteral:     fallthrough;
    case Nil:
        break;
    case Identifier:
        IdentifierExpr* i = cast<IdentifierExpr*>(e);
        return i.getKind();
    case Type:              fallthrough;
    case Call:              fallthrough;
    case InitList:          fallthrough;
    case FieldDesignatedInit:   fallthrough;
    case ArrayDesignatedInit:
        break;
    case BinaryOperator:
        assert(0); // TODO
        break;
    case UnaryOperator:
        assert(0); // TODO
        break;
    case ConditionalOperator:
        assert(0); // TODO
        break;
    case Builtin:
        break;
    case ArraySubscript:
        ArraySubscriptExpr* a = cast<ArraySubscriptExpr*>(e);
        return getInnerExprAddressOf(a.getBase());
    case Member:
        MemberExpr* m = cast<MemberExpr*>(e);
        return m.getKind();
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        return getInnerExprAddressOf(p.getInner());
    case BitOffset:
        return IdentifierKind.Unresolved;
    case ExplicitCast:
        ExplicitCastExpr* c = cast<ExplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    case ImplicitCast:
        ImplicitCastExpr* c = cast<ImplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    }

    return IdentifierKind.Unresolved;
}

func bool Analyser.getIdentifierKind(Analyser* ma, Expr* e) {
    IdentifierKind kind = getInnerExprAddressOf(e);
    const char* arg = "";
    switch (kind) {
    case Unresolved:
        QualType qt = e.getType();
        ma.error(e.getLoc(), "cannot take the address of an rvalue of type '%s'", qt.diagName());
        return false;
    case Module:
        arg = "a module";
        break;
    case Function:
        // NOTE: C2 does not allow address of function like C
        arg = "a function";
        break;
    case Type:
        arg = "a type";
        break;
    case Var:
        return true;
    case EnumConstant:
        arg = "an enum constant";
        break;
    case StructMember:
        return true;
    case Label:
        arg = "a label";
        break;
    }
    ma.error(e.getLoc(), "cannot take the address of %s", arg);
    return false;
}

func QualType getMinusType(QualType qt) {
    if (!qt.isBuiltinType()) return QualType_Invalid;
    BuiltinType* bi = qt.getBuiltinType();
    switch (bi.getKind()) {
    case Char:      fallthrough;
    case Int8:      fallthrough;
    case Int16:     fallthrough;
    case Int32:     fallthrough;
    case Int64:
        return qt;
    case UInt8:     fallthrough;
    case UInt16:    fallthrough;
    case UInt32:
        return g_i32;
    case UInt64:
        return g_i64;
    case Float32:   fallthrough;
    case Float64:   fallthrough;
    case ISize:
        return qt;
    case USize:
        return g_isize;
    case Bool:      fallthrough;
    case Void:
        break;
    }
    return QualType_Invalid;
}

// 0  cannot happen
// 1  invalid
// 2  builtin - builtin
// 3  builtin - enum -> int
// 4  pointer - pointer
// 5  struct - struct
// 6  enum - builtin -> int
// 7  enum - enum
const u8[elemsof(TypeKind)][elemsof(TypeKind)] CondOpTable = {
    //  Builtin Pointer Array   Struct  Enum    Func   Alias  Module
    //  Builtin += / -=
    {   2,      1,      0,      1,      3,      0,     0,     0  },
    //  Pointer += / -=
    {   1,      4,      0,      1,      1,      1,     0,     0  },
    //  Array += / -=
    {   0,      0,      0,      0,      0,      0,     0,     0  },
    //  Struct += / -=
    {   1,      1,      0,      5,      1,      1,     0,     0  },
    //  Enum += / -=
    {   6,      1,      0,      1,      7,      1,     0,     0  },
    //  Function += / -=
    {   0,      0,      0,      1,      0,      0,     0,     0  },
    // Alias + Module are zero
}
func QualType Analyser.analyseConditionalOperator(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    ConditionalOperator* cond = cast<ConditionalOperator*>(e);
    QualType qt = ma.analyseExpr(cond.getCond2(), true, RHS);
    if (qt.isInvalid()) return QualType_Invalid;

    ma.checker.check(g_bool, qt, cond.getCond2(), cond.getCond().getLoc());

    QualType lhs = ma.analyseExpr(cond.getLHS2(), true, RHS);
    QualType rhs = ma.analyseExpr(cond.getRHS2(), true, RHS);
    if (lhs.isInvalid() || rhs.isInvalid()) return QualType_Invalid;

    QualType lcanon = lhs.getCanonicalType();
    QualType rcanon = rhs.getCanonicalType();
    assert(lcanon.isValid());
    assert(rcanon.isValid());

    u8 res = CondOpTable[lcanon.getKind()][rcanon.getKind()];
    switch (res) {
    case 0: // cannot happen
        break;
    case 1: // invalid
        ma.error(e.getLoc(), "invalid operands to ternary operator (%s and %s)", lhs.diagName(), rhs.diagName());
        return QualType_Invalid;
    case 2: // builtin - builtin
        // TODO do integer promotions, check for void, float etc
        return lhs;
    case 3: // builtin - enum -> int
        // TODO do integer promotions, check for void, float etc
        return lhs;
    case 4: // pointer - pointer
        // TODO check if same type
        return lhs;
    case 5: // struct - struct
        bool ok = ma.checker.check(lhs, rhs, e_ptr, e.getLoc());
        if (!ok) return QualType_Invalid;
        return lhs;
    case 6: // enum - builtin -> int
        // TODO do integer promotions, check for void, float etc
        return rhs;
    case 7: // enum - enum
        bool ok = ma.checker.check(lhs, rhs, e_ptr, e.getLoc());
        if (!ok) return QualType_Invalid;
        return lhs;
    }
    assert(0);
    return QualType_Invalid;
}

func bool Analyser.checkAssignment(Analyser* ma, Expr* assignee, QualType tleft, const char* msg, SrcLoc loc) {
    if (tleft.isConst()) {
        //assignee.dump();
        if (assignee.isIdentifier()) {
            ma.error(loc, "cannot assign to read-only variable '%s'", "TODO");
            return false;
        }
        if (assignee.isMember()) {
            MemberExpr* m = cast<MemberExpr*>(assignee);
            switch (m.getKind()) {
            case Unresolved:
                assert(0);
                break;
            case Module:
                assert(0);
                break;
            case Function:
                break;
            case Type:
                break;
            case Var:
                ma.error(loc, "cannot assign to read-only variable '%s'", m.getLastMemberName());
                return false;
            case EnumConstant:
                break;
            case StructMember:
                ma.error(loc, "assignment of member '%s' in read-only object", m.getLastMemberName());
                return false;
            case Label:
                break;
            }
            ma.error(loc, "cannot assign to variable with const-qualified type '%s'", tleft.diagName());
        }
        return false;
    }

    if (!assignee.isLValue()) {
        ma.error(assignee.getLoc(), "lvalue required as %s", msg);
        return false;
    }

    if (tleft.isArrayType()) {
        ma.error(loc, "array type '%s' is not assignable", tleft.diagName());
        return false;
    }

    return true;
}

func QualType usualUnaryConversions(Expr* e) {
    QualType qt = e.getType();
    QualType canon = qt.getCanonicalType();

    if (canon.isBuiltinType()) {
        BuiltinType* bi = canon.getBuiltinType();
        if (bi.isPromotableIntegerType()) return g_i32;
    } else if (canon.isPointer()) {
        // TODO depend on arch width
        return g_u64;
    }

    return qt;
}

func QualType Analyser.analyseExplicitCast(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    ExplicitCastExpr* c = cast<ExplicitCastExpr*>(e);
    TypeRef* ref = c.getTypeRef();
    QualType destType = ma.analyseTypeRef(ref);

    QualType srcType = ma.analyseExpr(c.getInner2(), true, RHS);

    if (srcType.isInvalid() || destType.isInvalid()) return QualType_Invalid;

    Expr* inner = c.getInner();
    e.copyConstantFlags(inner);
    e.copyValType(inner);

    if (!destType.isScalar()) {
        ma.error(ref.getLoc(), "used type '%s' where arithmetic or pointer type is required", destType.diagName());
        return QualType_Invalid;
    }

    if (!ma.checker.checkCast(destType, srcType, ref.getLoc(), inner.getLoc())) return QualType_Invalid;

    return destType;
}

func QualType Analyser.analyseArraySubscriptExpr(Analyser* ma, Expr** e_ptr, u32 side) {
    Expr* e = *e_ptr;
    ArraySubscriptExpr* sub = cast<ArraySubscriptExpr*>(e);

    QualType q = ma.analyseExpr(sub.getBase2(), true, side);
    if (q.isInvalid()) return q;

    // Derefence alias types
    Expr* index = sub.getIndex();
    if (index.isBitOffset()) {
        if (side & LHS) {
            ma.errorRange(e.getLoc(), e.getRange(), "bitoffset cannot be used as left hand side expression");
            return QualType_Invalid;
        }
        Expr* base = sub.getBase();
        q = ma.analyseBitOffsetExpr(q, base, index);
        e.combineConstantFlags(base, index);
        return q;
    }

    q = q.getCanonicalType();

    if (!q.isPointer()) {
        ma.errorRange(e.getLoc(), e.getRange(), "subscripted value is not an array or pointer");
        return QualType_Invalid;
    }

    QualType qidx = ma.analyseExpr(sub.getIndex2(), true, RHS);
    if (qidx.isInvalid()) return qidx;

    PointerType* pt = q.getPointerType();
    return pt.getInner();
}

func QualType Analyser.analyseBitOffsetExpr(Analyser* ma, QualType ltype, Expr* base, Expr* e) {
    BitOffsetExpr* bo = cast<BitOffsetExpr*>(e);
    QualType canon = ltype.getCanonicalType();

    BuiltinType* bi = canon.getBuiltinType();
    if (!canon.isBuiltinType() || !bi.isUnsigned()) {
        ma.error(base.getLoc(), "bitoffsets are only allowed on unsigned integer type");
        return QualType_Invalid;
    }

    Value lval;
    Value rval;
    bool lvalid = ma.analyseBitOffsetIndex(bo.getLHS2(), canon, &lval);
    bool rvalid = ma.analyseBitOffsetIndex(bo.getRHS2(), canon, &rval);

    if (lvalid && rvalid) {
        if (!rval.less_than(&lval)) {
            ma.error(e.getLoc(), "left bitoffset index is smaller than right index");
            return QualType_Invalid;
        }

        Value width = lval.minus(&rval);
        width.uvalue++;
        if (width.uvalue <= 8) {
            ltype = g_u8;
        } else if (width.uvalue <= 16) {
            ltype = g_u16;
        } else if (width.uvalue <= 32) {
            ltype = g_u32;
        } else {
            ltype = g_u64;
        }

        bo.setWidth(cast<u8>(width.uvalue));
        e.setType(ltype);
    }

    e.combineConstantFlags(bo.getLHS(), bo.getRHS());

    return ltype;
}

func bool Analyser.analyseBitOffsetIndex(Analyser* ma, Expr** e_ptr, QualType baseType, Value* result) {
    BuiltinType* base_bi = baseType.getBuiltinType();

    QualType qt = ma.analyseExpr(e_ptr, true, RHS);
    if (qt.isInvalid()) return false;

    Expr* e = *e_ptr; // ignore ImplicitCast

    QualType canon = qt.getCanonicalType();
    BuiltinType* bi = canon.getBuiltinType();
    if (!canon.isBuiltinType() || !bi.isInteger()) {
        ma.error(e.getLoc(), "index of bitoffset has non-integer type '%s'", qt.diagName());
        return false;
    }

    // TODO only allow CTV expressions
    if (!e.isCtv()) return false;

    Value val = ctv_analyser.get_value(e);
    if (val.isNegative()) {
        ma.errorRange(e.getLoc(), e.getRange(), "bitoffset index value '%s' is negative", val.str());
        return false;
    }

    if (val.ugt(base_bi.getWidth() - 1)) {
        ma.errorRange(e.getLoc(), e.getRange(), "bitoffset index value '%s' too large for type '%s'", val.str(), baseType.diagName());
        return false;
    }

    *result = val;

    return true;
}

func void Analyser.memberError(Analyser* ma, u32 name_idx, SrcLoc loc, StructTypeDecl* s) {
    ma.error(loc, "no member named '%s' in %s '%s'",
        idx2name(name_idx),
        s.isStruct() ? "struct" : "union",
        s.asDecl().getFullName());
}

// TODO move to AnalyserUtils
func Decl* Analyser.findStructMember(Analyser* ma, StructTypeDecl* s, u32 name_idx, SrcLoc loc, bool allow_funcs) {
    Decl* d = s.findAny(name_idx);
    if (!d || (!allow_funcs && d.isFunction())) {
        ma.memberError(name_idx, loc, s);
        return nil;
    }

    return d;
}

// TODO move to AnalyserUtils
func QualType getPointerFromArray(ast_builder.Builder* builder, QualType q) {
    // Dont get canonical
    const ArrayType* a = cast<ArrayType*>(q.getTypeOrNil());
    QualType elem = a.getElemType();
    QualType res = builder.actOnPointerType(elem);
    return res;
}


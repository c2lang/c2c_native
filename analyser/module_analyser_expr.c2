/* Copyright 2022 Bas van den Berg
*/

module module_analyser;

import ast local;

//import stdio; // TEMP

func QualType ModuleAnalyser.analyseExpr(ModuleAnalyser* ma, Expr** e_ptr, bool need_rvalue) {
    QualType result = ma.analyseExprInner(e_ptr);
    if (result.isInvalid()) return result;

    Expr* e = *e_ptr;
    e.setType(result);

    if (need_rvalue && e.isLValue()) {
        QualType qt = e.getType();

        if (qt.isArrayType()) {
            QualType ptr_type; // = // usegetPointerFromArray(Context, Q);
            ma.builder.insertImplicitCast(ImplicitCastKind.ArrayToPointerDecay, e_ptr, ptr_type);
        } else {
            ma.builder.insertImplicitCast(ImplicitCastKind.LValueToRValue, e_ptr, qt);
        }
    }

    return result;
}

func QualType ModuleAnalyser.analyseExprInner(ModuleAnalyser* ma, Expr** e_ptr) {
    assert(e_ptr);
    Expr* e = *e_ptr;

    switch (e.getKind()) {
    case IntegerLiteral:
        // TODO determine kind based on value, for now just return u32
        return g_u32;
    case BooleanLiteral:
        return g_bool;
    case CharLiteral:
        return g_i8;
    case StringLiteral:
        // char* (const?)
        break;
    case Nil:
        // void*
        break;
    case Identifier:
        Decl* d = ma.analyseIdentifier(e_ptr);
        if (!d) break;
        // TODO
        return d.getType();
    case Type:
        break;
    case Call:
        return g_void; // to get CTC check in analyseInitExpr
    case InitList:
        assert(0);
        break;
    case FieldDesignatedInit:
        assert(0);
        break;
    case ArrayDesignatedInit:
        assert(0);
        break;
    case BinaryOperator:
        return ma.analyseBinaryOperator(e_ptr);
    case UnaryOperator:
        return ma.analyseUnaryOperator(e_ptr);
    case ConditionalOperator:
        break;
    case Builtin:
        return ma.analyseBuiltin(e_ptr);
    case ArraySubscript:
        break;
    case Member:
        return ma.analyseMemberExpr(e_ptr);
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        QualType qt = ma.analyseExpr(p.getInner2(), false);
        e.copyConstantFlags(p.getInner());
        return qt;
    case BitOffset:
        break;
    case ExplicitCast:
        break;
    case ImplicitCast:
        break;
    }
    return QualType.init0();
}

func Decl* ModuleAnalyser.analyseIdentifier(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    IdentifierExpr* i = cast<IdentifierExpr*>(e);
    //stdio.printf("FIND %s (%u) idx %u\n", i.getName(), i.getNameIdx(), ma.checkIndex);
    Decl* d = ma.scope.find(i.getNameIdx(), e.getLoc());
    //stdio.printf("D  %p\n", d);
    if (!d) return nil;

    if (!d.isChecked()) {
        ma.analyseGlobalDecl(d);
        // TODO need result
    }

    QualType qt = d.getType();
    assert(qt.isValid());
    e.setType(qt);
    i.setDecl(d);
    d.setUsed();

    IdentifierKind kind = IdentifierKind.Unresolved;
    switch (d.getKind()) {
    case Function:
        e.setCtc();
        e.setRValue();
        ma.builder.insertImplicitCast(ImplicitCastKind.FunctionToPointerDecay, e_ptr, d.getType());
        const FunctionDecl* fd = cast<FunctionDecl*>(d);
        if (fd.hasPrefix()) kind = IdentifierKind.StructFunction;
        else kind = IdentifierKind.Function;
        break;
    case Import:
        break;
    case StructType:
        e.setRValue();
        kind = IdentifierKind.Type;
        break;
    case EnumType:
        e.setCtc();
        e.setRValue();
        kind = IdentifierKind.Type;
        break;
    case EnumConstant:
        e.setCtc();
        e.setCtv();
        kind = IdentifierKind.EnumConstant;
        break;
    case FunctionType:
        e.setCtc();
        kind = IdentifierKind.Type;
        break;
    case AliasType:
        kind = IdentifierKind.Type;
        break;
    case Var:
        VarDecl* vd = cast<VarDecl*>(d);
        QualType t = vd.asDecl().getType();
        e.setCtc();
        const Expr* init_ = vd.getInit();
        if (init_ && t.isConst() && init_.isCtv()) e.setCtv();
        switch (vd.getKind()) {
        case GlobalVar: fallthrough;
        case LocalVar:  fallthrough;
        case FunctionParam:
            kind = IdentifierKind.Var;
            break;
        case StructMember:
            kind = IdentifierKind.StructMember;
            break;
        }
        break;
    case StaticAssert:
        break;
    }
    i.setKind(kind);

    if (e.isCtv()) e.setRValue();

    return d;
}

func QualType ModuleAnalyser.analyseBinaryOperator(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    BinaryOperator* b = cast<BinaryOperator*>(e);
    QualType ltype = ma.analyseExpr(b.getLHS2(), true);
    if (ltype.isInvalid()) return QualType.init0();

    QualType rtype = ma.analyseExpr(b.getRHS2(), true);
    if (rtype.isInvalid()) return QualType.init0();

    Expr* lhs = b.getLHS();
    Expr* rhs = b.getRHS();

    // TODO check if either type is void, give error

    QualType result = QualType.init0();
    switch (b.getKind()) {
    case Multiply:  fallthrough;
    case Divide:    fallthrough;
    case Reminder:  fallthrough;
    case Add:       fallthrough;
    case Subtract:
        break;
    case ShiftLeft: fallthrough;
    case ShiftRight:
        result = ltype;
        break;
    case LessThan:      fallthrough;
    case GreaterThan:   fallthrough;
    case LessEqual:     fallthrough;
    case GreaterEqual:  fallthrough;
    case Equal:         fallthrough;
    case NotEqual:
        result = g_bool;
        break;
    case And:       fallthrough;
    case Xor:       fallthrough;
    case Or:
        result = ltype;
        break;
    case LAnd:      fallthrough;
    case LOr:
        result = g_bool;
        break;
    case Assign:    fallthrough;
    case MulAssign: fallthrough;
    case DivAssign: fallthrough;
    case RemAssign: fallthrough;
    case AddAssign: fallthrough;
    case SubASsign: fallthrough;
    case ShlAssign: fallthrough;
    case ShrASsign: fallthrough;
    case AndAssign: fallthrough;
    case XorAssign: fallthrough;
    case OrAssign:
        assert(0);
        break;
    }

    e.combineConstantFlags(lhs, rhs);

    return result;
}

func IdentifierKind getInnerExprAddressOf(Expr* e) {
    // TODO change return type to IdentifierKind, use Unresolved for not-IdentifiersExpr/MemberExpr

    switch (e.getKind()) {
    case IntegerLiteral:    fallthrough;
    case BooleanLiteral:    fallthrough;
    case CharLiteral:       fallthrough;
    case StringLiteral:     fallthrough;
    case Nil:               fallthrough;
    case Identifier:        fallthrough;
    case Type:              fallthrough;
    case Call:              fallthrough;
    case InitList:          fallthrough;
    case FieldDesignatedInit:   fallthrough;
    case ArrayDesignatedInit:
        break;
    case BinaryOperator:
        // TODO
        break;
    case UnaryOperator:
        // TODO
        break;
    case ConditionalOperator:
        // TODO
        break;
    case Builtin:
        break;
    case ArraySubscript:
        ArraySubscriptExpr* a = cast<ArraySubscriptExpr*>(e);
        return getInnerExprAddressOf(a.getBase());
    case Member:
        MemberExpr* m = cast<MemberExpr*>(e);
        // TODO MemberExpr doesn't have an IdentifierExpr anymore!!
        // Caller only needs RefKind, so return that from this function?
        return m.getKind();
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        return getInnerExprAddressOf(p.getInner());
    case BitOffset:
        return IdentifierKind.Unresolved;
    case ExplicitCast:
        ExplicitCastExpr* c = cast<ExplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    case ImplicitCast:
        ImplicitCastExpr* c = cast<ImplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    }

    return IdentifierKind.Unresolved;
}

func bool ModuleAnalyser.getIdentifierKind(ModuleAnalyser* ma, Expr* e) {
    IdentifierKind kind = getInnerExprAddressOf(e);
    const char* arg = "";
    switch (kind) {
    case Unresolved:
        QualType qt = e.getType();
        ma.diags.report(e.getLoc(), "cannot take the address of an rvalue of type %s", qt.diagName());
        return false;
    case Module:
        arg = "a module";
        break;
    case Function:
        // NOTE: C2 does not allow address of function like C
        arg = "a function";
        break;
    case Type:
        arg = "a type";
        break;
    case Var:
        return true;
    case EnumConstant:
        arg = "an enum constant";
        break;
    case StructMember:
        return true;
    case StructFunction:
        arg = "a function";
        break;
    case Label:
        arg = "a label";
        break;
    }
    ma.diags.report(e.getLoc(), "cannot takes the address of ", arg);
    return false;
}

func QualType ModuleAnalyser.analyseUnaryOperator(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    UnaryOperator* u = cast<UnaryOperator*>(e);

    bool need_rvalue = true;

    // TODO need rvalue stuff
    switch (u.getKind()) {
    case PostInc:   fallthrough;
    case PostDec:   fallthrough;
    case PreInc:    fallthrough;
    case PreDec:
        ma.diags.report(e.getLoc(), "initializer is not a compile-time constant");
        return QualType.init0();
    case AddrOf:
        need_rvalue = false;
        break;
    case Deref:     fallthrough;
    case Minus:     fallthrough;
    case Not:       fallthrough;
    case LNot:
        break;
    }

    QualType t = ma.analyseExpr(u.getInner2(), need_rvalue);
    if (t.isInvalid()) return QualType.init0();

    e = *e_ptr; // re-read in case of ImplicitCast insertions
    Expr* inner = u.getInner();

    if (t.isVoidType()) {
        ma.diags.report(e.getLoc(), "invalid argument type %s to unary expression", "'void'");
        return QualType.init0();
    }

    switch (u.getKind()) {
    case PostInc:   fallthrough;
    case PostDec:   fallthrough;
    case PreInc:    fallthrough;
    case PreDec:
        assert(0);
        return QualType.init0();
    case AddrOf:
        if (!ma.getIdentifierKind(inner)) return QualType.init0();
        t = ma.builder.actOnPointerType(t.getCanonicalType(), 0);
        e.setCtc();
        break;
    case Deref:
        if (!t.isPointerType()) {
            ma.diags.report(e.getLoc(), "indirection requires pointer operand (%s invalid)", t.diagName());
            return QualType.init0();
        } else {
            t = t.getCanonicalType();
            const PointerType* p = t.getPointerType();
            return p.getInner();
        }
        break;
    case Minus:     fallthrough;
    case Not:
        e.copyConstantFlags(inner);
        // t = UsualUnaryConversions(inner);
        break;
    case LNot:
        e.copyConstantFlags(inner);
        return g_bool;
    }

    return t;
}

func QualType ModuleAnalyser.analyseMemberExpr(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    MemberExpr* m =cast<MemberExpr*>(e);

    QualType lhs = ma.analyseExpr(m.getBase2(), false);
    if (lhs.isInvalid()) return lhs;

    // we dont know what we're looking at here, it could be:
    // mod.Type
    // mod.var
    // mod.func
    // var<Type=struct>.member
    // var<Type=struct>.struct_function
    // var[index].member
    // var.member (= error)
    // Type.struct_function
    // Enum.Constant (eg. Color.Red)

    u32 rhs_idx = m.getNameIdx();

    // TODO check rest
    // TODO convert to d.getKind(), not type (see analyseIdentifier)
    Type* t = lhs.getType();
    switch(t.getKind()) {
    case Builtin:
        // cannot happen?
        break;
    case Pointer:
        // TODO can happen?
        break;
    case Array:
        // TODO can happen?
        break;
    case Ref:
        // IdentifierKind.Var or IdentifierKind.StructMember or IdentifierKind.EnumConstant
        break;
    case Struct:
        // TODO
        break;
    case Enum:
        EnumType* et = cast<EnumType*>(t);
        EnumTypeDecl* etd = et.getDecl();
        Decl* d = cast<Decl*>(etd);
        d.setUsed();
        EnumConstantDecl* ecd = etd.findConstant(rhs_idx);
        if (!ecd) {
            ma.diags.report(e.getLoc(), "enum %s has no constant %s", d.getName(), m.getName());
            return QualType.init0();
        }
        // TODO do self-initialization checking

        Decl* cd = cast<Decl*>(ecd);
        cd.setUsed();
        m.setDecl(cd);
        // TODO set ref kind (like IdentifierExpr)
        e.setCtv();
        e.setCtc();
        QualType rhs = cd.getType();
        e.setType(rhs);


        return rhs;
    case Function:
        // TODO
        break;
    case Module:
        // TODO
        break;
    }
    // TODO check for ModuleType

    // TODO check for EnumType

    // TODO var/struct


    return QualType.init0();
}

func QualType ModuleAnalyser.analyseBuiltin(ModuleAnalyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    BuiltinExpr* b = cast<BuiltinExpr*>(e);
    switch (b.getKind()) {
    case Sizeof:
        return ma.analyseSizeof(b);
    case Elemsof:
        break;
    case EnumMin:
        break;
    case EnumMax:
        break;
    case OffsetOf:
        break;
    case ToContainer:
        break;
    }

    return QualType.init0();
}

func QualType ModuleAnalyser.analyseSizeof(ModuleAnalyser* ma, BuiltinExpr* e) {
    Expr* inner = e.getInner();
    assert(inner);
    // TODO switch
    if (inner.getKind() == ExprKind.Type) {
        TypeExpr* te = cast<TypeExpr*>(inner);
        QualType qt = te.getType();
        // TODO
        e.setValue(4);
    }
    return QualType.init0();
}


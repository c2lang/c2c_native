/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module module_analyser;

import ast local;
import ctv_analyser;
import src_loc local;

import stdlib;
import string;


type ArrayEntry struct {
    u32 index;
    SrcLoc loc;
}

type ArrayChecker struct {
    ArrayEntry* entries;
    u32 count;
    u32 capacity;
    u32 max;
}

func ArrayChecker ArrayChecker.create(u32 capacity) {
    assert(capacity != 0);
    ArrayChecker c;
    c.count = 0;
    c.capacity = capacity;
    c.max = 0;
    c.entries = stdlib.malloc(capacity * sizeof(ArrayEntry));
    return c;
}

func void ArrayChecker.free(ArrayChecker* c) {
    stdlib.free(c.entries);
}

func void ArrayChecker.add(ArrayChecker* c, u32 index, SrcLoc loc) {
    if (c.count >= c.capacity) {
        c.capacity *= 2;
        ArrayEntry* entries = stdlib.malloc(c.capacity * sizeof(ArrayEntry));
        string.memcpy(entries, c.entries, c.count * sizeof(ArrayEntry));
        stdlib.free(c.entries);
        c.entries = entries;
    }
    ArrayEntry* entry = &c.entries[c.count];
    entry.index = index;
    entry.loc = loc;
    c.count++;
}

func SrcLoc ArrayChecker.find(ArrayChecker* c, u32 index) {
    for (u32 i=0; i<c.count; i++) {
        if (c.entries[i].index == index) return c.entries[i].loc;
    }
    return 0;
}


func bool Analyser.analyseInitExpr(Analyser* ma, Expr** e_ptr, QualType expectedType) {
    Expr* e = *e_ptr;

    if (e.isInitList()) {
        return ma.analyseInitListExpr(cast<InitListExpr*>(e), expectedType);
    }

    //if (e.isArrayDesignatedInit()) ..
    // TODO DesignatedInitExpr

    if (e.isStringLiteral()) {
        // could be (const) char* x = "text" OR (const) char[] x = "text";
        // check array case for overflow
        // when doing char[] a = "abc" -> string is not an LValue
        // when doing char*  a = "abc" -> string is lvalue (so insert ArrayToPointerDecay)
        ArrayType* at = expectedType.getArrayTypeOrNil();
        if (at) {
            // check that element type is char/int8
            QualType elem = at.getElemType();
            if (elem.getTypeOrNil() != g_char.getTypeOrNil() && elem.getTypeOrNil() != g_i8.getTypeOrNil()) {
                ma.errorRange(e.getLoc(), e.getRange(), "cannot initialize array of '%s' with a string literal", elem.diagName());
                return false;
            }

            QualType st = e.getType();
            ArrayType* at2 = st.getArrayType();
            u32 rhs_len = at2.getSize();
            if (at.hasSize()) {
                u32 lhs_len = at.getSize();
                if (rhs_len > lhs_len) {
                    ma.errorRange(e.getLoc(), e.getRange(), "initializer-string for char array is too long");
                    return false;
                }
            } else {
                at.setSize(rhs_len);
            }
            e.setRValue();
        } else {
            // need to add ArrayToPointerDecay (otherwise checker can get arrays)
            QualType qt = ma.analyseExpr(e_ptr, true, RHS);
            e = *e_ptr;
            if (!ma.checker.check(expectedType, e.getType(), e_ptr, e.getLoc())) return false;
        }
        return true;
    }

    QualType res = ma.analyseExpr(e_ptr, true, RHS);
    if (res.isInvalid()) return false;
    e = *e_ptr; // re-read since ImplicitCasts could have been inserted

    // TODO needed?
    //expectedType.clearQuals(); // rhs is not const/volatile
    //e.setType(expectedType);

    if (e.isCtv()) {
        return ctv_analyser.check(ma.diags, expectedType, e);
    }

    if (!ma.curFunction && !e.isCtv()) {
        if (!e.isCtc()) {
            ma.errorRange(e.getLoc(), e.getRange(), "initializer element is not a compile-time constant");
            return false;
        }

        if (expectedType.needsCtvInit()) {
            ma.errorRange(e.getLoc(), e.getRange(), "initializer element is not a compile-time value");
            return false;
        }
    }

    return ma.checker.check(expectedType, res, e_ptr, e.getLoc());
}

func bool Analyser.analyseInitListExpr(Analyser* ma, InitListExpr* ile, QualType expectedType) {
    const Type* t = expectedType.getTypeOrNil();
    if (t.isArrayType()) {
        return ma.analyseInitListArray(ile, expectedType);
    }

    if (t.isStructType()) {
        return ma.analyseInitListStruct(ile, expectedType);
    }

    Expr* e = cast<Expr*>(ile);
    ma.error(e.getLoc(), "cannot initialize variable of type '%s' with initializer list", expectedType.diagName());
    return false;
}

func bool Analyser.analyseInitListArray(Analyser* ma, InitListExpr* ile, QualType expectedType) {
    Expr* e = cast<Expr*>(ile);
    u32 numValues = ile.getNumValues();
    Expr** values = ile.getValues();

    expectedType.clearQuals();
    ArrayType* at = expectedType.getArrayType();
    QualType et = at.getElemType();
    et.clearQuals();

    bool ok = true;
    bool ctc = true;
    bool have_designators = false;
    u32 current_index = 0;

    for (u32 i=0; i<numValues; i++) {
        Expr* value = values[i];

        if (value.isFieldDesignatedInit()) {
            ma.errorRange(value.getLoc(), value.getRange(), "field designator cannot initialize an array");
            ok = false;
            continue;
        }
        if (value.isArrayDesignatedInit()) {
            ok |= ma.analyseArrayDesignatedInit(value, et);
            have_designators = true;
            continue;
        }

        ok |= ma.analyseInitExpr(&values[i], et);
        ctc |= values[i].isCtc();
    }

    if (ctc) e.setCtc();
    if (!ok) return false;

    if (have_designators) {
        i32 array_size = -1; // will be determined by init-expr
        if (at.hasSize()) array_size = cast<i32>(at.getSize());

        ArrayChecker checker = ArrayChecker.create(numValues);
        ok = ma.checkArrayDesignators(ile, &array_size, &checker);
        checker.free();

        if (!at.hasSize()) at.setSize(cast<u32>(array_size));

    } else {
        if (at.hasSize()) {
            u32 arraySize = at.getSize();
            if (current_index > arraySize) {
                ma.error(values[arraySize].getLoc(), "excess elements in array initializer");
                return false;
            }
        } else {
            at.setSize(numValues);
        }
    }

    e.setType(expectedType);
    return ok;
}

func bool Analyser.checkArrayDesignators(Analyser* ma, InitListExpr* ile, i32* size, ArrayChecker* checker) {
    u32 numValues = ile.getNumValues();
    Expr** values = ile.getValues();

    i32 max_index = 0;
    i32 current_index = -1;
    for (u32 i=0; i<numValues; i++) {
        SrcLoc loc;
        Expr* value = values[i];
        if (value.isArrayDesignatedInit()) {
            ArrayDesignatedInitExpr* ad = cast<ArrayDesignatedInitExpr*>(value);
            Expr* desig = ad.getDesignator();
            loc = desig.getLoc();
            Value idx = ctv_analyser.get_value(desig);
            if (idx.isNegative()) {
                ma.error(loc, "array designator value '%s' is negative", idx.str());
                return false;
            }
            current_index = cast<i32>(idx.uvalue);
            if (*size != -1 && current_index >= *size) {
                ma.error(loc, "array designator index (%u) exceeds array bounds (%u)", current_index, *size);
                return false;
            }
        } else {
            loc = value.getLoc();
            current_index++;
        }
        if (*size != -1 && current_index >= *size) {
            ma.error(value.getLoc(), "excess elements in array initializer");
            return false;
        }

        // check for duplicate entries
        SrcLoc duplicate = checker.find(cast<u32>(current_index));
        if (duplicate) {
            ma.error(loc, "duplicate initialization of array index");
            ma.note(duplicate, "previous initialization is here");

        } else {
            checker.add(cast<u32>(current_index), loc);
        }

        if (current_index > max_index) max_index = current_index;
    }
    if (*size == -1) *size = max_index + 1;
    return true;
}

func bool Analyser.analyseInitListStruct(Analyser* ma, InitListExpr* ile, QualType expectedType) {
    // Note: expectedType is StructType
    Expr* e = cast<Expr*>(ile);
    u32 numValues = ile.getNumValues();
    Expr** values = ile.getValues();

    StructType* st = expectedType.getStructType();
    StructTypeDecl* std = st.getDecl();

    // just init all values to 0
    if (numValues == 0) {
        e.setType(expectedType);
        return true;
    }

    // only allow none or all fields to use Designators
    const bool haveDesignators = (values[0].isFieldDesignatedInit());

    if (!haveDesignators && std.isUnion()) {
        ma.error(values[0].getLoc(), "union member initializer needs field designator");
        return false;
    }

    const u32 num_members = std.getNumMembers();
    Decl** members = std.getMembers();

    for (u32 i=0; i<numValues; i++) {
        Expr* value = values[i];
        if (i >= num_members) {
            ma.error(value.getLoc(), "excess initializer elements in struct");
            return false;
        }
        if (value.isArrayDesignatedInit()) {
            ma.error(value.getLoc(), "array designator cannot initialize non-array type '%s'", expectedType.diagName());

            return false;
        }
        bool is_designator = value.isFieldDesignatedInit();
        if (haveDesignators != is_designator) {
            ma.error(value.getLoc(), "mixing field designator with non-field designators");
            return false;
        }
        if (is_designator) {
            FieldDesignatedInitExpr* fdi = cast<FieldDesignatedInitExpr*>(value);
            //u32 field = fdi.getField();
            //Expr** init_ = fdi.getInit2();
            Decl* member = ma.findStructMember(std, fdi.getField(), value.getLoc(), false);
            if (!member) return false;
            // TODO check for duplicates
            member.setUsed();
            // TODO allow substruct init by name?
            bool ok = ma.analyseInitExpr(fdi.getInit2(), member.getType());
            if (!ok) return false;
            value.setType(fdi.getInit().getType());
        } else {
            members[i].setUsed();
            bool ok = ma.analyseInitExpr(&values[i], members[i].getType());
            if (!ok) return false;
        }
    }

    expectedType.clearQuals();
    e.setType(expectedType);
    return true;
}


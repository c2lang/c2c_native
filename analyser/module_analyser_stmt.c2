module module_analyser;

import ast local;
import diagnostics;
import scope;

import stdio;

func void Analyser.analyseFunctionBody(Analyser* ma, FunctionDecl* fd) {
    CompoundStmt* body = fd.getBody();
    // TODO assert (should not be called for interface components)
    if (!body) return;

    ma.scope = fd.asDecl().getAST().getPtr();

    ma.scope.reset();
    ma.scope.enter(scope.Function | scope.Decl);
    u32 num_params = fd.getNumParams();
    VarDecl** params = fd.getParams();
    for (u32 i=0; i<num_params; i++) {
        Decl* d = cast<Decl*>(params[i]);
        bool error = ma.scope.add(d);
        if (error) return;   // no need to set ma.has_error
    }

    ma.curFunction = fd;
    ma.has_error = false;
    // TODO use JumpBuf to return from error?
    ma.analyseCompoundStmt(body);

    ma.scope.exit();
    ma.curFunction = nil;
}

func void Analyser.analyseStmt(Analyser* ma, Stmt* s) {
    switch (s.getKind()) {
    case Return:
        ma.analyseReturnStmt(s);
        break;
    case Expr:
        // TODO need a different set, since this one uses the Stack of Globals
        ma.analyseExpr(cast<Expr**>(&s), false);
        break;
    case If:
        ma.analyseIfStmt(s);
        break;
    case While:
        ma.analyseWhileStmt(s);
        break;
    case Do:
        ma.analyseDoStmt(s);
        break;
    case For:
        ma.analyseForStmt(s);
        break;
    case Switch:
        ma.analyseSwitchStmt(s);
        break;
    case Case:
        assert(0);
        break;
    case Default:
        assert(0);
        break;
    case Break:
        ma.analyseBreakStmt(s);
        break;
    case Continue:
        ma.analyseContinueStmt(s);
        break;
    case Fallthrough:
        ma.analyseFallthroughStmt(s);
        break;
    case Label:
        break;
    case Goto:
        break;
    case Compound:
        ma.scope.enter(scope.Decl);
        ma.analyseCompoundStmt(cast<CompoundStmt*>(s));
        ma.scope.exit();
        break;
    case Decl:
        ma.analyseDeclStmt(s);
        break;
    case Assert:
        ma.analyseAssertStmt(s);
        break;
    }
}

func void Analyser.analyseSwitchStmt(Analyser* ma, Stmt* s) {
    SwitchStmt* sw = cast<SwitchStmt*>(s);
    // TODO
}

func void Analyser.analyseBreakStmt(Analyser* ma, Stmt* s) {
    if (!ma.scope.allowBreak()) {
        BreakStmt* b = cast<BreakStmt*>(s);
        ma.error(b.getLoc(), "'break' statement not in loop or switch statement");
    }
}

func void Analyser.analyseContinueStmt(Analyser* ma, Stmt* s) {
    if (!ma.scope.allowContinue()) {
        ContinueStmt* c = cast<ContinueStmt*>(s);
        ma.error(c.getLoc(), "'continue' statement not in loop statement");
    }
}

func void Analyser.analyseFallthroughStmt(Analyser* ma, Stmt* s) {
    FallthroughStmt* f = cast<FallthroughStmt*>(s);
    // TODO
}

func void Analyser.analyseCompoundStmt(Analyser* ma, CompoundStmt* c) {
    u32 count = c.getCount();
    Stmt** stmts = c.getStmts();
    for (u32 i=0; i<count; i++) {
        Stmt* s = stmts[i];
        ma.analyseStmt(s);
        if (ma.has_error) break;
    }
}

func void Analyser.analyseCondition(Analyser* ma, Stmt** s_ptr) {
    Stmt* s = *s_ptr;
    if (s.getKind() == StmtKind.Decl) {
        ma.analyseDeclStmt(s);
    } else {
        assert(s.getKind() == StmtKind.Expr);
        Expr* e = cast<Expr*>(s);
        // Note: cannot insert ImplicitCastExpr here!
        QualType qt = ma.analyseExpr(&e, true);
        if (qt.isInvalid()) return;
        ma.checker.check(g_bool, qt, cast<Expr**>(s_ptr), e.getLoc());
    }
}

func void Analyser.analyseIfStmt(Analyser* ma, Stmt* s) {
    IfStmt* i = cast<IfStmt*>(s);
    ma.scope.enter(scope.Decl);
    ma.analyseCondition(i.getCond2());

    ma.scope.enter(scope.Decl);
    ma.analyseStmt(i.getThen());
    ma.scope.exit();

    Stmt* else_ = i.getElse();
    if (else_) {
        ma.scope.enter(scope.Decl);
        ma.analyseStmt(else_);
        ma.scope.exit();
    }

    ma.scope.exit();
}

func void Analyser.analyseForStmt(Analyser* ma, Stmt* s) {
    ForStmt* f = cast<ForStmt*>(s);
    // TODO
}

func void Analyser.analyseWhileStmt(Analyser* ma, Stmt* s) {
    WhileStmt* w = cast<WhileStmt*>(s);
    ma.scope.enter(scope.Decl);
    ma.analyseStmt(w.getCond());
    // TODO test conversion to bool?
    ma.scope.enter(scope.Break | scope.Continue | scope.Decl | scope.Control);
    ma.analyseStmt(w.getBody());
    ma.scope.exit();
    ma.scope.exit();
}

func void Analyser.analyseDoStmt(Analyser* ma, Stmt* s) {
    DoStmt* d = cast<DoStmt*>(s);
    ma.scope.enter(scope.Break | scope.Continue | scope.Decl);
    ma.analyseStmt(d.getBody());
    ma.scope.exit();
    ma.analyseStmt(d.getCond());
}

func void Analyser.analyseDeclStmt(Analyser* ma, Stmt* s) {
    DeclStmt* ds = cast<DeclStmt*>(s);
    VarDecl* vd = ds.getDecl();
    Decl* d = cast<Decl*>(vd);

    // Note: d.getType() is 0 here! (use refType)
    TypeRef* ref = vd.getTypeRef();

    QualType res = ma.analyseTypeRef(ref);
    if (res.isInvalid()) return;
    d.setType(res);

    // TODO opaque

    ma.checkName(d, false);

    Expr** initExpr = vd.getInit2();
    if (initExpr) {
        ma.analyseInitExpr(initExpr, res);
    } else {
        if (res.isConstant()) {
            ma.error(d.getLoc(), "constant variable %s must be initialized", d.getName());
            return;
        }
        const ArrayType* at = res.getArrayTypeOrNil();
        if (at && !at.hasSize()) {
            ma.error(d.getLoc(), "array-type variable %s needs an explicit size or an initializer", d.getName());
            return;
        }
    }

    d.setChecked();
    ma.has_error = ma.scope.add(d);
}

func void Analyser.analyseAssertStmt(Analyser* ma, Stmt* s) {
    AssertStmt* a = cast<AssertStmt*>(s);
    QualType qt = ma.analyseExpr(a.getInner2(), true);
    if (qt.isInvalid()) return;
    Expr* inner = a.getInner();
    ma.checker.check(g_bool, qt, a.getInner2(), inner.getLoc());
}

func void Analyser.analyseReturnStmt(Analyser* ma, Stmt* s) {
    ReturnStmt* r = cast<ReturnStmt*>(s);

    Expr** arg = r.getValue2();

    if (ma.curFunction.hasReturn()) {
        if (!arg) {
            Expr* e = r.getValue();
            // +6 is skip 'return', to end up at ;
            ma.error(r.getLoc()+6, "non-void function %s should return a value", ma.curFunction.asDecl().getName());
            return;
        }
    } else {
        if (arg) {
            Expr* e = r.getValue();
            ma.error(e.getLoc(), "void function %s should not return a value", ma.curFunction.asDecl().getName());
            return;
        }
    }
    if (arg) {
        QualType qt = ma.analyseExpr(arg, true);
        if (qt.isInvalid()) return;

        ma.checker.check(ma.curFunction.getRType(), qt, arg, (*arg).getLoc());
    }
}


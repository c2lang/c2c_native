module module_analyser;

import ast local;
import diagnostics;

import stdio;

func void Analyser.analyseFunctionBody(Analyser* ma, FunctionDecl* d) {
    ma.scope = d.asDecl().getAST().getPtr();
    // TODO add function params to scope

    ma.curFunction = d;
    CompoundStmt* body = d.getBody();
    // TODO assert (should not be called for interface components)
    if (!body) return;

    // TODO use JumpBuf to return from error?
    ma.analyseCompoundStmt(body);
    ma.curFunction = nil;
}

func void Analyser.analyseCompoundStmt(Analyser* ma, CompoundStmt* c) {
    u32 count = c.getCount();
    Stmt** stmts = c.getStmts();
    for (u32 i=0; i<count; i++) {
        Stmt* s = stmts[i];
        switch (s.getKind()) {
        case Return:
            //ma.analyseReturnStmt(s);
            break;
        case Expr:
            // TODO need a different set, since this one uses the Stack of Globals
            //ma.analyseExpr(cast<Expr**>(&s), false);
            break;
        case If:
            break;
        case While:
            break;
        case Do:
            break;
        case For:
            break;
        case Switch:
            break;
        case Case:
            break;
        case Default:
            break;
        case Break:
            break;
        case Continue:
            break;
        case Fallthrough:
            break;
        case Label:
            break;
        case Goto:
            break;
        case Compound:
            break;
        case Decl:
            ma.analyseDeclStmt(s);
            break;
        case Assert:
            break;
        }
    }
}

func void Analyser.analyseDeclStmt(Analyser* ma, Stmt* s) {
    DeclStmt* ds = cast<DeclStmt*>(s);
    VarDecl* vd = ds.getDecl();
    Decl* d = cast<Decl*>(vd);

    // Note: d.getType() is 0 here! (use refType)
    TypeRef* ref = vd.getTypeRef();

    QualType res = ma.analyseTypeRef(ref);
    if (res.isInvalid()) return;
    d.setType(res);

    // TODO opaque, ArrayType without size needs init, etc

    ma.checkName(d, false);

    Expr** initExpr = vd.getInit2();
    if (initExpr) {
        // NOT YET
        //ma.analyseInitExpr(initExpr, res);
    } else {
        if (res.isConstant()) {
            ma.diags.report(d.getLoc(), "constant variable %s must be initialized", d.getName());
            return;
        }
    }

    // Note: no d.setChecked() for locals?
    bool error = ma.scope.add(d.getNameIdx(), d);
    if (error) return;  // use JmpBuf?
}

func void Analyser.analyseReturnStmt(Analyser* ma, Stmt* s) {
    ReturnStmt* r = cast<ReturnStmt*>(s);

    Expr** arg = r.getValue2();

    if (arg) {
        QualType qt = ma.analyseExpr(arg, true);
        if (qt.isInvalid()) return;
    }

    if (ma.curFunction.hasReturn()) {
        if (!arg) {
            Expr* e = r.getValue();
            // +6 is skip 'return', to end up at ;
            ma.diags.report(r.getLoc()+6, "non-void function %s should return a value", ma.curFunction.asDecl().getName());
        }
    } else {
        if (arg) {
            Expr* e = r.getValue();
            ma.diags.report(e.getLoc(), "void function %s should not return a value", ma.curFunction.asDecl().getName());
        }
    }
}


module module_analyser;

import ast local;
import diagnostics;
import scope;

import stdio;

func void Analyser.analyseFunctionBody(Analyser* ma, FunctionDecl* fd) {
    CompoundStmt* body = fd.getBody();
    // TODO assert (should not be called for interface components)
    if (!body) return;

    ma.scope = fd.asDecl().getAST().getPtr();
    // TODO reset scope? (after error of prev)

    u32 num_params = fd.getNumParams();
    VarDecl** params = fd.getParams();
    for (u32 i=0; i<num_params; i++) {
        Decl* d = cast<Decl*>(params[i]);
        bool error = ma.scope.add(d);
        if (error) return;   // no need to set ma.has_error
    }

    ma.curFunction = fd;
    ma.has_error = false;
    // TODO use JumpBuf to return from error?
    ma.analyseCompoundStmt(body);
    ma.curFunction = nil;
}

func void Analyser.analyseStmt(Analyser* ma, Stmt* s) {
    switch (s.getKind()) {
    case Return:
        ma.analyseReturnStmt(s);
        break;
    case Expr:
        // TODO need a different set, since this one uses the Stack of Globals
        ma.analyseExpr(cast<Expr**>(&s), false);
        break;
    case If:
        break;
    case While:
        ma.analyseWhileStmt(s);
        break;
    case Do:
        ma.analyseDoStmt(s);
        break;
    case For:
        break;
    case Switch:
        break;
    case Case:
        break;
    case Default:
        break;
    case Break:
        break;
    case Continue:
        break;
    case Fallthrough:
        break;
    case Label:
        break;
    case Goto:
        break;
    case Compound:
        ma.analyseCompoundStmt(cast<CompoundStmt*>(s));
        break;
    case Decl:
        ma.analyseDeclStmt(s);
        break;
    case Assert:
        break;
    }
}

func void Analyser.analyseCompoundStmt(Analyser* ma, CompoundStmt* c) {
    u32 count = c.getCount();
    Stmt** stmts = c.getStmts();
    for (u32 i=0; i<count; i++) {
        Stmt* s = stmts[i];
        ma.analyseStmt(s);
        if (ma.has_error) break;
    }
}

func void Analyser.analyseWhileStmt(Analyser* ma, Stmt* s) {
    WhileStmt* w = cast<WhileStmt*>(s);
    ma.scope.enter(scope.Decl);
    ma.analyseStmt(w.getCond());
    // TODO test conversion to bool?
    ma.scope.enter(scope.Break | scope.Continue | scope.Decl | scope.Control);
    ma.analyseStmt(w.getBody());
    ma.scope.exit();
    ma.scope.exit();
}

func void Analyser.analyseDoStmt(Analyser* ma, Stmt* s) {
    DoStmt* d = cast<DoStmt*>(s);
    ma.scope.enter(scope.Break | scope.Continue | scope.Decl);
    ma.analyseStmt(d.getBody());
    ma.scope.exit();
    ma.analyseStmt(d.getCond());
}

func void Analyser.analyseDeclStmt(Analyser* ma, Stmt* s) {
    DeclStmt* ds = cast<DeclStmt*>(s);
    VarDecl* vd = ds.getDecl();
    Decl* d = cast<Decl*>(vd);

    // Note: d.getType() is 0 here! (use refType)
    TypeRef* ref = vd.getTypeRef();

    QualType res = ma.analyseTypeRef(ref);
    if (res.isInvalid()) return;
    d.setType(res);

    // TODO opaque

    ma.checkName(d, false);

    Expr** initExpr = vd.getInit2();
    if (initExpr) {
        ma.analyseInitExpr(initExpr, res);
    } else {
        if (res.isConstant()) {
            ma.error(d.getLoc(), "constant variable %s must be initialized", d.getName());
            return;
        }
        const ArrayType* at = res.getArrayTypeOrNil();
        if (at && !at.hasSize()) {
            ma.error(d.getLoc(), "array-type variable %s needs an explicit size or an initializer", d.getName());
            return;
        }
    }

    d.setChecked();
    ma.has_error = ma.scope.add(d);
}

func void Analyser.analyseReturnStmt(Analyser* ma, Stmt* s) {
    ReturnStmt* r = cast<ReturnStmt*>(s);

    Expr** arg = r.getValue2();

    if (ma.curFunction.hasReturn()) {
        if (!arg) {
            Expr* e = r.getValue();
            // +6 is skip 'return', to end up at ;
            ma.error(r.getLoc()+6, "non-void function %s should return a value", ma.curFunction.asDecl().getName());
            return;
        }
    } else {
        if (arg) {
            Expr* e = r.getValue();
            ma.error(e.getLoc(), "void function %s should not return a value", ma.curFunction.asDecl().getName());
            return;
        }
    }
    if (arg) {
        QualType qt = ma.analyseExpr(arg, true);
        if (qt.isInvalid()) return;

        ma.checker.check(ma.curFunction.getRType(), qt, *arg);
    }
}


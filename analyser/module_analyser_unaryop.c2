/* Copyright 2022-2024 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module module_analyser;

import ast local;
import src_loc local;

fn VarDecl* getVarDecl(const Expr* e) {
    Decl* d;
    if (e.isIdentifier()) {
        IdentifierExpr* i = cast<IdentifierExpr*>(e);
        d = i.getDecl();
    } else {
        MemberExpr* m = cast<MemberExpr*>(e);
        d = m.getFullDecl();
    }
    if (d.isVariable()) return cast<VarDecl*>(d);
    return nil;
}

fn QualType Analyser.analyseUnaryOperator(Analyser* ma, Expr** e_ptr, u32 side) {
    Expr* e = *e_ptr;
    UnaryOperator* u = cast<UnaryOperator*>(e);

    bool need_rvalue = true;

    // TODO need rvalue stuff
    switch (u.getOpcode()) {
    case PostInc:   fallthrough;
    case PostDec:   fallthrough;
    case PreInc:    fallthrough;
    case PreDec:
        if (!ma.curFunction) {
            ma.errorRange(e.getLoc(), e.getRange(), "initializer element is not a compile-time constant");
            return QualType_Invalid;
        }
        need_rvalue = false;
        side |= LHS;
        break;
    case AddrOf:
        need_rvalue = false;
        side |= LHS;
        break;
    case Deref:     fallthrough;
    case Minus:     fallthrough;
    case Not:       fallthrough;
    case LNot:
        side |= RHS;
        break;
    }

    QualType t = ma.analyseExpr(u.getInner2(), need_rvalue, side);
    if (t.isInvalid()) {
        return QualType_Invalid;
    }

    e = *e_ptr; // re-read in case of ImplicitCast insertions
    Expr* inner = u.getInner();

    if (t.isVoid()) {
        ma.error(e.getLoc(), "invalid argument type '%s' to unary expression", "void");
        return QualType_Invalid;
    }

    switch (u.getOpcode()) {
    case PostInc:
        if (!ma.checkIncrDecr(inner, t, true, e.getLoc())) return QualType_Invalid;
        break;
    case PostDec:
        if (!ma.checkIncrDecr(inner, t, false, e.getLoc())) return QualType_Invalid;
        break;
    case PreInc:
        if (!ma.checkIncrDecr(inner, t, true, e.getLoc())) return QualType_Invalid;
        break;
    case PreDec:
        if (!ma.checkIncrDecr(inner, t, false, e.getLoc())) return QualType_Invalid;
        break;
    case AddrOf:
/*
        // faster, but less verbose
        if (!inner.isLValue()) {
            ma.error(inner.getLoc(), "lvalue required as unary '&' operand");
            return QualType_Invalid;
        }
*/
        if (!ma.getIdentifierKind(inner)) return QualType_Invalid;
        QualType canon = t.getCanonicalType();
        if (canon.isConst() && (inner.isIdentifier() || inner.isMember())) {
            VarDecl* vd = getVarDecl(inner);
            if (vd) vd.setAddrUsed();
        }
        t = ma.builder.actOnPointerType(canon);
        e.copyCtcFlags(inner);
        break;
    case Deref:
        if (t.isPointer()) {
            e.setLValue();
            t = t.getCanonicalType();
            const PointerType* p = t.getPointerType();
            // TODO copy flags from inner
            return p.getInner();
        } else {
            ma.error(e.getLoc(), "indirection requires pointer operand ('%s' invalid)", t.diagName());
            return QualType_Invalid;
        }
        break;
    case Minus:
        QualType lhs = getMinusType(t.getCanonicalType());
        if (!lhs.isValid()) {
            ma.error(e.getLoc(), "invalid argument type '%s' to unary expression", t.diagName());
            return QualType_Invalid;
        }
        e.copyConstantFlags(inner);
        t = usualUnaryConversions(inner);
        break;
    case Not:
        e.copyConstantFlags(inner);
        t = usualUnaryConversions(inner);
        break;
    case LNot:
        e.copyConstantFlags(inner);
        return builtins[BuiltinKind.Bool];
    }

    return t;
}

fn bool Analyser.checkIncrDecr(Analyser* ma, Expr* inner, QualType t, bool is_incr, SrcLoc loc) {
    const char* operand = is_incr ? "increment operand" : "decrement operand";
    if (!ma.checkAssignment(inner, t, operand, loc)) return false;

    t = t.getCanonicalType();
    if (!t.isBuiltin() && !t.isPointer() && !t.isEnum()) {
        ma.error(loc, "cannot %s value of type '%s'", is_incr ? "increment" : "decrement", t.diagName());
        return false;
    }

    return true;
}

fn bool Analyser.getIdentifierKind(Analyser* ma, Expr* e) {
    IdentifierKind kind = getInnerExprAddressOf(e);
    const char* arg = "";
    switch (kind) {
    case Unresolved:
        QualType qt = e.getType();
        ma.error(e.getLoc(), "cannot take the address of an rvalue of type '%s'", qt.diagName());
        return false;
    case Module:
        arg = "a module";
        break;
    case Function:
        // NOTE: C2 does not allow address of function like C
        arg = "a function";
        break;
    case Type:
        arg = "a type";
        break;
    case Var:
        return true;
    case EnumConstant:
        arg = "an enum constant";
        break;
    case StructMember:
        return true;
    case Label:
        arg = "a label";
        break;
    }
    ma.error(e.getLoc(), "cannot take the address of %s", arg);
    return false;
}

fn IdentifierKind getInnerExprAddressOf(Expr* e) {
    // TODO change return type to IdentifierKind, use Unresolved for not-IdentifiersExpr/MemberExpr

    switch (e.getKind()) {
    case IntegerLiteral:    fallthrough;
    case FloatLiteral:      fallthrough;
    case BooleanLiteral:    fallthrough;
    case CharLiteral:       fallthrough;
    case StringLiteral:     fallthrough;
    case Nil:
        break;
    case Identifier:
        IdentifierExpr* i = cast<IdentifierExpr*>(e);
        return i.getKind();
    case Type:              fallthrough;
    case Call:              fallthrough;
    case InitList:          fallthrough;
    case FieldDesignatedInit:   fallthrough;
    case ArrayDesignatedInit:
        break;
    case BinaryOperator:
        break;
    case UnaryOperator:
        break;
    case ConditionalOperator:
        break;
    case Builtin:
        break;
    case ArraySubscript:
        ArraySubscriptExpr* a = cast<ArraySubscriptExpr*>(e);
        return getInnerExprAddressOf(a.getBase());
    case Member:
        MemberExpr* m = cast<MemberExpr*>(e);
        return m.getKind();
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        return getInnerExprAddressOf(p.getInner());
    case BitOffset:
        return IdentifierKind.Unresolved;
    case ExplicitCast:
        ExplicitCastExpr* c = cast<ExplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    case ImplicitCast:
        ImplicitCastExpr* c = cast<ImplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    }

    return IdentifierKind.Unresolved;
}

fn QualType getMinusType(QualType qt) {
    if (!qt.isBuiltin()) return QualType_Invalid;
    BuiltinType* bi = qt.getBuiltin();
    switch (bi.getKind()) {
    case Char:      fallthrough;
    case Int8:      fallthrough;
    case Int16:     fallthrough;
    case Int32:     fallthrough;
    case Int64:
        return qt;
    case UInt8:     fallthrough;
    case UInt16:    fallthrough;
    case UInt32:
        return ast.builtins[BuiltinKind.Int32];
    case UInt64:
        return ast.builtins[BuiltinKind.Int64];
    case Float32:   fallthrough;
    case Float64:   fallthrough;
    case ISize:
        return qt;
    case USize:
        return builtins[BuiltinKind.ISize];
    case Bool:      fallthrough;
    case Void:
        break;
    }
    return QualType_Invalid;
}


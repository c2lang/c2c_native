/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module module_analyser;

import ast local;

func QualType Analyser.analyseUnaryOperator(Analyser* ma, Expr** e_ptr, u32 side) {
    Expr* e = *e_ptr;
    UnaryOperator* u = cast<UnaryOperator*>(e);

    bool need_rvalue = true;

    // TODO need rvalue stuff
    switch (u.getOpcode()) {
    case PostInc:   fallthrough;
    case PostDec:   fallthrough;
    case PreInc:    fallthrough;
    case PreDec:
        if (!ma.curFunction) {
            ma.errorRange(e.getLoc(), e.getRange(), "initializer element is not a compile-time constant");
            return QualType_Invalid;
        }
        need_rvalue = false;
        side |= LHS;
        break;
    case AddrOf:
        need_rvalue = false;
        side |= LHS;
        break;
    case Deref:     fallthrough;
    case Minus:     fallthrough;
    case Not:       fallthrough;
    case LNot:
        side |= RHS;
        break;
    }

    QualType t = ma.analyseExpr(u.getInner2(), need_rvalue, side);
    if (t.isInvalid()) {
        return QualType_Invalid;
    }

    e = *e_ptr; // re-read in case of ImplicitCast insertions
    Expr* inner = u.getInner();

    if (t.isVoid()) {
        ma.error(e.getLoc(), "invalid argument type '%s' to unary expression", "void");
        return QualType_Invalid;
    }

    switch (u.getOpcode()) {
    case PostInc:
        // TODO check if ptr/builtin
        if (!ma.checkAssignment(inner, t, "increment operand", e.getLoc())) return QualType_Invalid;
        break;
    case PostDec:
        // TODO check if ptr/builtin
        if (!ma.checkAssignment(inner, t, "decrement operand", e.getLoc())) return QualType_Invalid;
        break;
    case PreInc:
        // TODO check if ptr/builtin
        if (!ma.checkAssignment(inner, t, "increment operand", e.getLoc())) return QualType_Invalid;
        break;
    case PreDec:
        // TODO check if ptr/builtin
        if (!ma.checkAssignment(inner, t, "decrement operand", e.getLoc())) return QualType_Invalid;
        break;
    case AddrOf:
/*
        // faster, but less verbose
        if (!inner.isLValue()) {
            ma.error(inner.getLoc(), "lvalue required as unary '&' operand");
            return QualType_Invalid;
        }
*/
        if (!ma.getIdentifierKind(inner)) return QualType_Invalid;
        QualType canon = t.getCanonicalType();
        t = ma.builder.actOnPointerType(canon);
        e.setCtc();
        break;
    case Deref:
        if (t.isPointer()) {
            e.setLValue();
            t = t.getCanonicalType();
            const PointerType* p = t.getPointerType();
            // TODO copy flags from inner
            return p.getInner();
        } else {
            ma.error(e.getLoc(), "indirection requires pointer operand ('%s' invalid)", t.diagName());
            return QualType_Invalid;
        }
        break;
    case Minus:
        QualType lhs = getMinusType(t.getCanonicalType());
        if (!lhs.isValid()) {
            ma.error(e.getLoc(), "invalid argument type '%s' to unary expression", t.diagName());
            return QualType_Invalid;
        }
        e.copyConstantFlags(inner);
        t = usualUnaryConversions(inner);
        break;
    case Not:
        e.copyConstantFlags(inner);
        t = usualUnaryConversions(inner);
        break;
    case LNot:
        e.copyConstantFlags(inner);
        return g_bool;
    }

    return t;
}

func bool Analyser.getIdentifierKind(Analyser* ma, Expr* e) {
    IdentifierKind kind = getInnerExprAddressOf(e);
    const char* arg = "";
    switch (kind) {
    case Unresolved:
        QualType qt = e.getType();
        ma.error(e.getLoc(), "cannot take the address of an rvalue of type '%s'", qt.diagName());
        return false;
    case Module:
        arg = "a module";
        break;
    case Function:
        // NOTE: C2 does not allow address of function like C
        arg = "a function";
        break;
    case Type:
        arg = "a type";
        break;
    case Var:
        return true;
    case EnumConstant:
        arg = "an enum constant";
        break;
    case StructMember:
        return true;
    case Label:
        arg = "a label";
        break;
    }
    ma.error(e.getLoc(), "cannot take the address of %s", arg);
    return false;
}

func IdentifierKind getInnerExprAddressOf(Expr* e) {
    // TODO change return type to IdentifierKind, use Unresolved for not-IdentifiersExpr/MemberExpr

    switch (e.getKind()) {
    case IntegerLiteral:    fallthrough;
    case FloatLiteral:      fallthrough;
    case BooleanLiteral:    fallthrough;
    case CharLiteral:       fallthrough;
    case StringLiteral:     fallthrough;
    case Nil:
        break;
    case Identifier:
        IdentifierExpr* i = cast<IdentifierExpr*>(e);
        return i.getKind();
    case Type:              fallthrough;
    case Call:              fallthrough;
    case InitList:          fallthrough;
    case FieldDesignatedInit:   fallthrough;
    case ArrayDesignatedInit:
        break;
    case BinaryOperator:
        break;
    case UnaryOperator:
        break;
    case ConditionalOperator:
        break;
    case Builtin:
        break;
    case ArraySubscript:
        ArraySubscriptExpr* a = cast<ArraySubscriptExpr*>(e);
        return getInnerExprAddressOf(a.getBase());
    case Member:
        MemberExpr* m = cast<MemberExpr*>(e);
        return m.getKind();
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        return getInnerExprAddressOf(p.getInner());
    case BitOffset:
        return IdentifierKind.Unresolved;
    case ExplicitCast:
        ExplicitCastExpr* c = cast<ExplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    case ImplicitCast:
        ImplicitCastExpr* c = cast<ImplicitCastExpr*>(e);
        return getInnerExprAddressOf(c.getInner());
    }

    return IdentifierKind.Unresolved;
}


/* Copyright 2022 Bas van den Berg
*/

module module_analyser;

import ast_context;
import ast local;
import ctv_analyser;
import diagnostics;
import module_list;
import scope;

import string;
import stdlib;
import stdio;

type UnusedChecker struct {
    diagnostics.Diags* diags;
}

func void UnusedChecker.check(void* arg, Decl* d) {
    UnusedChecker* c = arg;
    bool used = d.isUsed();
    if (!used) {
        c.diags.report(d.getLoc(), "unused %s: %s", d.getKindName(), d.getName());
        return;
    }
    if (d.isPublic() && !d.isUsedPublic()) {
        c.diags.report(d.getLoc(), "unused public %s: %s", d.getKindName(), d.getName());
    }

    switch (d.getKind()) {
    case Function:
        // TODO args + vars
        break;
    case Import:
        break;
    case StructType:
        // TODO fields
        break;
    case EnumType:
        if (used) c.checkEnum(cast<EnumTypeDecl*>(d));
        break;
    case EnumConstant:
        break;
    case FunctionType:
        break;
    case AliasType:
        break;
    case Var:
        break;
    case StaticAssert:
        break;
    }
}

func void UnusedChecker.checkEnum(UnusedChecker* c, EnumTypeDecl* d) {
    u32 num_consts = d.getNumConstants();
    EnumConstantDecl** constants = d.getConstants();
    for (u32 i=0; i<num_consts; i++) {
        EnumConstantDecl** ecd = constants[i];
        Decl* dd = cast<Decl*>(ecd);
        if (!dd.isUsed()) {
            c.diags.report(dd.getLoc(), "unused %s: %s", dd.getKindName(), dd.getName());
        }
    }
}

public func void checkUnused(diagnostics.Diags* diags, Module* mod) {
    UnusedChecker c = {
        .diags = diags,
    }
    mod.visitDecls(UnusedChecker.check, &c);
}


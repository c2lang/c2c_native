/* Copyright 2022 Bas van den Berg
*/

module scope;

import ast;
import diagnostics;
import module_list;
import utils;

import stdlib;
import string;
import stdio local;

public const u32 MaxLevels = 16;

public type Flags enum u8 {
    Function  = 0x1,
    Break     = 0x2,
    Continue  = 0x4,
    Decl      = 0x8,
    Control   = 0x10,
    Block     = 0x20,
    Switch    = 0x40,
    HasDecls  = 0x80,
}

public type Level struct {
    u32 flags;              // combination of Flags
    u32 first_index;
}

public type Scope struct {
    // global scope
    const module_list.ModList* allmodules;
    diagnostics.Diags* diags;
    const ast.ImportDeclList* imports;
    const ast.Module* mod;
    const ast.SymbolTable* symbols;
    // global cache
    //ast.SymbolTable global_cache;

    // local scope
    ast.SymbolTable local_scope;

    Level[MaxLevels] levels;
    u32 lvl;
} @(opaque)

public func Scope* create(module_list.ModList* allmodules,
                          diagnostics.Diags* diags,
                          const ast.ImportDeclList* imports,
                          ast.Module* mod,
                          const ast.SymbolTable* symbols)
{
    Scope* s = stdlib.calloc(1, sizeof(Scope));
    s.allmodules = allmodules;
    s.diags = diags;
    s.imports = imports;
    s.mod = mod;
    s.symbols = symbols;
    //s.global_cache.init(64);
    s.local_scope.init(64);
    return s;
}

public func void Scope.free(Scope* s) {
    //s.global_cache.free();
    s.local_scope.free();
    stdlib.free(s);
}

public func void Scope.enter(Scope* s, u32 flags) {
    if (s.lvl == MaxLevels) {
        // TODO give error
        // assert(0);
        return;
    }
    Level* top = &s.levels[s.lvl];
    // TODO combine flags
    top.flags = flags;
    top.first_index = s.local_scope.size();
    s.lvl++;
}

public func void Scope.exit(Scope* s) {
    // assert(s.level != 0)
    s.local_scope.crop(s.levels[s.lvl].first_index);
    s.lvl--;
}

// return Decl if a clash, nil if ok
public func ast.Decl* Scope.add(Scope* s, u32 name_idx, ast.Decl* d) {
    ast.Decl* old = s.find(name_idx);
    if (old) return old;

    s.local_scope.add(name_idx, d);
    return nil;
}

public func ast.Decl* Scope.find(const Scope* s, u32 name_idx) {
    return s.local_scope.find(name_idx);
}

public func ast.Module* Scope.findModule(Scope* s, u32 name_idx, utils.SrcLoc loc) {
    ast.ImportDecl* d = s.imports.find(name_idx);
    if (d) {
        // TODO set-used
        return d.getDest();
    }

    d = s.imports.findAny(name_idx);
    if (d) {
        s.diags.report(loc, "module %s imported with alias %s", d.asDecl().getName(), d.getAliasName());
        return nil;
    }

    ast.Module* mod = s.allmodules.find(name_idx);
    if (mod) {
        s.diags.report(loc, "module %s not imported", ast.idx2name(name_idx));
    } else {
        s.diags.report(loc, "unknown module '%s'", ast.idx2name(name_idx));
    }
    return nil;
}

public func ast.Decl* Scope.findGlobalSymbolInModule(Scope* s, ast.Module* mod, u32 name_idx, utils.SrcLoc loc) {
    ast.Decl* d = mod.getSymbols().find(name_idx);
    if (!d) {
        s.diags.report(loc, "no symbol '%s' in module %s", ast.idx2name(name_idx), mod.getName());
        s.symbols.dump();
        return nil;
    }

    // TODO use d.getMod()?
    if (mod != s.mod) {
        // TODO check public
        if (!d.isPublic()) {
            s.diags.report(loc, "symbol '%s' is not public", ast.idx2name(name_idx));
            return nil;
        }
        // d.setUsedPublic();
    }

    return d;
}

public func ast.Decl* Scope.findType(Scope* s, u32 name_idx, utils.SrcLoc loc) {
    ast.Decl* d = s.findGlobalSymbol(name_idx, loc);
    if (!d) {
        s.diags.report(loc, "unknown type %s", ast.idx2name(name_idx));
    }
    return d;
}

func ast.Decl* Scope.findGlobalSymbol(Scope* s, u32 name_idx, utils.SrcLoc loc) {
/*
    // Note: global cache seems to make it slower!
    ast.Decl* d = s.global_cache.find(name_idx);
    if (d) {
        // TODO update if used_public
        return d;
    }
*/

    ast.Decl* d = s.symbols.find(name_idx);

    // TODO check if visible also, see C2C findSymbol()
    // check if local imports also have symbol
    const u32 count = s.imports.size();
    ast.ImportDecl** decls = s.imports.getDecls();
    for (u32 i=1; i<count; i++) {       // note: skip first one (=self)
        ast.ImportDecl* id = decls[i];
        if (id.isLocal()) {
            ast.Module* dest = id.getDest();
            ast.Decl* d2 = dest.findSymbol(name_idx);
            if (d2) {
                if (d) {
                    s.diags.report(loc, "symbol %s is ambiguous", ast.idx2name(name_idx));
                    // TODO print uses
                    // TODO make prefix suggestion
                    break;
                } else {
                    d = d2;
                }
            }
        }
    }

    //s.global_cache.add(name_idx, d);

    return d;
}


/* Copyright 2022 Bas van den Berg
*/

module scope;

import ast;
import diagnostics;
import module_list;
import utils;

import ctype;
import stdlib;

public const u32 MaxLevels = 16;

public type Flags enum u8 {
    Function  = 0x1,
    Break     = 0x2,
    Continue  = 0x4,
    Decl      = 0x8,
    Control   = 0x10,
    Block     = 0x20,
    Switch    = 0x40,
    HasDecls  = 0x80,
}

public type Level struct {
    u32 flags;              // combination of Flags
    u32 first_index;
}

public type Scope struct {
    // global scope
    const module_list.ModList* allmodules;
    diagnostics.Diags* diags;
    const ast.ImportDeclList* imports;
    const ast.Module* mod;
    const ast.SymbolTable* symbols;
    // global cache
    //ast.SymbolTable global_cache;

    // local scope
    ast.SymbolTable local_scope;

    Level[MaxLevels] levels;
    u32 lvl;
} @(opaque)

public func Scope* create(module_list.ModList* allmodules,
                          diagnostics.Diags* diags,
                          const ast.ImportDeclList* imports,
                          ast.Module* mod,
                          const ast.SymbolTable* symbols)
{
    Scope* s = stdlib.calloc(1, sizeof(Scope));
    s.allmodules = allmodules;
    s.diags = diags;
    s.imports = imports;
    s.mod = mod;
    s.symbols = symbols;
    //s.global_cache.init(64);
    s.local_scope.init(64);
    return s;
}

public func void Scope.free(Scope* s) {
    //s.global_cache.free();
    s.local_scope.free();
    stdlib.free(s);
}

public func void Scope.enter(Scope* s, u32 flags) {
    if (s.lvl == MaxLevels) {
        // TODO give error
        assert(0);
        return;
    }
    Level* top = &s.levels[s.lvl];
    // TODO combine flags
    top.flags = flags;
    top.first_index = s.local_scope.size();
    s.lvl++;
}

public func void Scope.exit(Scope* s) {
    assert(s.lvl != 0);
    s.local_scope.crop(s.levels[s.lvl].first_index);
    s.lvl--;
}

// return Decl if a clash, nil if ok
public func ast.Decl* Scope.add(Scope* s, u32 name_idx, ast.Decl* d) {
    // TODO may clash with a 'import local' variable from another module

    ast.Decl* old = s.find(name_idx, d.getLoc());
    if (old) return old;

    s.local_scope.add(name_idx, d);
    return nil;
}

public func ast.Decl* Scope.find(Scope* s, u32 name_idx, utils.SrcLoc loc) {
    ast.Decl* decl = s.local_scope.find(name_idx);
    if (decl) return decl;

    return s.findGlobalSymbol(name_idx, loc, false);
}

public func ast.ImportDecl* Scope.findModule(Scope* s, u32 name_idx, utils.SrcLoc loc) {
    assert(s);
    ast.ImportDecl* d = s.imports.find(name_idx);
    d.asDecl().setUsed();

    if (d) return d;

    d = s.imports.findAny(name_idx);
    if (d) {
        s.diags.report(loc, "module %s imported with alias %s", d.asDecl().getName(), d.getAliasName());
        return nil;
    }

    ast.Module* mod = s.allmodules.find(name_idx);
    if (mod) {
        s.diags.report(loc, "module %s not imported", ast.idx2name(name_idx));
    } else {
        s.diags.report(loc, "unknown module '%s'", ast.idx2name(name_idx));
    }
    return nil;
}

public func ast.Decl* Scope.findGlobalSymbolInModule(Scope* s, ast.Module* mod, u32 name_idx, utils.SrcLoc loc) {
    assert(s);
    ast.Decl* d = mod.getSymbols().find(name_idx);
    if (!d) {
        s.diags.report(loc, "no symbol '%s' in module %s", ast.idx2name(name_idx), mod.getName());
        return nil;
    }

    // TODO use d.getMod()?
    if (mod != s.mod) {
        // TODO check public
        if (!d.isPublic()) {
            s.diags.report(loc, "symbol '%s' is not public", ast.idx2name(name_idx));
            return nil;
        }
        // d.setUsedPublic();
    }

    return d;
}

public func ast.Decl* Scope.findType(Scope* s, u32 name_idx, utils.SrcLoc loc) {
    assert(s);
    return s.findGlobalSymbol(name_idx, loc, true);
}

func ast.Decl* Scope.findGlobalSymbol(Scope* s, u32 name_idx, utils.SrcLoc loc, bool force_type) {
/*
    // Note: global cache seems to make it slower!
    ast.Decl* d = s.global_cache.find(name_idx);
    if (d) {
        // TODO update if used_public
        return d;
    }
*/

    ast.Decl* decl = nil;   //s.symbols.find(name_idx);

    ast.ImportDecl* used_import = nil;

    // lookup in local imported modules
    bool ambiguous = false;
    bool visible_match = false;

    u32 num_imports = s.imports.size();
    ast.ImportDecl** imports = s.imports.getDecls();
    for (u32 i=0; i<num_imports; i++) {
        ast.ImportDecl* id = imports[i];
        // check if it is the import itself
        if (name_idx == id.getImportNameIdx()) {
            decl = cast<ast.Decl*>(id);
            used_import = id;
            visible_match = true;
            continue;
        }

        if (id.isLocal()) {
            ast.Module* dest = id.getDest();
            const ast.SymbolTable* symbols = dest.getSymbols();
            ast.Decl* d = symbols.find(name_idx);
            if (!d) continue;

            bool visible = !((s.mod != dest) && !d.isPublic());
            if (decl) {
                // if previous result was non-visible, replace with new one
                if (visible_match == visible) {
                    const char* name = ast.idx2name(name_idx);
                    const char* mod2_name = ast.idx2name(id.getImportNameIdx());
                    if (!ambiguous) {
                        s.diags.report(loc, "symbol %s is ambiguous", name);
                        const char* mod1_name = ast.idx2name(used_import.getImportNameIdx());
                        s.diags.note(loc, "did you mean %s.%s or %s.%s?", mod1_name, name, mod2_name, name);
                        ambiguous = true;
                    } else {
                        s.diags.report(loc, "did you mean %s.%s?", mod2_name, name);
                    }
                    continue;
                }
                if (!visible_match) {  // replace with visible symbol
                    decl = d;
                    used_import = id;
                    visible_match = visible;
                }
            } else {
                decl = d;
                used_import = id;
                visible_match = visible;
            }
        }
    }
    if (ambiguous) return nil;

    if (decl) {
        bool external = (used_import.getDest() != s.mod);
        // mark importdecl as used (if not local)
        if (external) used_import.asDecl().setUsed();
        // TODO mark usedPublic?

        if (!visible_match) {
            s.diags.report(loc, "symbol %s is not public", ast.idx2name(name_idx));
            return nil;
        }
        if (external) decl.setUsedPublic();
        // TODO add to cache
    } else {
        const char* name = ast.idx2name(name_idx);
        const char* kind = "variable";
        if (ctype.isupper(name[0])) kind = "type/constant";
        if (force_type) kind = "type";
        s.diags.report(loc, "unknown %s: %s", kind, name);

        // TODO make suggestion based on symbols in all modules
    }

    return decl;
}


/* Copyright 2022 Bas van den Berg
*/

module unused_checker;

import warning_flags;
import ast local;
import diagnostics;

import stdio;

type Checker struct {
    diagnostics.Diags* diags;
    const warning_flags.Flags* warnings;
}

func const char* getFullName(const Decl* d) {
    if (d.getKind() != DeclKind.Function) return d.getName();

    const FunctionDecl* fd = cast<FunctionDecl*>(d);
    if (!fd.hasPrefix()) return d.getName();

    local char[64] tmp;
    stdio.sprintf(tmp, "%s.%s", fd.getPrefixName(), d.getName());
    return tmp;
}

func void Checker.check(void* arg, Decl* d) {
    Checker* c = arg;
    bool used = d.isUsed();
    if (d.isPublic() && !d.isUsedPublic() && !c.warnings.no_unused_public) {
        c.diags.warn(d.getLoc(), "unused public %s: %s", d.getKindName(), getFullName(d));
    }

    switch (d.getKind()) {
    case Function:
        if (c.warnings.no_unused_function) return;
        break;
    case Import:
        if (c.warnings.no_unused_import) return;
        break;
    case StructType:
        c.checkStructMembers(d);
        if (c.warnings.no_unused_type) return;
        break;
    case EnumType:
        if (used && !c.warnings.no_unused_enum_constant) {
            c.checkEnum(cast<EnumTypeDecl*>(d));
        }
        break;
    case EnumConstant:
        break;
    case FunctionType:
        if (c.warnings.no_unused_type) return;
        break;
    case AliasType:
        if (c.warnings.no_unused_type) return;
        break;
    case Var:
        if (c.warnings.no_unused_variable) return;
        break;
    case StaticAssert:
        break;
    }
    if (!used) {
        c.diags.warn(d.getLoc(), "unused %s: %s", d.getKindName(), getFullName(d));
        return;
    }
}

func void Checker.checkEnum(Checker* c, EnumTypeDecl* d) {
    u32 num_consts = d.getNumConstants();
    EnumConstantDecl** constants = d.getConstants();
    for (u32 i=0; i<num_consts; i++) {
        EnumConstantDecl* ecd = constants[i];
        Decl* dd = cast<Decl*>(ecd);
        if (!dd.isUsed()) {
            c.diags.warn(dd.getLoc(), "unused %s: %s", dd.getKindName(), dd.getName());
        }
    }
}

func void Checker.checkStructMembers(Checker* c, Decl* d) {
    StructTypeDecl* std = cast<StructTypeDecl*>(d);
    u32 num_members = std.getNumMembers();
    Decl** members = std.getMembers();
    for (u32 i=0; i<num_members; i++) {
        Decl* member = members[i];
        if (!member.isUsed()) {
            c.diags.warn(member.getLoc(), "unused struct member: %s", member.getName());
        }
        // TODO recurse
    }
}

public func void check(diagnostics.Diags* diags,
                       const warning_flags.Flags* warnings,
                       Module* mod)
{
    Checker c = {
        .diags = diags,
        .warnings = warnings,
    }
    mod.visitDecls(Checker.check, &c);
}


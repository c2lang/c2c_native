/* Copyright 2022 Bas van den Berg
*/

module ast;

import ast_context;
import string_buffer;
import utils;

public type ArrayTypeBits struct {
    u32 : NumTypeBits;
    u32 has_size : 1;       // if it has an sizeExpr
    u32 value_set : 1;
    u32 is_incremental : 1;
}

public type ArrayType struct {
    Type parent;
    QualType elem;
    Expr*[0] sizeExpr; // tail-allocated
} @(opaque)

public func ArrayType* ArrayType.create(ast_context.Context* c, QualType elem, bool is_incremental, Expr* sizeExpr) @(inline) {
    u32 size = sizeof(ArrayType);
    if (sizeExpr) size += sizeof(Expr*);
    ArrayType* t = c.alloc(size);
    t.parent.init(TypeKind.Array);
    t.parent.arrayTypeBits.is_incremental = is_incremental;
    t.elem = elem;

    if (sizeExpr) {
        t.parent.arrayTypeBits.has_size = 1;
        t.sizeExpr[0] = sizeExpr;
    }
    return t;
}

public func Type* ArrayType.asType(ArrayType* t) @(inline) { return &t.parent; }

public func void ArrayType.print(const ArrayType* t, string_buffer.Buf* out) {
    out.add("ArrayType\n");
    t.elem.print(out);
    if (t.parent.arrayTypeBits.has_size) {
        t.sizeExpr[0].print(out, 0);
    }
}

func void ArrayType.debugPrint(const ArrayType* t, string_buffer.Buf* out) {
    out.add("ArrayType\n");
    // TODO check if elems is also array
    // if (AT) TODO
    // else
    t.elem.debugPrint(out);

    out.add("[");
    //NOTE
    if (t.parent.arrayTypeBits.value_set) {
        // TODO print value?
        //t.sizeExpr[0].print(out, 0);
    } else {
        if (t.parent.arrayTypeBits.is_incremental) out.add("+");
            // TODO
            //t.sizeExpr[0].printLiteral(out);
        if (t.parent.arrayTypeBits.has_size) {
        }
    }
    out.add("]");

    // if (AT) AT->debugPostName()
}


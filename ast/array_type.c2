/* Copyright 2022 Bas van den Berg
*/

module ast;

import ast_context;
import string_buffer;

public type ArrayTypeBits struct {
    u32 : NumTypeBits;
    u32 has_size : 1;       // if it has an sizeExpr
    u32 value_set : 1;
    u32 is_incremental : 1;
}

public type ArrayType struct {
    Type parent;
    QualType elem;
    Expr*[0] sizeExpr; // tail-allocated
} @(opaque)

public func ArrayType* ArrayType.create(ast_context.Context* c, QualType elem, bool is_incremental, Expr* sizeExpr) @(inline) {
    u32 size = sizeof(ArrayType);
    if (sizeExpr) size += sizeof(Expr*);
    ArrayType* t = c.alloc(size);
    t.parent.init(TypeKind.Array);
    t.parent.arrayTypeBits.is_incremental = is_incremental;
    t.elem = elem;

    if (sizeExpr) {
        t.parent.arrayTypeBits.has_size = 1;
        t.sizeExpr[0] = sizeExpr;
    }
    return t;
}

public func Type* ArrayType.asType(ArrayType* t) @(inline) { return &t.parent; }

public func QualType ArrayType.getElemType(const ArrayType* t) { return t.elem; }

public func bool ArrayType.isIncremental(const ArrayType*t) {
    return t.parent.arrayTypeBits.is_incremental;
}

public func Expr* ArrayType.getSizeExpr(const ArrayType*t) {
    if (t.parent.arrayTypeBits.has_size) return t.sizeExpr[0];
    return nil;
}

func void ArrayType.print(const ArrayType* t, string_buffer.Buf* out) {
    t.elem.print(out);
    out.add("[");
    if (t.parent.arrayTypeBits.value_set) {
        // print value
    } else if (t.parent.arrayTypeBits.is_incremental) {
        out.add("+");
    } else if (t.parent.arrayTypeBits.has_size) {
        t.sizeExpr[0].printLiteral(out);
    }
    out.add("]");
    // TODO use printPost()  printPre()
}

func void ArrayType.debugPrint(const ArrayType* t, string_buffer.Buf* out) {
    out.add("ArrayType TODO\n");
}

public func void ArrayType.fullPrint(const ArrayType* t, string_buffer.Buf* out, u32 indent) {
    out.indent(indent);
    out.print("ArrayType [%p]\n", t);
    t.elem.fullPrint(out, indent + 2);
}

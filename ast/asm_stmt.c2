/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ast;

import ast_context;
import string_buffer;
import src_loc local;

import string;
import stdio;


type AsmStmtBits struct {
    u32 : NumStmtBits;
    u32 is_basic: 1;
    u32 is_volatile : 1;
}

public type AsmStmt struct {
    Stmt parent;
    SrcLoc loc;
    u8 num_constraits;
    u8 num_exprs;
    u8 num_clobbers;
    u8 num_outputs;
    u8 num_inputs;
    u8[2] pad; // keep names in right place without other members
    Expr*[0] constraints;
    Expr*[0] exprs;
    Expr*[0] clobbers;
    u32[0] names;   // tail-allocated
} @(opaque)

public func AsmStmt* AsmStmt.create(ast_context.Context* c,
                                    SrcLoc loc,
                                    bool is_basic,
                                    bool is_volatile,
                                    u32 num_outputs,
                                    u32 num_inputs,
                                    const u32* names,
                                    ExprList* constraints,
                                    ExprList* exprs,
                                    ExprList* clobbers,
                                    Expr* str) @(inline) {  // TODO change into u32 (now StringLiteral)
    u32 size = sizeof(AsmStmt);
    size += (constraints.size() * sizeof(Expr*));
    size += (exprs.size() * sizeof(Expr*));
    size += (clobbers.size() * sizeof(Expr*));
    size += (num_inputs + num_outputs) * sizeof(u32);
    AsmStmt* s = c.alloc(size);
    s.parent.init(StmtKind.Asm);
    s.parent.asmStmtBits.is_basic = is_basic;
    s.parent.asmStmtBits.is_volatile = is_volatile;
    s.num_outputs = cast<u8>(num_outputs);
    s.num_inputs = cast<u8>(num_inputs);
    s.num_constraits = cast<u8>(constraints.size());
    s.num_exprs = cast<u8>(exprs.size());
    s.num_clobbers = cast<u8>(clobbers.size());
    s.loc = loc;

    stdio.printf("ASM constraints: %u\n", constraints.size());
    stdio.printf("ASM exprs: %u\n", exprs.size());
    stdio.printf("ASM clobbers: %u\n", clobbers.size());
    stdio.printf("ASM out/in %u/%u\n", num_outputs, num_inputs);

    u8* tail = cast<u8*>(s.constraints);
    if (constraints.size()) {
        stdio.printf("CONSTRAINTS %u\n", cast<usize>(tail - cast<u8*>(s)));
        u32 sz = constraints.size() * sizeof(Expr*);
        string.memcpy(tail, constraints.getExprs(), sz);
        tail += sz;
    }
    if (exprs.size()) {
        stdio.printf("EXPRS %u\n", cast<usize>(tail - cast<u8*>(s)));
        u32 sz = exprs.size() * sizeof(Expr*);
        string.memcpy(tail, exprs.getExprs(), sz);
        tail += sz;
    }
    if (clobbers.size()) {
        u32 sz = clobbers.size() * sizeof(Expr*);
        string.memcpy(tail, clobbers.getExprs(), sz);
        tail += sz;
    }
    u32 num_names = num_outputs + num_inputs;
    if (num_names) {
        stdio.printf("NAMES %u\n", cast<usize>(tail - cast<u8*>(s)));
        for (u32 i=0; i<num_names; i++) {
            stdio.printf("NAME[%u] = %s\n", i, idx2name(names[i]));
            /* code */
        }
        string.memcpy(tail, names, num_names * sizeof(u32));
    }

#if AstStatistics
    Stats.addStmt(StmtKind.Asm, size);
#endif
    return s;
}

func Stmt* AsmStmt.instantiate(AsmStmt* s, Instantiator* inst) {
    // TODO 
    return cast<Stmt*>(s);
}

func SrcLoc AsmStmt.getLoc(const AsmStmt* s) {
    return s.loc;
}

func Expr** AsmStmt.getConstraints(const AsmStmt* s) {
    return s.constraints;
}

func Expr** AsmStmt.getExprs(const AsmStmt* s) {
    u8* tail = cast<u8*>(s.constraints);
    tail += s.num_constraits * sizeof(Expr*);
    return cast<Expr**>(tail);
}

func Expr** AsmStmt.getClobbers(const AsmStmt* s) {
    u8* tail = cast<u8*>(s.constraints);
    tail += s.num_constraits * sizeof(Expr*);
    tail += s.num_exprs * sizeof(Expr*);
    return cast<Expr**>(tail);
}

func u32* AsmStmt.getNames(const AsmStmt* s) {
    u8* tail = cast<u8*>(s.constraints);
    tail += s.num_constraits * sizeof(Expr*);
    tail += s.num_exprs * sizeof(Expr*);
    tail += s.num_clobbers * sizeof(Expr*);
    return cast<u32*>(tail);
}

func void AsmStmt.print(const AsmStmt* s, string_buffer.Buf* out, u32 indent) {
    s.parent.printKind(out, indent);
    out.newline();

    if (s.num_outputs) {
        out.indent(indent);
        out.color(col_Attr);
        out.add("outputs\n");
        const u32* names = s.getNames();
#if 0
        Expr** constraints = s.getConstraints();
        Expr** exprs = s.getExprs();
        for (u32 i=0; i<s.num_outputs; i++) {
            out.indent(indent+1);
            out.add(idx2name(names[i]));
            out.space();
            const StringLiteral* sl = cast<StringLiteral*>(constraints[i]);
            sl.printLiteral(out);
            const Expr* e = exprs[i];
            out.space();
            e.print(out, 0);
            out.newline();
        }
#endif
    }
    // TODO debug
    if (s.num_inputs) {
        out.indent(indent);
        out.color(col_Attr);
        out.add("inputs\n");
#if 0
        const u32* names = s.getNames();
        Expr** constraints = s.getConstraints();
        Expr** exprs = s.getExprs();
        for (u32 i=0; i<s.num_inputs; i++) {
            out.indent(indent+1);
            out.add(idx2name(names[i + s.num_outputs]));
            out.space();
            const StringLiteral* sl = cast<StringLiteral*>(constraints[i + s.num_outputs]);
            sl.printLiteral(out);
            const Expr* e = exprs[i + s.num_outputs];
            out.space();
            e.print(out, 0);
            out.newline();
        }
#endif
    }

    if (s.num_clobbers) {
        out.indent(indent);
        out.color(col_Attr);
        out.add("clobbers: ");
        Expr** clobbers = s.getClobbers();
        for (u32 i=0; i<s.num_clobbers; i++) {
            if (i != 0) out.space();

        }
    }
}


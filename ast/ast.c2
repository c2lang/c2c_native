/* Copyright 2022 Bas van den Berg
*/

module ast;

import string_buffer;

import stdlib;

/*
    Represents a single file with all its imports, decls, etc
*/
public type AST struct {
    const char* filename;   // no ownership
    Module* mod;
    void* ptr;  // pointer used during analyser/generation (in analysis: Scope*)
    u32 idx;

    ImportDeclList imports;
    DeclList types;
    DeclList variables;
    FunctionDeclList functions;
    DeclList static_asserts;
} @(opaque)

public func AST* AST.create(const char* filename, Module* mod) {
    AST* a = stdlib.calloc(1, sizeof(AST));
    a.filename = filename;
    a.mod = mod;
    a.idx = addAST(a);
    a.imports.init();
    a.types.init();
    a.variables.init();
    a.functions.init();
    a.static_asserts.init();
    return a;
}

public func void AST.free(AST* a) {
    a.imports.free();
    a.types.free();
    a.variables.free();
    a.functions.free();
    a.static_asserts.free();
    stdlib.free(a);
}

public func const char*  AST.getFilename(const AST* a) @(inline) { return a.filename; }

public func void AST.setPtr(AST* a, void* ptr) @(inline) { a.ptr = ptr; }

public func void* AST.getPtr(const AST* a) @(inline) { return a.ptr; }

public func void AST.addImport(AST* a, ImportDecl* d) @(inline) {
    a.imports.add(d);
}

public func void AST.addFunc(AST* a, FunctionDecl* d) @(inline) {
    a.functions.add(d);
}

public func void AST.addTypeDecl(AST* a, Decl* d) @(inline) {
    a.types.add(d);
}

public func void AST.addVarDecl(AST* a, Decl* d) @(inline) {
    a.variables.add(d);
}

public func void AST.addStaticAssert(AST* a, StaticAssertDecl* d) @(inline) {
    a.static_asserts.add(d.asDecl());
}

public type ImportVisitor func void (void* arg, ImportDecl* d);

public func void AST.visitImports(const AST* a, ImportVisitor visitor, void* arg) {
    ImportDecl** imports = a.imports.getDecls();
    // Note: skip first 'Import' since it is really the module statement
    for (u32 i=1; i<a.imports.size(); i++) {
        visitor(arg, imports[i]);
    }
}

public func const ImportDeclList* AST.getImports(const AST* a) { return &a.imports; }

public type StructFunctionVisitor func void (void* arg, FunctionDecl* d);

public func void AST.visitStructFunctions(const AST* a, StructFunctionVisitor visitor, void* arg) {
    FunctionDecl** functions = a.functions.getDecls();
    for (u32 i=0; i<a.functions.size(); i++) {
        FunctionDecl* d = functions[i];
        if (d.hasPrefix()) visitor(arg, d);
    }
}

public type TypeDeclVisitor func void (void* arg, Decl* d);

public func void AST.visitTypeDecls(const AST* a, TypeDeclVisitor visitor, void* arg) {
    Decl** types = a.types.getDecls();
    for (u32 i=0; i<a.types.size(); i++) {
        visitor(arg, types[i]);
    }
}

public type VarDeclVisitor func void (void* arg, VarDecl* d);

public func void AST.visitVarDecls(const AST* a, VarDeclVisitor visitor, void* arg) {
    Decl** variables = a.variables.getDecls();
    for (u32 i=0; i<a.variables.size(); i++) {
        visitor(arg, cast<VarDecl*>(variables[i]));
    }
}

public func Decl* AST.findType(const AST* a, u32 name_idx) {
    Decl** types = a.types.getDecls();
    for (u32 i=0; i<a.types.size(); i++) {
        Decl* d = types[i];
        if (d.getNameIdx() == name_idx) return d;
    }
    return nil;
}

public func void AST.info(const AST* a, string_buffer.Buf* out) {
    out.print("    %s\n", a.filename);
}

public func void AST.print(const AST* a, string_buffer.Buf* out) {
    out.print("------- AST %s ----\n", a.filename);

    ImportDecl** imports = a.imports.getDecls();
    for (u32 i=0; i<a.imports.size(); i++) {
        imports[i].print(out, 0);
        out.add("\n");
    }

    Decl** types = a.types.getDecls();
    for (u32 i=0; i<a.types.size(); i++) {
        types[i].print(out, 0);
        out.add("\n");
    }

    Decl** variables = a.variables.getDecls();
    for (u32 i=0; i<a.variables.size(); i++) {
        variables[i].print(out, 0);
        out.add("\n");
    }

    FunctionDecl** functions = a.functions.getDecls();
    for (u32 i=0; i<a.functions.size(); i++) {
        functions[i].print(out, 0);
        out.add("\n");
    }

    Decl** asserts = a.static_asserts.getDecls();
    for (u32 i=0; i<a.static_asserts.size(); i++) {
        asserts[i].print(out, 0);
        out.add("\n");
    }
}


/* Copyright 2022 Bas van den Berg
*/

module ast;

import ast_context;
import string_buffer;
import src_loc local;

public type BuiltinExprBits struct {
    u32 : NumExprBits;
    u32 kind : 3;
}

public type BuiltinExprKind enum u8 {
    Sizeof,
    Elemsof,
    EnumMin,
    EnumMax,
    OffsetOf,
    ToContainer,
}

// Keep in sync
const char*[] builtin_names = {
    "sizeof",
    "elemsof",
    "enum_min",
    "enum_max",
    "offsetof",
    "to_container",
}

static_assert(elemsof(BuiltinExprKind), elemsof(builtin_names));

public type ToContainerData struct {
    Expr* member;
    Expr* pointer;
}

public type OffsetOfData struct {
    Expr* member;       // Identifier / MemberExpr
}

public type BuiltinExpr struct {
    Expr parent;
    // TODO use TypeRef (can contain Type or VarDecl ref)
    Expr* inner;
    usize value;    // set during analysis

    OffsetOfData[0] offset;     // tail-allocated, only for offsetof
    ToContainerData[0] container;   // tail-allocated, only for to_container
} @(opaque)

public func BuiltinExpr* BuiltinExpr.create(ast_context.Context* c, SrcLoc loc, Expr* inner, BuiltinExprKind kind) @(inline) {
    const u32 size = sizeof(BuiltinExpr);
    BuiltinExpr* e = c.alloc(size);
    e.parent.init(ExprKind.Builtin, loc, 1, 1, 0, ValType.RValue);
    e.parent.parent.builtinExprBits.kind = kind;
    e.inner = inner;
    e.value = 0;
#if AstStatistics
    Stats.addExpr(ExprKind.Builtin, size);
#endif
    return e;
}

public func BuiltinExpr* BuiltinExpr.createOffsetOf(ast_context.Context* c, SrcLoc loc, Expr* typeExpr, Expr* member) @(inline) {
    const u32 size  =sizeof(BuiltinExpr) + sizeof(OffsetOfData);
    BuiltinExpr* e = c.alloc(size);
    e.parent.init(ExprKind.Builtin, loc, 1, 1, 0, ValType.RValue);
    e.parent.parent.builtinExprBits.kind = BuiltinExprKind.OffsetOf;
    e.inner = typeExpr;
    e.offset[0].member = member;
#if AstStatistics
    Stats.addExpr(ExprKind.Builtin, size);
#endif
    return e;
}

public func BuiltinExpr* BuiltinExpr.createToContainer(ast_context.Context* c, SrcLoc loc, Expr* typeExpr, Expr* member, Expr* pointer) @(inline) {
    const u32 size = sizeof(BuiltinExpr) + sizeof(ToContainerData);
    BuiltinExpr* e = c.alloc(size);
    e.parent.init(ExprKind.Builtin, loc, 1, 1, 0, ValType.RValue);
    e.parent.parent.builtinExprBits.kind = BuiltinExprKind.ToContainer;
    e.inner = typeExpr;
    e.container[0].member = member;
    e.container[0].pointer = pointer;
#if AstStatistics
    Stats.addExpr(ExprKind.Builtin, size);
#endif
    return e;
}

public func BuiltinExprKind BuiltinExpr.getKind(const BuiltinExpr* e) {
    return cast<BuiltinExprKind>(e.parent.parent.builtinExprBits.kind);
}

public func usize BuiltinExpr.getValue(const BuiltinExpr* e) { return e.value; }

public func void BuiltinExpr.setValue(BuiltinExpr* e, usize value ) {
    e.value = value;
}

public func Expr* BuiltinExpr.getInner(const BuiltinExpr* e) { return e.inner; }

public func SrcLoc BuiltinExpr.getEndLoc(const BuiltinExpr* e) @(inline) {
    switch (e.getKind()) {
    case Sizeof:    fallthrough;
    case Elemsof:   fallthrough;
    case EnumMin:   fallthrough;
    case EnumMax:
        break;
    case OffsetOf:
        return e.offset[0].member.getEndLoc() + 1;  // add closing )
    case ToContainer:
        return e.container[0].pointer.getEndLoc() + 1;  // add closing )
    }
    return e.inner.getEndLoc(); // note: misses end ), but cannot add 1 here
}

public func Expr* BuiltinExpr.getOffsetOfMember(const BuiltinExpr* b) {
    assert(b.getKind() == BuiltinExprKind.OffsetOf);
    return b.offset[0].member;
}

public func Expr* BuiltinExpr.getToContainerMember(const BuiltinExpr* b) {
    assert(b.getKind() == BuiltinExprKind.ToContainer);
    return b.container[0].member;
}

public func Expr* BuiltinExpr.getToContainerPointer(const BuiltinExpr* b) {
    assert(b.getKind() == BuiltinExprKind.ToContainer);
    return b.container[0].pointer;
}

public func Expr** BuiltinExpr.getToContainerPointer2(BuiltinExpr* b) {
    assert(b.getKind() == BuiltinExprKind.ToContainer);
    return &b.container[0].pointer;
}

func void BuiltinExpr.print(const BuiltinExpr* e, string_buffer.Buf* out, u32 indent) {
    e.parent.printKind(out, indent);
    e.parent.printTypeBits(out);
    out.color(col_Attr);
    out.print(" %s", builtin_names[e.getKind()]);
    out.color(col_Calc);
    out.print(" %u", e.value);
    out.add1('\n');

    e.inner.print(out, indent + 1);

    switch (e.getKind()) {
    case Sizeof:
        break;
    case Elemsof:
        break;
    case EnumMin:
        break;
    case EnumMax:
        break;
    case OffsetOf:
        e.offset[0].member.print(out, indent + 1);
        break;
    case ToContainer:
        e.container[0].member.print(out, indent + 1);
        e.container[0].pointer.print(out, indent + 1);
        break;
    }
}

func void BuiltinExpr.printLiteral(const BuiltinExpr* e, string_buffer.Buf* out) {
    out.add(builtin_names[e.getKind()]);
    out.add1('(');
    out.add1(')');
    switch (e.getKind()) {
    case Sizeof:
        break;
    case Elemsof:
        break;
    case EnumMin:
        break;
    case EnumMax:
        break;
    case OffsetOf:
        // TODO
        //e.offset[0].member.print(out, indent + 1);
        break;
    case ToContainer:
        // TODO
        //e.container[0].member.print(out, indent + 1);
        //e.container[0].pointer.print(out, indent + 1);
        break;
    }
}


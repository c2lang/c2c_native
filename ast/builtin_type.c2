/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ast;

import ast_context;
import string_buffer;

// Note: dont change positions, since they are used to check interval
public type BuiltinKind enum u8 {
    Char,
    Int8,
    Int16,
    Int32,
    Int64,
    UInt8,
    UInt16,
    UInt32,
    UInt64,
    Float32,
    Float64,
    ISize,
    USize,
    Bool,
    Void,
}

const char*[] builtinType_names = {
    "char",
    "i8",
    "i16",
    "i32",
    "i64",
    "u8",
    "u16",
    "u32",
    "u64",
    "f32",
    "f64",
    "isize",
    "usize",
    "bool",
    "void",
}

static_assert(elemsof(BuiltinKind), elemsof(builtinType_names));

const bool[] BuiltinType_promotable = {
    true,
    true,
    true,
    false,
    false,
    true,
    true,
    false,
    false,
    false,
    false,
    false,
    false,
    true,
    false,
}

static_assert(elemsof(BuiltinKind), elemsof(BuiltinType_promotable));

const bool[] BuiltinType_signed = {
    true,
    true,
    true,
    true,
    true,
    false,
    false,
    false,
    false,
    true,
    true,
    true,
    false,
    false,
    false,
}

static_assert(elemsof(BuiltinKind), elemsof(BuiltinType_signed));

const bool[] BuiltinType_unsigned = {
    false,
    false,
    false,
    false,
    false,
    true,
    true,
    true,
    true,
    false,
    false,
    false,
    true,
    false,
    false,
}

static_assert(elemsof(BuiltinKind), elemsof(BuiltinType_unsigned));

const bool[] BuiltinType_integer = {
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    false,
    false,
    true,
    true,
    false,
    false,
}

static_assert(elemsof(BuiltinKind), elemsof(BuiltinType_integer));

// not const because isize/usize
u32[] builtinType_sizes = {
    1,          // Char
    1, 2, 4, 8, // IntX
    1, 2, 4, 8, // UIntX
    4, 8,       // FloatX
    8, 8,       // Isize/Usize <- need to change for ARCH
    1,          // Bool
    0,          // Void
}
static_assert(elemsof(BuiltinKind), elemsof(builtinType_sizes));

// not const because isize/usize, set those from ast.init()
u32[] builtinType_width = {
    7,             // Char
    7, 15, 31, 63, // IntX
    8, 16, 32, 64, // UIntX
    0, 0,          // FloatX
    63, 64,        // Isize/Usize <- need to change for ARCH
    1,             // Bool
    0,             // Void
}
static_assert(elemsof(BuiltinKind), elemsof(builtinType_width));

BuiltinKind[] builtinType_baseTypes = {
    BuiltinKind.Char,
    BuiltinKind.Int8,
    BuiltinKind.Int16,
    BuiltinKind.Int32,
    BuiltinKind.Int64,
    BuiltinKind.UInt8,
    BuiltinKind.UInt16,
    BuiltinKind.UInt32,
    BuiltinKind.UInt64,
    BuiltinKind.Float32,
    BuiltinKind.Float64,
    BuiltinKind.Int64,      // can be changed in ast.init()
    BuiltinKind.UInt64,     // can be changed in ast.init()
    BuiltinKind.Bool,
    BuiltinKind.Void,
}
static_assert(elemsof(BuiltinKind), elemsof(builtinType_baseTypes));

public type BuiltinTypeBits struct {
    u32 : NumTypeBits;
    u32 kind : 4;
}

public type BuiltinType struct {
    Type parent;
} @(opaque)

// wordsize in bytes
func void builtin_configure(u32 wordsize) {
    builtinType_sizes[BuiltinKind.ISize] = wordsize;
    builtinType_sizes[BuiltinKind.USize] = wordsize;
    builtinType_width[BuiltinKind.ISize] = wordsize * 8 - 1;
    builtinType_width[BuiltinKind.USize] = wordsize * 8;

    if (wordsize == 4) {
        builtinType_baseTypes[BuiltinKind.ISize] = BuiltinKind.Int32;
        builtinType_baseTypes[BuiltinKind.USize] = BuiltinKind.UInt32;
    } else {
        builtinType_baseTypes[BuiltinKind.ISize] = BuiltinKind.Int64;
        builtinType_baseTypes[BuiltinKind.USize] = BuiltinKind.UInt64;
    }
}

public func BuiltinType* BuiltinType.create(ast_context.Context* c, BuiltinKind kind) {
    BuiltinType* b = c.alloc(sizeof(BuiltinType));
    b.parent.init(TypeKind.Builtin);
    b.parent.builtinTypeBits.kind = kind;
    b.parent.setCanonicalType(QualType.init(&b.parent));
#if AstStatistics
    Stats.addType(TypeKind.Builtin, sizeof(BuiltinType));
#endif
    return b;
}

public func BuiltinKind BuiltinType.getKind(const BuiltinType* b) {
    return cast<BuiltinKind>(b.parent.builtinTypeBits.kind);
}

// converts ISize/USize to Int64/UInt64 or Int32/UInt32 depending on arch
public func BuiltinKind BuiltinType.getBaseKind(const BuiltinType* b) {
    return builtinType_baseTypes[b.getKind()];
}

public func bool BuiltinType.isChar(const BuiltinType* b) {
    return b.parent.builtinTypeBits.kind == BuiltinKind.Char;
}

public func bool BuiltinType.isInt8(const BuiltinType* b) {
    return b.parent.builtinTypeBits.kind == BuiltinKind.Int8;
}

public func bool BuiltinType.isUInt8(const BuiltinType* b) {
    return b.parent.builtinTypeBits.kind == BuiltinKind.UInt8;
}

public func bool BuiltinType.isInt32(const BuiltinType* b) {
    return b.parent.builtinTypeBits.kind == BuiltinKind.Int32;
}

public func bool BuiltinType.isBool(const BuiltinType* b) {
    return b.parent.builtinTypeBits.kind == BuiltinKind.Bool;
}

public func bool BuiltinType.isVoid(const BuiltinType* b) {
    return b.parent.builtinTypeBits.kind == BuiltinKind.Void;
}

public func bool BuiltinType.isArithmeticType(const BuiltinType* b) {
    // Bool and Void are not, the rest is
    return b.parent.builtinTypeBits.kind < BuiltinKind.Bool;
}

func const char* BuiltinType.kind2str(const BuiltinType* b) {
    return builtinType_names[b.getKind()];
}

public func bool BuiltinType.isPromotableIntegerType(const BuiltinType* b) {
    return BuiltinType_promotable[b.getKind()];
}

public func bool BuiltinType.isInteger(const BuiltinType* b) {
    return BuiltinType_integer[b.getKind()];
}

public func bool BuiltinType.isSigned(const BuiltinType* b) {
    return BuiltinType_signed[b.getKind()];
}

public func bool BuiltinType.isUnsigned(const BuiltinType* b) {
    return BuiltinType_unsigned[b.getKind()];
}

public func u32 BuiltinType.getAlignment(const BuiltinType* b) {
    return builtinType_sizes[b.getKind()];
}

public func u32 BuiltinType.getWidth(const BuiltinType* b) {
    return builtinType_width[b.getKind()];
}

func void BuiltinType.print(const BuiltinType* b, string_buffer.Buf* out) {
    out.add(builtinType_names[b.getKind()]);
}

public func void BuiltinType.fullPrint(const BuiltinType* t, string_buffer.Buf* out, u32 indent) {
    out.indent(indent);
    out.print("BuiltinType [%p] %s\n", t, t.kind2str());
}

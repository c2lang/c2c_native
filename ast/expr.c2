/* Copyright 2022 Bas van den Berg
*/

module ast;

import utils local;
import string_buffer;
import stdio;

public type ExprKind enum u8 {
    IntegerLiteral,
/*
    FloatLiteral,
*/
    BooleanLiteral,
    CharLiteral,
    StringLiteral,
    Nil,
    Identifier,
    Type,
    Call,
    InitList,
    FieldDesignatedInit,
    ArrayDesignatedInit,
    BinaryOperator,
    UnaryOperator,
    ConditionalOperator,
    Builtin,
    ArraySubscript,
    Member,
    Paren,
    BitOffset,
    ExplicitCast,
/*
    ImplicitCast,
*/
}

public type ExprBits struct {
    u32 : NumStmtBits;
    u32 kind : 8;
    u32 is_ctv : 1;
    u32 is_ctc : 1;
    u32 is_lvalue : 1;
}
public const u32 NumExprBits = NumStmtBits + 16;

public type Expr struct {
    Stmt parent;
    SrcLoc loc;
    QualType qt;
} @(opaque)

public func void Expr.init(Expr* e, ExprKind k, SrcLoc loc, bool ctv, bool ctc, bool lvalue) @(inline) {
    e.parent.init(StmtKind.Expr);
    e.parent.exprBits.kind = k;
    e.parent.exprBits.is_ctv = ctv;
    e.parent.exprBits.is_ctc = ctc;
    e.parent.exprBits.is_lvalue = lvalue;
    e.loc = loc;
    e.qt.ptr = 0;
}

public func Stmt* Expr.asStmt(Expr* e) @(inline) { return &e.parent; }

// TEMP cast needed until Analyser fixed
public func ExprKind Expr.getKind(const Expr* e) @(inline) { return cast<ExprKind>(e.parent.exprBits.kind); }

public func bool Expr.isCtv(const Expr* e) @(inline) { return e.parent.exprBits.is_ctv; }

public func bool Expr.isCtc(const Expr* e) @(inline) { return e.parent.exprBits.is_ctc; }

public func SrcLoc Expr.getLoc(const Expr* e) @(inline) { return e.loc; }

public func void Expr.dump(Expr* e) {
    string_buffer.Buf* out = string_buffer.create(10*4096);
    e.print(out, 0);
    stdio.puts(out.data());
    out.free();
}

func void Expr.print(const Expr* e, string_buffer.Buf* out, u32 indent) {
    switch (e.getKind()) {
    case ExprKind.IntegerLiteral:
        IntegerLiteral.print(cast<IntegerLiteral*>(e), out, indent);
        break;
    case ExprKind.BooleanLiteral:
        BooleanLiteral.print(cast<BooleanLiteral*>(e), out, indent);
        break;
    case ExprKind.CharLiteral:
        CharLiteral.print(cast<CharLiteral*>(e), out, indent);
        break;
    case ExprKind.StringLiteral:
        StringLiteral.print(cast<StringLiteral*>(e), out, indent);
        break;
    case ExprKind.Nil:
        NilExpr.print(cast<NilExpr*>(e), out, indent);
        break;
    case ExprKind.Identifier:
        IdentifierExpr.print(cast<IdentifierExpr*>(e), out, indent);
        break;
    case ExprKind.Type:
        TypeExpr.print(cast<TypeExpr*>(e), out, indent);
        break;
    case ExprKind.Call:
        CallExpr.print(cast<CallExpr*>(e), out, indent);
        break;
    case ExprKind.InitList:
        InitListExpr.print(cast<InitListExpr*>(e), out, indent);
        break;
    case ExprKind.FieldDesignatedInit:
        FieldDesignatedInitExpr.print(cast<FieldDesignatedInitExpr*>(e), out, indent);
        break;
    case ExprKind.ArrayDesignatedInit:
        ArrayDesignatedInitExpr.print(cast<ArrayDesignatedInitExpr*>(e), out, indent);
        break;
    case ExprKind.BinaryOperator:
        BinaryOperator.print(cast<BinaryOperator*>(e), out, indent);
        break;
    case ExprKind.UnaryOperator:
        UnaryOperator.print(cast<UnaryOperator*>(e), out, indent);
        break;
    case ExprKind.ConditionalOperator:
        ConditionalOperator.print(cast<ConditionalOperator*>(e), out, indent);
        break;
    case ExprKind.Builtin:
        BuiltinExpr.print(cast<BuiltinExpr*>(e), out, indent);
        break;
    case ExprKind.ArraySubscript:
        ArraySubscriptExpr.print(cast<ArraySubscriptExpr*>(e), out, indent);
        break;
    case ExprKind.Member:
        MemberExpr.print(cast<MemberExpr*>(e), out, indent);
        break;
    case ExprKind.Paren:
        ParenExpr.print(cast<ParenExpr*>(e), out, indent);
        break;
    case ExprKind.BitOffset:
        BitOffsetExpr.print(cast<BitOffsetExpr*>(e), out, indent);
        break;
    case ExprKind.ExplicitCast:
        ExplicitCastExpr.print(cast<ExplicitCastExpr*>(e), out, indent);
        break;
    }
}

func void Expr.printLiteral(const Expr* e, string_buffer.Buf* out) {
    switch (e.getKind()) {
    case ExprKind.IntegerLiteral:
        IntegerLiteral.printLiteral(cast<IntegerLiteral*>(e), out);
        return;
    case ExprKind.BooleanLiteral:
        BooleanLiteral.printLiteral(cast<BooleanLiteral*>(e), out);
        return;
    case ExprKind.CharLiteral:
        CharLiteral.printLiteral(cast<CharLiteral*>(e), out);
        return;
    case ExprKind.StringLiteral:
        // can happen?
        break;
    case ExprKind.Nil:
        NilExpr.printLiteral(cast<NilExpr*>(e), out);
        return;
    case ExprKind.Identifier:
        IdentifierExpr.printLiteral(cast<IdentifierExpr*>(e), out);
        return;
    case ExprKind.Type:
        // can happen? array[enum_max(Enum)} ?
        break;
    case ExprKind.Call:
        break;
    case ExprKind.InitList:
        break;
    case ExprKind.FieldDesignatedInit:
        break;
    case ExprKind.ArrayDesignatedInit:
        break;
    case ExprKind.BinaryOperator:
        BinaryOperator.printLiteral(cast<BinaryOperator*>(e), out);
        return;
    case ExprKind.UnaryOperator:
        UnaryOperator.printLiteral(cast<UnaryOperator*>(e), out);
        return;
    case ExprKind.ConditionalOperator:
        break;
    case ExprKind.Builtin:
        BuiltinExpr.printLiteral(cast<BuiltinExpr*>(e), out);
        return;
    case ExprKind.ArraySubscript:
        // can happen?
        break;
    case ExprKind.Member:
        MemberExpr.printLiteral(cast<MemberExpr*>(e), out);
        return;
    case ExprKind.Paren:
        ParenExpr.printLiteral(cast<ParenExpr*>(e), out);
        return;
    case ExprKind.BitOffset:
        break;
    case ExprKind.ExplicitCast:
        break;
    }
    out.print("?? kind=%u", e.getKind());
}

func void Expr.printKind(const Expr* e, string_buffer.Buf* out, u32 indent, const char* kind_) {
    out.indent(indent);
    out.color(col_Expr);
    out.add(kind_);
}

func void Expr.printTypeBits(const Expr* e, string_buffer.Buf* out) {
    out.add(" ");
    e.qt.printQuoted(out);
    out.color(col_Attr);
    if (e.parent.exprBits.is_ctv) out.add(" CTV");
    if (e.parent.exprBits.is_ctc) out.add(" CTC");
    if (e.parent.exprBits.is_lvalue) out.add(" lvalue");
}


/* Copyright 2022 Bas van den Berg
*/

module ast;

import ast_context;
import utils local;
import string_buffer;
import string;

type FunctionDeclBits struct {
    u32 : NumDeclBits;
    u32 is_variadic : 1;
    u32 has_prefix : 1;
    u32 num_params : 5;
}

public type FunctionDecl struct {
    Decl parent;
    QualType rtype;
    CompoundStmt* body;
    IdentifierExpr* [0] prefix;
    VarDecl*[0] params; // tail-allocated;
} @(opaque)

public func FunctionDecl* FunctionDecl.create(ast_context.Context* c,
                                              const char* name,
                                              SrcLoc loc,
                                              bool is_public,
                                              QualType rtype,
                                              IdentifierExpr* prefix,
                                              VarDecl** params,
                                              u32 num_params,
                                              bool is_variadic) @(inline)
{
    u32 size = sizeof(FunctionDecl) + num_params * sizeof(VarDecl*);
    if (prefix) size += sizeof(IdentifierExpr*);
    FunctionDecl* d = c.alloc(size);
    d.parent.init(DeclKind.Function, name, loc, is_public);
    d.parent.functionDeclBits.is_variadic = is_variadic;
    d.parent.functionDeclBits.num_params = num_params;
    d.body = nil;
    u32 params_offset = 0;
    if (prefix) {
        d.parent.functionDeclBits.has_prefix = 1;
        d.prefix[0] = prefix;
        params_offset = 1;
    }
    if (num_params) {
        string.memcpy(cast<void*>(&d.params[params_offset]), cast<void*>(params), num_params * sizeof(VarDecl*));
    }
    return d;
}

public func void FunctionDecl.setBody(FunctionDecl* d, CompoundStmt* body) @(inline) { d.body = body; }

public func Decl* FunctionDecl.asDecl(FunctionDecl* d) @(inline) { return &d.parent; }


public func void FunctionDecl.print(const FunctionDecl* d, string_buffer.Buf* out, u32 indent) {
    d.parent.printKind(out, indent, "FunctionDecl");
    // TODO print type (not rtype, that's shown in type)
    d.parent.printBits(out);
    d.parent.printName(out);

    if (d.parent.functionDeclBits.is_variadic) {
        out.color(col_Attr);
        out.add(" ...");
    }
    if (d.parent.functionDeclBits.has_prefix) {
        out.color(col_Attr);
        out.add(" ");
        // TODO static struct function
        out.add("SF");
    }
    out.add("\n");

    u32 params_offset = 0;
    if (d.parent.functionDeclBits.has_prefix) {
        d.prefix[0].print(out, indent + 2);
        params_offset = 1;
    }
    //d.rtype.print(out, indent + 2);
    for (u32 i=0; i<d.parent.functionDeclBits.num_params; i++) {
        d.params[params_offset + i].print(out, indent + 2);
    }
    if (d.body) {
        d.body.print(out, indent + 2);
    }
}


/* Copyright 2022 Bas van den Berg
*/

module ast;

import ast_context;
import src_loc local;
import string_buffer;
import string;

type FunctionDeclBits struct {
    u32 : NumDeclBits;
    u32 is_variadic : 1;
    u32 has_prefix : 1;     // is a (static) struct-function
    u32 num_params : 5;
    u32 has_return : 1;     // if it returns something, set during analysis
    u32 attr_unused_params : 1;
    u32 attr_noreturn : 1;
    u32 attr_inline : 1;
    u32 attr_weak : 1;
}

public type FunctionDecl struct {
    Decl parent;
    CompoundStmt* body;
    QualType rt;    // return type after analysis
    TypeRef rtype;  // note: variable size!
    Ref[0] prefix;  // tail-allocated
    //VarDecl*[0] params; // tail-allocated;
} @(opaque)

public func FunctionDecl* FunctionDecl.create(ast_context.Context* c,
                                              u32 name,
                                              SrcLoc loc,
                                              bool is_public,
                                              u32 ast_idx,
                                              const TypeRefHolder* rtype,
                                              const Ref* prefix,
                                              VarDecl** params,
                                              u32 num_params,
                                              bool is_variadic) @(inline)
{
    u32 size = sizeof(FunctionDecl) + num_params * sizeof(VarDecl*) + rtype.getExtraSize();
    if (prefix) size += sizeof(Ref);
    FunctionDecl* d = c.alloc(size);
    FunctionType* ftype = FunctionType.create(c, d);
    QualType qt = QualType.init(ftype.asType());
    d.parent.init(DeclKind.Function, name, loc, is_public, qt, ast_idx);
    d.parent.functionDeclBits.is_variadic = is_variadic;
    d.parent.functionDeclBits.num_params = num_params;
    d.rt = QualType_Invalid;
    rtype.fill(&d.rtype);
    d.body = nil;
    u8* tail = d.rtype.getPointerAfter();
    if (prefix) {
        d.parent.functionDeclBits.has_prefix = 1;
        string.memcpy(tail, prefix, sizeof(Ref));   // gives c-warning, TODO suppress
        tail += sizeof(Ref);
    }
    if (num_params) {
        string.memcpy(tail, cast<void*>(params), num_params * sizeof(VarDecl*));
    }

#if AstStatistics
    Stats.addDecl(DeclKind.Function, size);
#endif
    return d;
}

public func void FunctionDecl.setBody(FunctionDecl* d, CompoundStmt* body) {
    d.body = body;
}

public func CompoundStmt* FunctionDecl.getBody(const FunctionDecl* d) {
    return d.body;
}

public func void FunctionDecl.setRType(FunctionDecl* d, QualType rt) {
    if (!rt.isVoidType()) d.parent.functionDeclBits.has_return = 1;
    d.rt = rt;
}

public func QualType FunctionDecl.getRType(const FunctionDecl* d) {
    return d.rt;
}

public func bool FunctionDecl.hasReturn(const FunctionDecl* d) {
    return d.parent.functionDeclBits.has_return;
}

public func Decl* FunctionDecl.asDecl(FunctionDecl* d) {
    return &d.parent;
}

public func TypeRef* FunctionDecl.getTypeRef(FunctionDecl* d) {
    return &d.rtype;
}

public func bool FunctionDecl.hasPrefix(const FunctionDecl* d) {
    return d.parent.functionDeclBits.has_prefix;
}

public func Ref* FunctionDecl.getPrefix(const FunctionDecl* d) {
    if (d.hasPrefix()) return d.rtype.getPointerAfter();
    return  nil;
}

public func bool FunctionDecl.isVariadic(const FunctionDecl* d) {
    return d.parent.functionDeclBits.is_variadic;
}

public func u32 FunctionDecl.getNumParams(const FunctionDecl* d) {
    return d.parent.functionDeclBits.num_params;
}

public func VarDecl* FunctionDecl.getParam(const FunctionDecl* d, u32 idx) {
    u8* tail = d.rtype.getPointerAfter();
    if (d.hasPrefix()) tail += sizeof(Ref);
    VarDecl** params = cast<VarDecl**>(tail);
    return params[idx];
}

public func void FunctionDecl.setAttrUnusedParams(FunctionDecl* d) {
    d.parent.functionDeclBits.attr_unused_params = 1;
}

public func void FunctionDecl.setAttrNoReturn(FunctionDecl* d) {
    d.parent.functionDeclBits.attr_noreturn = 1;
}

public func void FunctionDecl.setAttrInline(FunctionDecl* d) {
    d.parent.functionDeclBits.attr_inline = 1;
}

public func void FunctionDecl.setAttrWeak(FunctionDecl* d) {
    d.parent.functionDeclBits.attr_weak = 1;
}

func void FunctionDecl.print(const FunctionDecl* d, string_buffer.Buf* out, u32 indent) {
    bool valid_type = d.parent.qt.isValid();
    d.parent.printKind(out, indent, valid_type);
    if (!valid_type) {
        out.add(" ");
        d.rtype.print(out, true);
    }

    d.parent.printBits(out);

    out.color(col_Attr);
    if (d.parent.functionDeclBits.attr_noreturn) out.add(" noreturn");
    if (d.parent.functionDeclBits.attr_inline) out.add(" inline");
    if (d.parent.functionDeclBits.attr_weak) out.add(" weak");
    if (d.parent.functionDeclBits.has_prefix) out.add(" SF");
    d.parent.printAttrs(out);

    out.add1(' ');
    out.color(col_Value);

    const u8* tail = d.rtype.getPointerAfter();
    if (d.hasPrefix()) {
        const Ref* prefix = cast<Ref*>(tail);
        out.add(prefix.getName());
        out.add1('.');
        tail += sizeof(Ref);
    }
    out.add(d.parent.getName());
    out.add1('\n');

    //d.rtype.print(out, true,);

    VarDecl** params = cast<VarDecl**>(tail);
    for (u32 i=0; i<d.parent.functionDeclBits.num_params; i++) {
        params[i].print(out, indent + 2);
    }
    if (d.body) {
        d.body.print(out, indent + 2);
    }
}

func void FunctionDecl.printType(const FunctionDecl* d, string_buffer.Buf* out) {
    if (d.rt.isValid()) {
        d.rt.print(out);
    } else {
        d.rtype.print(out, true);
    }
    out.add(" (");

    u32 num_params = d.parent.functionDeclBits.num_params;
    const u8* tail = d.rtype.getPointerAfter();
    if (d.hasPrefix()) tail += sizeof(Ref);
    i32 params_offset = d.parent.functionDeclBits.has_prefix ? 1 : 0;
    VarDecl** params = cast<VarDecl**>(tail);
    for (u32 i=0; i<num_params; i++) {
        if (i != 0) out.add(", ");
        params[i].printType(out);
    }

    if (d.parent.functionDeclBits.is_variadic) out.add(", ...");

    out.add1(')');
}


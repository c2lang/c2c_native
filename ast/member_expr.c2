/* Copyright 2022 Bas van den Berg
*/

module ast;

import ast_context;
import string_buffer;
import src_loc local;

public const u32 MemberExprMaxDepth = 7;

public type MemberExprBits struct {
    u32 : NumExprBits;
    u32 kind : 4;   // IdentifierKind
    u32 num_refs : 3;   // Excluding one for Expr* if has_expr
    u32 num_decls : 3;  // how many refs have a decl (from the bottom up), set during analysis
    u32 has_expr : 1;
}

/*
    2 variants: (a.b.c.d..)
    - Pure (a = Identifier, num_refs >= 1
        -> parent.loc is the loc of the rhs (= first ref)
    - Non-Pure (a = Expr, num_refs >= 2)
        -> parent.loc is the loc of the first ref (= lhs)
        u32 locs[num_refs-1]
*/

type MemberRef union {
    u32 name_idx;
    Decl* decl;     // set during analysis
    Expr* expr;     // for first ref in non-pure mode
}

public type MemberExpr struct {
    // Note: loc is that of Member or first ref
    Expr parent;
    MemberRef[0] refs;  // tail-allocated, num_ref times
    // u32[numrefs-1] locs  // tail-allocated
} @(opaque)

// if base == nil, MemberExpr is pure, otherwise non-pure
public func MemberExpr* MemberExpr.create(ast_context.Context* c, Expr* base, const Ref* refs, u32 refcount) {
    u32 size = sizeof(MemberExpr) + refcount * sizeof(MemberRef) + (refcount - 1) * sizeof(u32);
    if (base) size += sizeof(MemberRef);
    size = (size + 7) & ~0x7; // round to 8-byte (temp)

    MemberExpr* e = c.alloc(size);
    e.parent.init(ExprKind.Member, refs[0].loc, 0, 0, 0);
    e.parent.parent.memberExprBits.num_refs = refcount;
    u32 offset = 0;
    if (base) {
        offset = 1;
        e.refs[0].expr = base;
        e.parent.parent.memberExprBits.has_expr = 1;
    }

    for (u32 i=0; i<refcount; i++) {
        e.refs[i+offset].name_idx = refs[i].name_idx;
    }
    SrcLoc* locs = cast<SrcLoc*>(&e.refs[refcount + offset]);
    for (u32 i=0; i<refcount-1; i++) { // first loc already in parent.loc
        locs[i] = refs[i+1].loc;    // shift them all
    }

    e.parent.setLValue();
#if AstStatistics
    Stats.addExpr(ExprKind.Member, size);
#endif
    return e;
}

public func bool MemberExpr.hasExpr(const MemberExpr* e) {
    return e.parent.parent.memberExprBits.has_expr;
}

public func Expr* MemberExpr.getExprBase(const MemberExpr* e) {
    if (e.hasExpr()) return e.refs[0].expr;
    return nil;
}

public func const char* MemberExpr.getName(const MemberExpr* e, u32 ref_idx) {
    const MemberRef* ref = &e.refs[ref_idx + e.hasExpr()];
    if (e.parent.parent.memberExprBits.num_decls > ref_idx) {
        return ref.decl.getName();
    }
    return idx2name(ref.name_idx);
}

public func u32 MemberExpr.getNumRefs(const MemberExpr* e) {
    return e.parent.parent.memberExprBits.num_refs;
}

public func u32 MemberExpr.getNameIdx(const MemberExpr* e, u32 ref_idx) {
    const MemberRef* ref = &e.refs[ref_idx + e.hasExpr()];

    if (e.parent.parent.memberExprBits.num_decls > ref_idx) {
        assert(0);  // TODO
        //return name2idx(ref.decl.getName());
    }
    return ref.name_idx;
}

public func SrcLoc MemberExpr.getLoc(const MemberExpr* e, u32 ref_idx) {
    if (ref_idx == 0) return e.parent.getLoc();

    SrcLoc* locs = cast<SrcLoc*>(&e.refs[e.getNumRefs() + e.hasExpr()]);
    return locs[ref_idx-1];
}

public func IdentifierKind MemberExpr.getKind(const MemberExpr* e) @(inline) {
    return cast<IdentifierKind>(e.parent.parent.memberExprBits.kind);
}

public func void MemberExpr.setKind(MemberExpr* e, IdentifierKind kind) @(inline) {
    e.parent.parent.memberExprBits.kind = kind;
}

// returns the final decl after a.b.c.d <-, must be fully analysed
public func Decl* MemberExpr.getFullDecl(const MemberExpr* e) {
    u32 num = e.getNumRefs();
    if (e.parent.parent.memberExprBits.num_decls < num) return nil;

    num += e.hasExpr();
    return e.refs[num-1].decl;
}

/*
// Note: not used yet
public func Decl* MemberExpr.getDecl(const MemberExpr* e, u32 ref_idx) {
    if (e.parent.parent.memberExprBits.num_decls <= ref_idx) return nil;

    if (e.isSingle()) return e.single.rhs.decl;
    return e.multi.refs[ref_idx].decl;
}
*/

public func void MemberExpr.setDecl(MemberExpr* e, Decl* d, u32 ref_idx) {
    e.parent.parent.memberExprBits.num_decls = ref_idx + 1;

    e.refs[ref_idx+e.hasExpr()].decl = d;
}

func SrcLoc MemberExpr.getStartLoc(const MemberExpr* e) @(inline) {
    if (e.hasExpr()) return e.refs[0].expr.getStartLoc();
    return e.parent.getLoc();
}

public func SrcLoc MemberExpr.getEndLoc(const MemberExpr* e) @(inline) {
    return e.getLoc(e.getNumRefs()-1);
}

func void MemberExpr.print(const MemberExpr* e, string_buffer.Buf* out, u32 indent) {
    e.parent.printKind(out, indent);
    e.parent.printTypeBits(out);
    out.add1(' ');
    IdentifierKind kind = e.getKind();
    if (kind == IdentifierKind.Unresolved) out.color(col_Error);
    else out.color(col_Attr);
    out.add(identifierKind_names[kind]);
    out.color(col_Attr);
    out.print(" refs=%u/%u ", e.parent.parent.memberExprBits.num_decls, e.getNumRefs());
    out.color(col_Value);
    e.printLiteral(out);
    out.add1('\n');
    if (e.hasExpr()) e.refs[0].expr.print(out, indent + 2);
}

func void MemberExpr.printLiteral(const MemberExpr* e, string_buffer.Buf* out) {
    if (e.hasExpr()) {
        out.add("<expr>.");
    }
    for (u32 i=0; i<e.getNumRefs(); i++) {
        if (i != 0) out.add(".");
        out.add(e.getName(i));
    }
}


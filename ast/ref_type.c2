/* Copyright 2022 Bas van den Berg
*/

module ast;

import ast_context;
import string_buffer;

import stdio; // TEMP

public type RefTypeBits struct {
    u32 : NumTypeBits;
    u32 have_prefix : 1;
}

public type RefType struct {
    Type parent;
    IdentifierExpr* ref;
    IdentifierExpr*[0] prefix; // tail-allocated
} @(opaque)

u32 ref_count;

public func RefType* RefType.create(ast_context.Context* c, IdentifierExpr* prefix, IdentifierExpr* ref) @(inline) {
    u32 size = sizeof(RefType);
    if (prefix) size += sizeof(Expr*);
    RefType* t = c.alloc(size);
    t.parent.init(TypeKind.Ref);
    t.ref = ref;

    if (prefix) {
        t.parent.refTypeBits.have_prefix = true;
        t.prefix[0] = prefix;
    }
#if AstStatistics
    stats.refCount++;
    stats.refSize += size;
#endif
    return t;
}

public func IdentifierExpr* RefType.getRef(const RefType* t) @(inline) { return t.ref; }

public func IdentifierExpr** RefType.getRef2(RefType* t) @(inline) { return &t.ref; }

public func IdentifierExpr* RefType.getPrefix(const RefType* t) {
    if (t.parent.refTypeBits.have_prefix) return t.prefix[0];
    return nil;
}

func void RefType.print(const RefType* t, string_buffer.Buf* out) {
    const Decl* d = t.ref.getDecl();
        // TODO add const/volatile flags
    if (d) {
        if (t.parent.refTypeBits.have_prefix) {
            t.prefix[0].printLiteral(out);
            out.add(".");
        }
        out.add(d.getName());
    } else {
        out.color(col_Error);
        if (t.parent.refTypeBits.have_prefix) {
            t.prefix[0].printLiteral(out);
            out.add(".");
        }
        t.ref.printLiteral(out);
        out.color(col_Type);
    }
}

func void RefType.debugPrint(const RefType* t, string_buffer.Buf* out) {
    // TODO
}

public func void RefType.fullPrint(const RefType* t, string_buffer.Buf* out, u32 indent) {
    out.indent(indent);
    out.print("RefType [%p] %s\n", t, t.ref.getName());
    //IdentifierExpr*[0] prefix; // tail-allocated
}

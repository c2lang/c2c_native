/* Copyright 2022 Bas van den Berg
*/

module ast;

import color;
import utils local;
import string_buffer;
import stdio;

public type TypeKind enum u8 {
    Builtin,
    Pointer,
    Array,
    Ref,
    Struct,
    Enum,
    Function,
    // Alias,
    Module,
}

public type TypeBits struct {
    u32 kind : 8;
}
public const u32 NumTypeBits = 8;

public type Type struct {
    union {
        TypeBits typeBits;
        BuiltinTypeBits builtinTypeBits;
        ArrayTypeBits arrayTypeBits;
        RefTypeBits refTypeBits;
        u32 bits;
    }
    QualType canonicalType;
    Type* ptr_type;
} @(opaque)

func void Type.init(Type* t, TypeKind k) @(inline) {
    t.bits = 0;
    t.typeBits.kind = k;
    t.canonicalType.ptr = 0;
    t.ptr_type = nil;
}

// TEMP cast needed until Analyser fixed
public func TypeKind Type.getKind(const Type* t) @(inline) { return cast<TypeKind>(t.typeBits.kind); }

public func QualType Type.getCanonicalType(const Type* t) @(inline) { return t.canonicalType; }
public func void Type.setCanonicalType(Type* t, QualType canon) @(inline) { t.canonicalType = canon; }

public func Type* Type.getPtrType(const Type* t) @(inline) { return t.ptr_type; }
public func void Type.setPtrType(Type* t, Type* pt) @(inline) { t.ptr_type = pt; }

public func ArrayType* Type.asArray(Type* t) {
    if (t.getKind() == TypeKind.Array) return cast<ArrayType*>(t);
    return nil;
}

public func void Type.dump(const Type* t) {
    string_buffer.Buf* out = string_buffer.create(256, utils.useColor());
    t.print(out);
    out.color(color.Normal);
    stdio.printf("%s\n", out.data());
    out.free();
}

func void Type.print(const Type* t, string_buffer.Buf* out) {
    out.color(col_Type);
    switch (t.getKind()) {
    case Builtin:
        BuiltinType.print(cast<BuiltinType*>(t), out);
        break;
    case Pointer:
        PointerType.print(cast<PointerType*>(t), out);
        break;
    case Array:
        ArrayType.print(cast<ArrayType*>(t), out);
        break;
    case Ref:
        RefType.print(cast<RefType*>(t), out);
        break;
    case Struct:
        StructType.print(cast<StructType*>(t), out);
        break;
    case Enum:
        EnumType.print(cast<EnumType*>(t), out);
        break;
    case Function:
        FunctionType.print(cast<FunctionType*>(t), out);
        break;
    case Module:
        ModuleType.print(cast<ModuleType*>(t), out);
        break;
    }
}

func void Type.debugPrint(const Type* t, string_buffer.Buf* out) {
    switch (t.getKind()) {
    case Builtin:
        BuiltinType.debugPrint(cast<BuiltinType*>(t), out);
        break;
    case Pointer:
        PointerType.debugPrint(cast<PointerType*>(t), out);
        break;
    case Array:
        ArrayType.debugPrint(cast<ArrayType*>(t), out);
        break;
    case Ref:
        RefType.debugPrint(cast<RefType*>(t), out);
        break;
    case Struct:
        StructType.debugPrint(cast<StructType*>(t), out);
        break;
    case Enum:
        EnumType.debugPrint(cast<EnumType*>(t), out);
        break;
    case Function:
        FunctionType.debugPrint(cast<FunctionType*>(t), out);
        break;
    case Module:
        ModuleType.debugPrint(cast<ModuleType*>(t), out);
        break;
    }
}

public func void Type.fullPrint(const Type* t, string_buffer.Buf* out, u32 indent) {
    switch (t.getKind()) {
    case Builtin:
        BuiltinType.fullPrint(cast<BuiltinType*>(t), out, indent);
        break;
    case Pointer:
        PointerType.fullPrint(cast<PointerType*>(t), out, indent);
        break;
    case Array:
        ArrayType.fullPrint(cast<ArrayType*>(t), out, indent);
        break;
    case Ref:
        RefType.fullPrint(cast<RefType*>(t), out, indent);
        break;
    case Struct:
        StructType.fullPrint(cast<StructType*>(t), out, indent);
        break;
    case Enum:
        EnumType.fullPrint(cast<EnumType*>(t), out, indent);
        break;
    case Function:
        FunctionType.fullPrint(cast<FunctionType*>(t), out, indent);
        break;
    case Module:
        ModuleType.fullPrint(cast<ModuleType*>(t), out, indent);
        break;
    }
    out.indent(indent);
    out.add("canonical=");
    Type* canon = t.canonicalType.getTypeOrNil();
    if (canon) {
        if (canon == t) {
            out.add("this\n");
        } else {
            out.add("\n");
            canon.fullPrint(out, indent + 2);
        }
    } else {
        out.add("NIL\n");
    }

}


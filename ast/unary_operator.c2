/* Copyright 2022 Bas van den Berg
*/

module ast;

import ast_context;
import string_buffer;
import src_loc local;

public type UnaryOpcode enum u8 {
    PostInc,
    PostDec,
    PreInc,
    PreDec,
    AddrOf,
    Deref,
    Minus,
    Not,
    LNot,
}

const char*[] unaryOpcode_names = {
    "++",
    "--",
    "++",
    "--",
    "&",
    "*",
    "-",
    "~",
    "!",
}

static_assert(elemsof(UnaryOpcode), elemsof(unaryOpcode_names));

public type UnaryOperatorBits struct {
    u32 : NumExprBits;
    u32 kind : 4;
}

public type UnaryOperator struct {
    Expr parent;
    Expr* inner;
} @(opaque)

public func UnaryOperator* UnaryOperator.create(ast_context.Context* c, SrcLoc loc, UnaryOpcode kind, Expr* inner) @(inline) {
    UnaryOperator* e = c.alloc(sizeof(UnaryOperator));
    e.parent.init(ExprKind.UnaryOperator, loc, 0, 0, kind <= UnaryOpcode.PreDec, ValType.RValue);
    e.parent.parent.unaryOperatorBits.kind = kind;
    e.inner = inner;
#if AstStatistics
    Stats.addExpr(ExprKind.UnaryOperator, sizeof(UnaryOperator));
#endif
    return e;
}

func Expr* UnaryOperator.instantiate(UnaryOperator* e, Instantiator* inst) {
    return cast<Expr*>(UnaryOperator.create(inst.c, e.parent.loc, e.getOpcode(), e.inner.instantiate(inst)));
}

public func UnaryOpcode UnaryOperator.getOpcode(const UnaryOperator* e) {
    return cast<UnaryOpcode>(e.parent.parent.unaryOperatorBits.kind);
}

public func Expr* UnaryOperator.getInner(const UnaryOperator* e) { return e.inner; }
public func Expr** UnaryOperator.getInner2(UnaryOperator* e) { return &e.inner; }

public func Expr* UnaryOperator.asExpr(UnaryOperator* e) { return &e.parent; }

public func bool UnaryOperator.isBefore(const UnaryOperator* e) {
    switch (e.getOpcode()) {
    case PostInc: return false;
    case PostDec: return false;
    case PreInc:  return true;
    case PreDec:  return true;
    case AddrOf:  return true;
    case Deref:   return true;
    case Minus:   return true;
    case Not:     return true;
    case LNot:    return true;
    }
    return true;
}

public func SrcLoc UnaryOperator.getStartLoc(const UnaryOperator* e) @(inline) {
    if (e.isBefore()) return e.parent.getLoc();
    return e.inner.getStartLoc();
}

public func SrcLoc UnaryOperator.getEndLoc(const UnaryOperator* e) @(inline) {
    if (e.isBefore()) return e.inner.getStartLoc();
    return e.parent.getLoc();
}

public func const char* UnaryOperator.getOpcodeStr(const UnaryOperator* e) {
    return unaryOpcode_names[e.getOpcode()];
}

func void UnaryOperator.print(const UnaryOperator* e, string_buffer.Buf* out, u32 indent) {
    e.parent.printKind(out, indent);
    e.parent.printTypeBits(out);
    out.add1(' ');
    out.color(col_Value);
    out.add(unaryOpcode_names[e.getOpcode()]);
    out.add1('\n');
    e.inner.print(out, indent + 1);
}

func void UnaryOperator.printLiteral(const UnaryOperator* e, string_buffer.Buf* out) {
    const char* opcode = unaryOpcode_names[e.getOpcode()];
    if (e.isBefore()) {
        out.add(opcode);
        e.inner.printLiteral(out);
    } else {
        e.inner.printLiteral(out);
        out.add(opcode);
    }
}


/* Copyright 2022 Bas van den Berg
*/

module ast;

import color;
import ast_context local;

import stdlib;
import string;
#if AstStatistics
import stdio;
#endif

static_assert(24, sizeof(Decl));
static_assert(32, sizeof(AliasTypeDecl));
static_assert(32, sizeof(EnumConstantDecl));
static_assert(32, sizeof(EnumTypeDecl));
static_assert(32, sizeof(FunctionTypeDecl));
static_assert(32, sizeof(VarDecl));
static_assert(48, sizeof(FunctionDecl));
static_assert(40, sizeof(ImportDecl));
static_assert(40, sizeof(StaticAssertDecl));
static_assert(40, sizeof(StructTypeDecl));

static_assert(4, sizeof(Stmt));
static_assert(16, sizeof(AssertStmt));
static_assert(16, sizeof(CaseStmt));
static_assert(16, sizeof(DeclStmt));
static_assert(12, sizeof(GotoStmt));
static_assert(12, sizeof(LabelStmt));
static_assert(16, sizeof(SwitchStmt));
static_assert(24, sizeof(DoStmt));
static_assert(24, sizeof(IfStmt));
static_assert(24, sizeof(WhileStmt));
static_assert(40, sizeof(ForStmt));
static_assert(8, sizeof(BreakStmt));
static_assert(8, sizeof(CompoundStmt));
static_assert(8, sizeof(ContinueStmt));
static_assert(8, sizeof(DefaultStmt));
static_assert(8, sizeof(FallthroughStmt));
static_assert(8, sizeof(ReturnStmt));

static_assert(16, sizeof(Expr));
static_assert(16, sizeof(BooleanLiteral));
static_assert(16, sizeof(CharLiteral));
static_assert(16, sizeof(NilExpr));
static_assert(24, sizeof(CallExpr));
static_assert(24, sizeof(IdentifierExpr));
static_assert(24, sizeof(ImplicitCastExpr));
static_assert(24, sizeof(InitListExpr));
static_assert(24, sizeof(IntegerLiteral));
static_assert(24, sizeof(ParenExpr));
static_assert(24, sizeof(StringLiteral));
static_assert(24, sizeof(UnaryOperator));
static_assert(32, sizeof(ArrayDesignatedInitExpr));
static_assert(32, sizeof(ArraySubscriptExpr));
static_assert(32, sizeof(BinaryOperator));
static_assert(32, sizeof(BitOffsetExpr));
static_assert(32, sizeof(BuiltinExpr));
static_assert(32, sizeof(ExplicitCastExpr));
static_assert(32, sizeof(FieldDesignatedInitExpr));
static_assert(32, sizeof(MemberExpr));
static_assert(24, sizeof(TypeExpr));
static_assert(48, sizeof(ConditionalOperator));

static_assert(8, sizeof(QualType));
static_assert(16, sizeof(Type));
static_assert(16, sizeof(BuiltinType));
static_assert(24, sizeof(PointerType));
static_assert(32, sizeof(ArrayType));
static_assert(24, sizeof(StructType));
static_assert(24, sizeof(EnumType));
static_assert(24, sizeof(FunctionType));

static_assert(8, sizeof(TypeRef));

// TODO use array with BuiltinTypeKind as index (less globals)
public QualType g_u8;
public QualType g_u16;
public QualType g_u32;
public QualType g_u64;
public QualType g_i8;
public QualType g_i16;
public QualType g_i32;
public QualType g_i64;
public QualType g_f32;
public QualType g_f64;
public QualType g_isize;
public QualType g_usize;
public QualType g_void;
public QualType g_bool;
public QualType g_void_ptr; //used to init NilExpr

const char* g_names_start;

TypePool g_types;

// TODO just use AST vector (also in modules, but modules has ownership)
AST** g_ast_list;
u32 ast_count;      // Note: first index used to indicate nil
u32 ast_capacity;

public func void init(Context* c, const char* names_start) {
    stats.reset();
    g_types.init(c);

    g_u8.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.UInt8)));
    g_u16.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.UInt16)));
    g_u32.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.UInt32)));
    g_u64.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.UInt64)));
    g_i8.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.Int8)));
    g_i16.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.Int16)));
    g_i32.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.Int32)));
    g_i64.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.Int64)));
    g_f32.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.Float32)));
    g_f64.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.Float64)));
    g_isize.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.Int64)));
    g_usize.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.UInt64)));
    g_void.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.Void)));
    g_bool.set(cast<Type*>(BuiltinType.create(c, BuiltinTypeKind.Bool)));

    Type* void_ptr = ast.getPointerType(g_void);
    g_void_ptr.set(void_ptr);
    void_ptr.setCanonicalType(g_void_ptr);

    g_names_start = names_start;
    ast_count = 1;
    ast_capacity = 0;
    g_ast_list = nil;
}

public func void deinit() {
#if AstStatistics
    stats.dump();
#endif
    stdlib.free(cast<void*>(g_ast_list));
    g_types.clear();
}

public func const char* idx2name(u32 idx) {
    // TODO just keep pointer to string_pool. That way it can resize!
    if (idx) return g_names_start + idx;
    return nil;
}

public func Type* getPointerType(QualType inner) {
    return g_types.getPointerType(inner);
}

func u32 addAST(AST* ast_) {

    if (ast_count >= ast_capacity) {
        if (ast_capacity == 0) ast_capacity = 16;
        else ast_capacity *= 2;

        void* buf = stdlib.malloc(ast_capacity * sizeof(ast.AST*));
        if (g_ast_list) {
            void* old = cast<void*>(g_ast_list);
            string.memcpy(buf, old, ast_count * sizeof(ast.AST*));
            stdlib.free(old);
        }
        g_ast_list = buf;
    }

    u32 idx = ast_count;
    g_ast_list[idx] = ast_;
    ast_count++;
    return idx;
}

public func u32 ast2idx(const AST* ast_) {
    if (ast_) return ast_.idx;
    return 0;
}

public func AST* idx2ast(u32 idx) {
    if (idx == 0) return nil;
    return g_ast_list[idx];
}

const char* col_Stmt = color.Bmagenta;
const char* col_Decl = color.Bgreen;
const char* col_Expr = color.Bmagenta;
const char* col_Attr = color.Blue;
const char* col_Cast = color.Red;
const char* col_Type = color.Green;
const char* col_Value = color.Bcyan;
const char* col_Error = color.Red;
const char* col_Attributes = color.Yellow;
const char* col_Normal = color.Normal;

#if AstStatistics
type AstStats struct {
    // Types
    u32 typeCount;
    u32 pointerCount;
    u32 aliasCount;
    u32 builtinCount;
    u32 enumCount;
    u32 arrayCount;
    u32 functionTypeCount;
    u32 structCount;
    u32 moduleCount;

    u32 arraySize;
}

func void AstStats.reset(AstStats* s) {
    string.memset(s, 0, sizeof(AstStats));
}

func void AstStats.dump(const AstStats* s) {
    stdio.printf("AST: Types\n");
    u32 total = 0;
    total += stats.pointerCount * sizeof(PointerType);
    total += stats.functionTypeCount * sizeof(FunctionType);
    total += stats.moduleCount * sizeof(ModuleType);
    total += stats.structCount * sizeof(StructType);
    total += stats.arraySize;
    total += stats.enumCount * sizeof(EnumType);
    total += stats.aliasCount * sizeof(AliasType);
    total += stats.builtinCount * sizeof(BuiltinType);
    // TODO count tail-allocators as wel (need total count in create functions)
    stdio.printf("   types      %5u   %6u\n", stats.typeCount, total);
    stdio.printf("   function   %5u   %6u\n", stats.functionTypeCount, stats.functionTypeCount * sizeof(FunctionType));
    stdio.printf("   pointers   %5u   %6u\n", stats.pointerCount, stats.pointerCount * sizeof(PointerType));
    stdio.printf("   modules    %5u   %6u\n", stats.moduleCount, stats.moduleCount * sizeof(ModuleType));
    stdio.printf("   structs    %5u   %6u\n", stats.structCount, stats.structCount * sizeof(StructType));
    stdio.printf("   array      %5u   %6u\n", stats.arrayCount, stats.arraySize);
    stdio.printf("   enum       %5u   %6u\n", stats.enumCount, stats.enumCount * sizeof(EnumType));
    stdio.printf("   alias      %5u   %6u\n", stats.aliasCount, stats.aliasCount * sizeof(AliasType));
    stdio.printf("   builtins   %5u   %6u\n", stats.builtinCount, stats.builtinCount * sizeof(BuiltinType));
}

AstStats stats;
#endif

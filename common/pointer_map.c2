/* Copyright 2022 Bas van den Berg
*/
module pointer_map;

import stdio;
import stdlib;

// 64 also seems optimal for lineair search
// 128 seems good for binary search inside block
const u32 BlockSize = 128;

public type Block struct {
    usize[BlockSize] keys;
    usize[BlockSize] values;
    u32 count;
    Block* next;
} @(opaque)

func Block* Block.create() {
    Block* b = stdlib.malloc(sizeof(Block));
    b.count = 0;
    b.next = nil;
    return b;
}

public type Map struct {
    Block* head;
    Block* tail;
    usize last;
}

public func void Map.init(Map* m) {
    m.head = Block.create();
    m.tail = m.head;
    m.last = 0;
}

func void Map.free(Map* m) {
    Block* b = m.head;
    while (b) {
        Block* cur = b;
        b = b.next;
        stdlib.free(cur);
    }
}

// NOTE: must always be inserted in order
public func void Map.add(Map* m, usize key, usize value) {
    if (key < m.last) {
        stdio.fprintf(stdio.stderr, "pointer_map: ENTRY SMALLER\n");
        stdlib.exit(-1);
    }
    m.last = key;

    Block* b = m.tail;
    if (b.count == BlockSize) {
        Block* b2 = Block.create();
        b.next = b2;
        m.tail = b2;
        b = b2;
    }

    b.keys[b.count] = key;
    b.values[b.count] = value;
    b.count++;
}

// return value 0 means key not found
public func usize Map.find(Map* m, usize value) {
    // check block first/last, binary inside block
    const Block* b = m.head;
    while (b) {
        const u32 count = b.count;
        // find block
        if (value > b.keys[count-1]) {
            b = b.next;
            continue;
        }
        if (value < b.keys[0]) return 0;
        // search inside block
        u32 left = 0;
        u32 right = count;
        while (left != right) {
            u32 middle = (left + right) / 2;
            if (value < b.keys[middle]) {
                right = middle;
                continue;
            }
            if (value > b.keys[middle]) {
                left = middle;
                continue;
            }
            return b.values[middle];
        }
        return 0;
    }
    return 0;
}


/* Copyright 2022 Bas van den Berg
*/

module string_buffer;

import stdarg local;
import stdlib local;
import string local;

public type Buf struct {
    u32 capacity;
    u32 size_;
    char* data_;
    bool colors;
}

static_assert(24, sizeof(Buf));

public func Buf* create(u32 capacity, bool colors = true)
{
    Buf* buf = malloc(sizeof(Buf));
    buf.capacity = capacity;
    buf.size_ = 0;
    buf.data_ = malloc(capacity);
    buf.colors = colors;
    return buf;
}

public func void Buf.free(Buf* buf)
{
    free(buf.data_);
    free(buf);
}

public func u32 Buf.size(const Buf* buf)
{
    return buf.size_;
}

public func const char* Buf.data(const Buf* buf)
{
    return buf.data_;
}

public func void Buf.clear(Buf* buf)
{
    buf.size_ = 0;
}

public func void Buf.color(Buf* buf, const char* color) {
    if (!buf.colors) return;

    u32 len = cast<u32>(strlen(color));
    buf.add2(color, len);
}

public func void Buf.add(Buf* buf, const char* text)
{
    u32 len = cast<u32>(strlen(text));
    buf.add2(text, len);
}

// len = strlen(text)
public func void Buf.add2(Buf* buf, const char* text, u32 len) @(inline)
{
    if (buf.size_ + len + 1 > buf.capacity) {
        u32 new_cap = buf.capacity * 2;
        while (buf.size_ + len + 1 > new_cap) new_cap *= 2;
        buf.resize(new_cap);
    }
    strcpy(&buf.data_[buf.size_], text);
    buf.size_ += len;
    buf.data_[buf.size_] = 0;
}

public func void Buf.print(Buf* buf, const char* format, ...) {
    char[256] tmp;
    // NOTE: no growing
    Va_list args;
    va_start(args, format);
    i32 len = vsprintf(tmp, format, args);
    buf.add2(tmp, cast<u32>(len));
    va_end(args);
}

public func void Buf.indent(Buf* buf, u32 indent) {
    if (buf.size_ + indent + 1 > buf.capacity) {
        buf.resize(buf.capacity * 2);
    }

    char* cur = buf.data_ + buf.size_;
    memset(cur, ' ', indent);
    cur[indent] = 0;
    buf.size_ += indent;
}

func void Buf.resize(Buf* buf, u32 capacity) {
    buf.capacity = capacity;
    //if ((len + 1) >= (newcap - buf.size_)) newcap += buf.size_ + len + 1;
    char* data2 = malloc(buf.capacity);
    memcpy(data2, buf.data_, buf.size_);
    free(buf.data_);
    buf.data_ = data2;
}

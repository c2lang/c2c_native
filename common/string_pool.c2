module string_pool;

import string;
import stdlib;
import stdio;

/*
    Make Nodes resizable (start at 2000)
    Make data resizable?
        . can we put blocks underneath (block vector, each 16Kb)
*/

type Color enum u8 { Black, Red }
type Dir enum u8 { Left, Right }

type Node struct {
    u16[2] child;
    u32 word_idx;
    u16 parent;
    Color color;
}

public type Pool struct {
    u32 size; // rename dataSize
    u32 data_capacity;
    char* data;
    Node* nodes;
    u16 node_capacity;
    u16 node_count;
    Node* root;
} @(opaque)

public func Pool* Pool.create(u32 data_capacity, u16 node_capacity) {
    Pool* p = stdlib.calloc(1, sizeof(Pool));
    //p.size = 1; // skip first to mark as unused, still needed?
    p.data_capacity = data_capacity;
    p.node_capacity = node_capacity;
    p.data = stdlib.malloc(p.data_capacity);
    p.nodes = stdlib.malloc(p.node_capacity * sizeof(Node));
    p.node_count = 1; // skip node 1
    return p;
}

public func void Pool.free(Pool* p) {
    stdlib.free(p.data);
    stdlib.free(p.nodes);
    stdlib.free(p);
}

func Node* Pool.getChild(Pool* pool, Node* x, Dir dir) @(inline) {
    // assert(x);
    u16 idx = x.child[dir];
    if (idx) return pool.nodes + idx;
    return nil;
}

func u16 Pool.toIndex(Pool* pool, Node* x) @(inline) {
    return cast<u16>(x - pool.nodes);
}

func void Pool.rotate(Pool* pool, Node* p, Dir dir) {
    Dir rdir = 1-dir;
    u16 g = p.parent;
    u16 s = p.child[rdir];
    u16 c = pool.nodes[s].child[dir];
    p.child[rdir] = c;
    u16 p_idx = pool.toIndex(p);
    if (c) pool.nodes[c].parent = p_idx;
    pool.nodes[s].child[dir] = p_idx;
    p.parent = s;
    pool.nodes[s].parent = g;
    if (g) {
        pool.nodes[g].child[p_idx == pool.nodes[g].child[Dir.Right] ? Dir.Right : Dir.Left] = s;
    } else {
        pool.root = &pool.nodes[s];
    }
}

func void Pool.insert(Pool* pool, Node* n, Node* p) {
    n.color = Color.Red;
    // Note left+right+ parent already set

    if (p == nil) {
        pool.root = n;
        return;
    }
    //p.child[dir] = n; . already done

    Node* g;
    Dir dir;
    Dir rdir;
    do {
        if (p.color == Color.Black) return;  // case I1 (P black);

        // From now on P is red
        if (p.parent == 0) goto Case_I4;

        g = pool.nodes + p.parent;
        dir = (p == (pool.nodes + g.child[Dir.Right])) ? Dir.Right : Dir.Left; // the side of parent G on which node P is located
        rdir = 1-dir;
        u16 u_idx = g.child[rdir]; // uncle
        if (u_idx == 0) goto Case_I56;
        Node* u = pool.nodes + u_idx;
        if (u.color == Color.Black) goto Case_I56;

        // Case_I2 (P+U red):
        p.color = Color.Black;
        u.color = Color.Black;
        g.color = Color.Red;
        n = g;  // new current node;
        // iterate 1 black level higher (= 2 tree levels)

        if (n.parent == 0) break;
        p = pool.nodes + n.parent;
    } while (1);

    // Case_I3: N is the root and red
    return;
Case_I4:
    p.color = Color.Black;
    return;
Case_I56:
    if (n == pool.getChild(p, rdir)) {
        // Case-I5 (P red && U black && N inner grandchild of G):
        pool.rotate(p, dir);
        n = p;   // new current node
        p = pool.nodes + g.child[dir]; // new parent of N
        //fall through to Case_I6
    }
    // Case_I6 (P red && U black && N outer grandchild of G):
    pool.rotate(g, rdir); // G may be the root
    p.color = Color.Black;
    g.color = Color.Red;
    return;
}

public func const char* Pool.add(Pool* pool, const char* text, usize len, bool filter) {
    if (filter) {
        Node* n = pool.root;
        Dir dir = Dir.Left;
        while (n) {
            const char* word = pool.data + n.word_idx;
            // NOTE: strcmp seems a bit faster than memcmp!!
            //i32 result = string.strcmp(word, text);
            i32 result = string.memcmp(word, text, len);
            if (result > 0) {
                if (n.child[Dir.Left]) {
                    n = pool.nodes + n.child[Dir.Left];
                    continue;
                } else {
                    n.child[Dir.Left] = pool.node_count;
                    break;
                }
            }
            if (result < 0) {
                if (n.child[Dir.Right]) {
                    n = pool.nodes + n.child[Dir.Right];
                    continue;
                } else {
                    n.child[Dir.Right] = pool.node_count;
                    break;
                }
            }
            return word;
        }
        Node* parent = n;
        u16 parent_idx = cast<u16>(n ? cast<u16>(n - pool.nodes) : 0);
        // fill new node
        //assert(pool.node_count < pool.node_capacity);
        n = pool.nodes + pool.node_count;
        n.parent = parent_idx;
        pool.node_count++;
        n.word_idx = pool.size;
        n.child[Dir.Left] = 0;
        n.child[Dir.Right] = 0;

        pool.insert(n, parent);
    }

    char* dest = pool.data + pool.size;
    pool.size += len;
    //assert(pool.size < pool.data_capacity);
    string.memcpy(dest, text, len);
    return dest;
}

#if 0
func u32 tree_size(const Node* n) {
    u32 size = 1;
    if (n.child[Dir.Left]) size += tree_size(pool.nodes + n.child[Dir.Left]);
    if (n.child[Dir.Right]) size += tree_size(pool.nodes + n.child[Dir.Right]);
    return size;
}

static void iterate(const Node* n) {
    if (n.child[Dir.Left]) iterate(pool.nodes + n.child[Dir.Left]);
    printf("%s\n", pool.data + n.word_idx);
    if (n.child[Dir.Right]) iterate(pool.nodes + n.child[Dir.Right]);
}

#define LINE_LEN 200
#define NUM_LINES 40
static char lines[NUM_LINES][LINE_LEN];
static u32 max_depth = 1;

static void find_depth(const Node* n, u32 depth) {
    if (depth > max_depth) max_depth = depth;
    if (n.child[Dir.Left]) find_depth(pool.nodes + n.child[Dir.Left], depth + 1);
    if (n.child[Dir.Right]) find_depth(pool.nodes + n.child[Dir.Right], depth + 1);
}

static void print2(const Node* n, u32 depth, u32 center) {
    lines[depth][center] = 'X';
    if (n.child[Dir.Left]) print2(pool.nodes + n.child[Dir.Left], depth + 1, (center + 2)/ 2);
    if (n.child[Dir.Right]) print2(pool.nodes + n.child[Dir.Right], depth + 1, (LINE_LEN + center - 3) / 2);
}

static void nice_print(void) {
    if (pool.root) find_depth(pool.root, 1);
    printf("Max depth: %u\n", max_depth);

    memset(lines, ' ', sizeof(lines));
    for (u32 i=0; i<NUM_LINES; i++) {
        lines[i][LINE_LEN-1] = 0;
        lines[i][LINE_LEN-2] = '|';
        sprintf(lines[i], "%02d", i+1);
        lines[i][2] = ' ';
    }
    if (pool.root) print2(pool.root, 0, LINE_LEN / 2);
    for (u32 i=0; i<max_depth; i++) {
        printf("%s\n", lines[i]);
    }
}
#endif

public func void Pool.dump(const Pool* pool) {
    stdio.printf("Pool: %u words, data %u bytes\n", pool.node_count - 1, pool.size);
    u32 index_size =  pool.node_count * sizeof(Node);
    stdio.printf("Pool: index size %u, total size %u\n", index_size, index_size + pool.size);
    //if (pool.root) iterate(pool.root);
    //nice_print();
}


/* Copyright 2022 Bas van den Berg
*/

module utils;
import stdlib local;
import string local;

const u32 BufferCap = 4096-(sizeof(void*)+sizeof(u32));
type Buffer struct {
    Buffer* next;
    u32 size;
    char[BufferCap] data;
}

static_assert(4096, sizeof(Buffer));

func Buffer* Buffer.create() {
    Buffer* b = malloc(sizeof(Buffer));
    b.next = nil;
    b.size = 0;
    b.data[0] = 0;
    return b;
}

func u32 Buffer.capacity(const Buffer* b) {
    return BufferCap - b.size;
}

func char* Buffer.alloc(Buffer* b, u32 len) {
    // NOTE: capacity already checked
    char* start = &b.data[b.size];
    b.size += len;
    return start;
}


public type StringPool struct {
    Buffer* head;
    Buffer* tail;
} @(opaque)

public func StringPool* StringPool.create() {
    StringPool* p = calloc(1, sizeof(StringPool));
    return p;
}

public func void StringPool.destroy(StringPool* p) {
    Buffer* cur = p.head;
    while (cur) {
        Buffer* next = cur.next;
        free(cur);
        cur = next;
    }
    free(p);
}

public func char* StringPool.alloc_mem(StringPool* p, u32 len) {
    // NOTE: assume size < BufferCap
    if (!p.tail) {
        p.head = Buffer.create();
        p.tail = p.head;
    }
    Buffer* b = p.tail;
    if (b.capacity() < len) {
        b = Buffer.create();
        p.tail.next = b;
        p.tail = b;
    }
    return b.alloc(len);
}

public func char* StringPool.alloc_str(StringPool* p, const char* input) {
    u32 len = cast<u32>(strlen(input)) + 1;
    char* data = p.alloc_mem(len);
    memcpy(data, input, len);
    return data;
}


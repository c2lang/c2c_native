/* Copyright 2022 Bas van den Berg
*/

module yaml;
import stdio local;
import string local;

public func void Parser.dump(const Parser* p, bool verbose = false) {
    p.data.dump(verbose);
}

func void Data.dump(const Data* d, bool verbose) {
    u32 node_count = cast<u32>(d.nodes_cur - d.nodes);
    if (verbose) {
        printf("Text %d/%u\n", cast<u32>(d.text_cur - d.text), d.text_size);
        const char* cp = d.text + 1;
        while (cp < d.text_cur) {
            u32 len = cast<u32>(strlen(cp));
            u32 offset = cast<u32>(cp - d.text);
            printf("  [%3u] %s\n", offset, cp);
            cp += len + 1;
        }

        printf("Nodes %u/%u\n", node_count, d.nodes_count);
        for (u32 i=1; i<node_count; i++) {
            const Node* n = &d.nodes[i];
            printf("  [%2u] %s  next %3u  name %3u  value/child %3u\n", i, node_names[n.kind], n.next_idx, n.name_idx, n.text_idx);
        }
    }

    if (node_count > 1) d.dump_node(&d.nodes[1], 0);
}

func Node* Data.idx2node(const Data* d, u32 idx) {
    return &d.nodes[idx];
}

func void Data.dump_node(const Data* d, const Node* n, i32 indent) {
    // TEMP crude way
    for (i32 i=0; i<indent; i++) printf("   ");

    printf("[%2u] %s", d.node2idx(n), node_names[n.kind]);
    printf("  name: ");
    if (n.name_idx) printf("%s", &d.text[n.name_idx]);
    else printf("-");
    printf("  value: ");
    switch (n.kind) {
    case NodeKind.Unknown:
        printf("-\n");
        break;
    case NodeKind.Scalar:
        if (n.text_idx) printf("%s", &d.text[n.text_idx]);
        printf("\n");
        break;
    case NodeKind.Map: fallthrough;
    case NodeKind.Sequence:
        printf("-\n");
        if (n.child_idx) d.dump_node(d.idx2node(n.child_idx), indent+1);
        break;
    }

    if (n.next_idx) {
        d.dump_node(d.idx2node(n.next_idx), indent);
    }
}


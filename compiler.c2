/* Copyright 2022 Bas van den Berg
*/

module compiler;

import ast;
import ast_builder;
import ast_context;
import c2_parser;
import c2recipe;
import component;
import constants;
import manifest;
import module_list;
import module_sorter;
import source_mgr;
import string_list;
import string_pool;
import utils;

import string;
// for sort
import color;
import stdlib;

import stdio local;

// TODO or return/add Component?
func void parseLib(source_mgr.SourceMgr* sm,
                   string_pool.Pool* auxPool,
                   string_pool.Pool* astPool,
                   component.Component* comp)
{
    const char* libdir = stdlib.getenv("C2_LIBDIR");
    if (!libdir) printf("Warning: environment variable C2_LIBDIR not set!\n");

    char[512] manifestFilename;
    i32 len = stdio.sprintf(manifestFilename, "%s/%s/manifest.yml", libdir, comp.getName());
    const char* name = auxPool.add(manifestFilename, cast<usize>(len), 0);

    i32 file_id = sm.open(name, 0);
    if (file_id == -1) return;
    // TODO fill component with stuff from manifest
    //if (!recipe.parseYaml(file_id)) return;
    // NOTE: dont parse modules (interface files) yet, only if needed
    // TODO erro handling
    manifest.parse(sm, file_id, astPool, comp);
}

func void Compiler.handleImport(void* arg, ast.ImportDecl* d) {
    Compiler* c = arg;

    const char* name = d.asDecl().getName();
    ast.Module* m = c.globalList.find(name);
    if (m) {
        d.setModule(m);
    } else {
        fprintf(stderr, "Error: Unknown module '%s'\n", name);
        stdlib.exit(-1);
    }
}

type Compiler struct {
    string_pool.Pool* auxPool;   // no ownership
    source_mgr.SourceMgr* sm;    // no ownership
    const c2recipe.Target* target;     // no ownership
    const Options* opts;        // no ownership

    // TODO: extract this to a Context? and pass that around? (container only)
    ast_context.Context* context;
    string_pool.Pool* astPool;
    ast_builder.Builder* builder;
    module_list.ModList* globalList;
    component.Component* mainComp;  // no ownership

    component.Component** components;
    u32 num_components;
    u32 max_components;
}

public type Options struct {
    bool print_ast;
}

public func void build(string_pool.Pool* auxPool,
                       source_mgr.SourceMgr* sm,
                       c2recipe.Target* target,
                       const Options* opts)
{
    Compiler c;
    c.init(auxPool, sm, target, opts);
    //c.build();
    c.free();
}

func void Compiler.init(Compiler* c,
                        string_pool.Pool* auxPool,
                        source_mgr.SourceMgr* sm,
                        c2recipe.Target* target,
                        const Options* opts)
{
    string.memset(c, 0, sizeof(Compiler));
    c.auxPool = auxPool;
    c.sm = sm;
    c.target = target;
    c.opts = opts;

    c.context = ast_context.create(16*1024);
    c.astPool = string_pool.create(1024*1024, 2048);
    c.builder = ast_builder.create(c.context);
    c.globalList = module_list.create(false);
    c.resizeComponents(4);

    ast.init(c.context, c.astPool.getStart());

    component.Component* libcComponent = component.create(c.globalList, "libc");
    c.addComponent(libcComponent);
    c.builder.setComponent(libcComponent);
    // TODO parse manifest
    // NOTE: HMM manifest filename should go into auxPool, module-names into normal astPool
    parseLib(sm, auxPool, c.astPool, libcComponent);

    c.mainComp = component.create(c.globalList, "main");
    c.addComponent(c.mainComp);
    c.builder.setComponent(c.mainComp);

    // TODO get from recipe/target
    // TODO dynamic sizing
    string_list.List features;
    features.init(64);
    features.add("feature_a");

    printf("%sparsing %s%s\n", color.Yellow, target.getName(), color.Normal);
    u64 total_time = 0;
    for (u32 j=0; j<target.numFiles(); j++) {
        i32 file_id = target.openFile(j);
        if (file_id == -1) return;   // note: error already printed

        const char* filename = sm.getFileName(file_id);
        //printf("parsing %s\n", filename);

        c2_parser.Parser* parser = c2_parser.create(sm, file_id, c.builder, c.astPool, &features, false);
        u64 t1 = utils.now();
        bool ok = parser.parse();
        u64 t2 = utils.now();
        total_time += (t2 - t1);
        //printf("parsing %s took %lu usec\n", sm.getFileName(file_id), t2 - t1);

        parser.free();
    }
    printf("parsing took %lu usec\n", total_time);
#if DumpTokens
#else
    c.context.dump();
    c.astPool.dump();
#endif

#if 0
    for (u32 i=0; i<c.num_components; i++) {
        c.components[i].info();
    }
#endif

    // step 1: resolve imports
    printf("%sresolve imports%s\n", color.Yellow, color.Normal);
    // TODO change to visitModules and then call visitImports on modules? (otherwise big api in components)
    c.mainComp.visitImports(Compiler.handleImport, c);

    // step 2: sort modules inside main component
    module_sorter.sort(c.mainComp);

    // analyse each module, all files in it step by step

    c.mainComp.visitModules(Compiler.analyseModule, c);

    // check unused

    if (c.opts.print_ast) c.mainComp.print();

}

func void Compiler.free(Compiler* c) {
    for (u32 i=0; i<c.num_components; i++) {
        c.components[i].free();
    }
    c.globalList.free();
    c.builder.free();
    c.astPool.free();
    c.context.free();
}

func void Compiler.resizeComponents(Compiler* c, u32 capacity) {
    c.max_components = capacity;
    component.Component** comps2 = stdlib.malloc(c.max_components * sizeof(component.Component*));
    if (c.components) {
        string.memcpy(cast<void*>(comps2), cast<void*>(c.components), c.num_components * sizeof(component.Component*));
        stdlib.free(cast<void*>(c.components));
    }
    c.components = comps2;
}

func void Compiler.addComponent(Compiler* c, component.Component* comp) {
    if (c.num_components == c.max_components) c.resizeComponents(c.max_components * 2);

    c.components[c.num_components] = comp;
    c.num_components++;
}

func void Compiler.analyseModule(void* arg, ast.Module* m) {
    // TODO move this to ModuleAnalyser? (so Compiler doesn't have to know ast)

    Compiler* c = arg;
    printf("analysing module %s\n", m.getName());
    // TODO do we now which Component? (otherwise make small struct with Component and Compiler)

    // NOTE: C2C ModuleAnalyser::step1()
    // step 3a: collect incremental arrays
    // TODO use visitIncrArrays()
    // step 3b: collect struct functions
    // TODO use visitStructFunctions();
    m.visitStructFunctions(Compiler.handleStructFunc, c);

    // NOTE: C2C ModuleAnalyser::step2()
    // analyse types
    // analyse vars
    // analyse static asserts
    // analyse function protos

    // NOTE: C2C ModuleAnalyser::step3()
    // analyse functionbodies
}

func void Compiler.handleStructFunc(void* arg, ast.FunctionDecl* d) {
    Compiler* c = arg;
    ast.IdentifierExpr* prefix = d.getPrefix();
    const char* prefix_name = prefix.getName();
    // assert(prefix)
    printf("  %s %s\n", prefix_name, d.asDecl().getName());
    //d.asDecl().dump();

    /*
        TODO we need to put this inside ModuleAnalyser, so it knows which Module we are working on
        TODO also since we do symbol lookup, create Scope for Module?
            -> could be duplicates with 'local imported' modules, so need smart Scope

        search prefix_name in vector, compare by pointer
        if (found) {
            // TypeDecl already found, get it from 2nd vector
        } else {
            search Scope for prefix_name (not only TypeDecls!)
            search TypeDecl, check if struct/union
            add to data-structure.
        }
        add FunctionDecl in another vector with same index as name vector
            check for duplicate names
        set Decl inside (IdentifierExpr) prefix
    */
}

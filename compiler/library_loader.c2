/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module library_loader;

import ast;
import ast_builder;
import ast_context;
import c2_parser;
import color;
import component;
import console;
import constants;
import manifest;
import module_list;
import source_mgr;
import string_buffer;
import string_list;
import string_pool;

import c_errno local;
import libc_dirent local;
import stdio;
import stdlib;
import string;
import sys_stat local;

public type Loader struct {
    source_mgr.SourceMgr* sm;   // no ownership
    ast_context.Context* context; // no ownership
    component.List* components; // no ownership
    module_list.List* modules;   // no ownership
    string_pool.Pool* auxPool;  // no ownership
    string_pool.Pool* astPool;  // no ownership
    c2_parser.Parser* parser;   // no ownership
    ast_builder.Builder* builder;   // no ownership

    string_list.List dirs;
    component.Component* c; // only set during load()
} @(opaque)

public func Loader* create(source_mgr.SourceMgr* sm,
                           ast_context.Context* context,
                           component.List* components,
                           module_list.List* modules,
                           string_pool.Pool* auxPool,
                           string_pool.Pool* astPool,
                           c2_parser.Parser* parser,
                           ast_builder.Builder* builder)
{
    Loader* l = stdlib.calloc(1, sizeof(Loader));
    l.sm = sm;
    l.context = context;
    l.components = components;
    l.modules = modules;
    l.auxPool = auxPool;
    l.astPool = astPool;
    l.parser = parser;
    l.builder = builder;

    l.dirs.init(auxPool);
    return l;
}

public func void Loader.free(Loader* l) {
    l.dirs.free();
    stdlib.free(l);
}

public func void Loader.addDir(Loader* l, u32 dirname) {
    l.dirs.add(dirname);
}

// reads the manifest, creates the Component and (empty) Modules
public func void Loader.open(Loader* l, u32 libname) {
    const char* libstr = l.auxPool.idx2str(libname);
    char[512] libdir;
    if (!l.find_lib(libstr, libdir)) {
        console.error("cannot find library '%s'", libstr);
        stdlib.exit(-1);
    }

    char[512] fullname;
    stdio.sprintf(fullname, "%s/%s", libdir, constants.manifest_name);
    u32 filename_idx = l.auxPool.addStr(fullname, false);
    i32 file_id = l.sm.open(filename_idx, 0, false);
    if (file_id == -1) return;

    u32 dirname_idx = l.auxPool.addStr(libdir, false);

    component.Component* comp = component.create(l.context, l.auxPool, l.modules, libname, dirname_idx, true);
    manifest.parse(l.sm, file_id, l.astPool, comp);
    l.components.add(comp);

    l.sm.close(file_id);
}

func bool Loader.find_lib(const Loader* l, const char* libname, char* fullpath) {
    for (u32 i=0; i<l.dirs.length(); i++) {
        const char* dirname = l.dirs.get(i);
        stdio.sprintf(fullpath, "%s/%s/%s", dirname, libname, constants.manifest_name);

        Stat statbuf;
        i32 err = stat(fullpath, &statbuf);
        if (!err) {
            stdio.sprintf(fullpath, "%s/%s", dirname, libname);
            return true;
        }
    }
    return false;
}

func void Loader.parseModule(void* arg, ast.Module* m) {
    Loader* l = arg;
    if (!m.isUsed()) return;

    char[512] filename;
    i32 len = stdio.sprintf(filename, "%s/%s.c2i", l.c.getPath(), m.getName());
    u32 name = l.auxPool.add(filename, cast<usize>(len), false);

    i32 file_id = l.sm.open(name, 0, false);
    if (file_id == -1) return;   // note: error already printed

    l.parser.parse(file_id, true);

    l.sm.close(file_id);
}

public func void Loader.load(Loader* l, component.Component* c) {
    l.c = c;
    l.builder.setComponent(c);
    c.visitModules(Loader.parseModule, l);
}


public func void Loader.showAll(const Loader* l) {
    string_buffer.Buf* out = string_buffer.create(1024, color.useColor(), 2);
    out.add("libraries:\n");

    bool show_modules = false;
    for (u32 i=0; i<l.dirs.length(); i++) {
        l.showLibs(out, l.dirs.get(i), show_modules);
    }

    stdio.puts(out.data());
    out.free();
}

func void Loader.showLibs(const Loader* l, string_buffer.Buf* out, const char* dirname, bool show_modules) {
    out.indent(1);
    out.color(color.Blue);
    out.add(dirname);
    out.color(color.Normal);
    out.newline();

    DIR* dir = opendir(dirname);
    if (dir == nil) {
        console.error("cannot open library dir '%s': %s", dirname, string.strerror(*errno2()));
        return;
    }

    char[512] fullname;
    Dirent* entry = readdir(dir);
    while (entry != nil) {
        const char* name = entry.d_name;
        if (name[0] != '.' && entry.d_type == DT_DIR) {
            i32 len = stdio.sprintf(fullname, "%s/%s/%s", dirname, name, constants.manifest_name);

            Stat statbuf;
            i32 err = stat(fullname, &statbuf);
            if (err) goto next;

            u32 filename_idx = l.auxPool.add(fullname, cast<usize>(len), false);

            out.indent(2);
            out.add(name);
            {
                i32 file_id = l.sm.open(filename_idx, 0, false);
                if (file_id == -1) return;

                u32 name_idx = l.auxPool.addStr(name, true);
                component.Component* comp = component.create(l.context, l.auxPool, l.modules, name_idx, 0, true);
                manifest.parse(l.sm, file_id, l.astPool, comp);
                l.components.add(comp);

                out.add("  ");
                out.color(color.Yellow);
                bool first = true;
                if (comp.isStaticLib()) {
                    out.add("static");
                    first = false;
                }
                if (comp.isDynamicLib()) {
                    if (!first) out.add1('|');
                    out.add("dynamic");
                    first = false;
                }

                const string_list.List* deps = comp.getDeps();
                u32 num_deps = deps.length();
                if (num_deps) {
                    out.add("  ");
                    out.color(color.Magenta);
                    out.add("requires: ");
                    for (u32 i=0; i<num_deps; i++) {
                        if (i != 0) out.add(", ");
                        out.add(deps.get(i));
                    }
                }

                l.sm.close(file_id);
                out.color(color.Normal);
                out.newline();

                if (show_modules) {
                    // TODO store in manifest or component?
                }
            }
        }
next:
        entry = readdir(dir);
    }
    closedir(dir);
}


/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module library_loader;

import ast_context;
import color;
import component;
import console;
import constants;
import manifest;
import module_list;
import source_mgr;
import string_buffer;
import string_list;
import string_pool;

import c_errno local;
import libc_dirent local;
import stdio;
import stdlib;
import string;
import sys_stat local;

public type Loader struct {
    source_mgr.SourceMgr* sm;   // no ownership
    component.List* components; // no ownership
    module_list.List* modules;   // no ownership
    string_pool.Pool* auxPool;  // no ownership
    string_pool.Pool* astPool;  // no ownership
    ast_context.Context* context; // no ownership

    string_list.List dirs;
} @(opaque)

public func Loader* create(source_mgr.SourceMgr* sm,
                           ast_context.Context* context,
                           component.List* components,
                           module_list.List* modules,
                           string_pool.Pool* auxPool,
                           string_pool.Pool* astPool)
{
    Loader* l = stdlib.calloc(1, sizeof(Loader));
    l.sm = sm;
    l.context = context;
    l.components = components;
    l.modules = modules;
    l.auxPool = auxPool;
    l.astPool = astPool;

    l.dirs.init(auxPool);
    return l;
}

public func void Loader.free(Loader* l) {
    l.dirs.free();
    stdlib.free(l);
}

public func void Loader.addDir(Loader* l, u32 dirname) {
    l.dirs.add(dirname);
}

public func void Loader.showAll(const Loader* l) {
    string_buffer.Buf* out = string_buffer.create(1024, color.useColor(), 2);
    out.add("libraries:\n");

    bool show_modules = false;
    for (u32 i=0; i<l.dirs.length(); i++) {
        l.showLibs(out, l.dirs.get(i), show_modules);
    }

    stdio.puts(out.data());
    out.free();
}

func void Loader.showLibs(const Loader* l, string_buffer.Buf* out, const char* dirname, bool show_modules) {
    out.indent(1);
    out.color(color.Blue);
    out.add(dirname);
    out.color(color.Normal);
    out.newline();

    DIR* dir = opendir(dirname);
    if (dir == nil) {
        console.error("cannot open library dir '%s': %s", dirname, string.strerror(*errno2()));
        return;
    }

    char[512] fullname;
    Dirent* entry = readdir(dir);
    while (entry != nil) {
        const char* name = entry.d_name;
        if (name[0] != '.' && entry.d_type == DT_DIR) {
            i32 len = stdio.sprintf(fullname, "%s/%s/%s", dirname, name, constants.manifest_name);

            Stat statbuf;
            i32 err = stat(fullname, &statbuf);
            if (err) goto next;

            u32 filename_idx = l.auxPool.add(fullname, cast<usize>(len), false);

            out.indent(2);
            out.add(name);
            {
                i32 file_id = l.sm.open(filename_idx, 0, false);
                if (file_id == -1) return;

                u32 name_idx = l.auxPool.addStr(name, true);
                component.Component* comp = component.create(l.context, l.auxPool, l.modules, name_idx, true);
                manifest.parse(l.sm, file_id, l.astPool, comp);
                l.components.add(comp);

                out.add("  ");
                out.color(color.Yellow);
                bool first = true;
                if (comp.isStaticLib()) {
                    out.add("static");
                    first = false;
                }
                if (comp.isDynamicLib()) {
                    if (!first) out.add1('|');
                    out.add("dynamic");
                    first = false;
                }

                const string_list.List* deps = comp.getDeps();
                u32 num_deps = deps.length();
                if (num_deps) {
                    out.add("  ");
                    out.color(color.Magenta);
                    out.add("requires: ");
                    for (u32 i=0; i<num_deps; i++) {
                        if (i != 0) out.add(", ");
                        out.add(deps.get(i));
                    }
                }

                l.sm.close(file_id);
                out.color(color.Normal);
                out.newline();

                if (show_modules) {
                    // TODO
                }
            }
        }
next:
        entry = readdir(dir);
    }
    closedir(dir);
}


/* Copyright 2022 Bas van den Berg
*/

module source_mgr;

import file_utils;
import utils;
import color;

import stdio;
import stdlib;
import string;

const u32 InitialMaxFiles = 8;

type File struct {
    const char* filename;   // no ownership
    u32 offset;
    // TODO dont use fileReader here, since it has duplicate info and error msg are easier then
    file_utils.Reader file;

    // to find line-number
    u32 last_offset;
    Location last_loc;
}

func void File.close(File* f) {
    // todo check state
    // TODO first do file opening/closing here ourself
    // ignore for now
    //f.file.close();
}

public type SourceMgr struct {
    File* files;
    u32 num_files;
    u32 max_files;

    // for report
    u32 other_count;
    u32 other_size;
    u32 sources_count;
    u32 sources_size;
} @(opaque)

public func SourceMgr* create() {
    SourceMgr* sm = stdlib.calloc(1, sizeof(SourceMgr));
    sm.max_files = InitialMaxFiles;
    sm.files = stdlib.malloc(sizeof(File) * sm.max_files);
    return sm;
}

public func void SourceMgr.free(SourceMgr* sm) {
    for (u32 i=0; i<sm.num_files; i++) {
        sm.files[i].close();
    }
    stdlib.free(sm.files);
    stdlib.free(sm);
}

// Note closes all files above the handle (excluding the handle)
public func void SourceMgr.clear(SourceMgr* sm, u32 handle) {
    for (u32 i=handle+1; i<sm.num_files; i++) {
        File* f = &sm.files[i];
        f.file.close();
    }
    sm.num_files = handle;
}

// TODO split in create and open?
public func i32 SourceMgr.open(SourceMgr* sm, const char* filename, utils.SrcLoc loc, bool is_source) {
    file_utils.Reader file;
    if (!file.open(filename)) {
        char[256] error_msg;
        if (file.errno == file_utils.Err_not_a_file) {
            stdio.sprintf(error_msg, "cannot open %s: %s\n", filename, "not a regular file");
        } else {
            stdio.sprintf(error_msg, "cannot open %s: %s\n", filename, string.strerror(file.errno));
        }
        if (loc) {
            stdio.fprintf(stdio.stderr, "%s: %serror:%s %s\n", sm.loc2str(loc), color.Red, color.Normal, error_msg);
        } else {
            stdio.fprintf(stdio.stderr, "%serror%s: %s\n", color.Red, color.Normal, error_msg);
        }
        return -1;
    }

    if (sm.num_files == sm.max_files) {
        sm.max_files *= 2;
        File* files2 = stdlib.malloc(sizeof(File) * sm.max_files);
        string.memcpy(files2, sm.files, sm.num_files * sizeof(File));
        stdlib.free(sm.files);
        sm.files = files2;
    }

    i32 file_id = cast<i32>(sm.num_files);
    File* f = &sm.files[sm.num_files];
    string.memset(f, 0, sizeof(File));

    u32 offset = 1;
    if (sm.num_files) offset = sm.files[sm.num_files-1].offset + sm.files[sm.num_files-1].file.size;
    f.filename = filename;
    f.offset = offset;
    f.file = file;
    if (is_source) {
        sm.sources_count++;
        sm.sources_size += file.size;
    } else {
        sm.other_count++;
        sm.other_size += file.size;
    }

    sm.num_files++;
    //sm.dump();
    return file_id;
}

public func void SourceMgr.close(SourceMgr* sm, i32 file_id) {
    sm.files[file_id].close();
}

public func const char* SourceMgr.get_content(SourceMgr* sm, i32 handle) {
    return cast<char*>(sm.files[handle].file.data());
}

public func const char* SourceMgr.get_token_source(SourceMgr* sm, utils.SrcLoc loc) {
    File* f = sm.find_file(loc);
    if (!f) return "";

    u32 offset = loc - f.offset;
    // TODO check if open, otherwise re-open
    char* data = f.file.region;
    data += offset;

    return data;
}

public func u32 SourceMgr.get_offset(SourceMgr* sm, i32 handle) {
    return sm.files[handle].offset;
}

public func const char* SourceMgr.getFileName(SourceMgr* sm, i32 handle) {
    return sm.files[handle].filename;
}

#if 0
func void SourceMgr.dump(const SourceMgr* sm) {
    stdio.printf("SourceMgr  files %u\n", sm.num_files);
    u32 total_size = 0;
    for (u32 i=0; i<sm.num_files; i++) {
        File* f = &sm.files[i];
        total_size += f.file.size;
        stdio.printf("  [%2u]  %7u  %7u %s\n", i, f.offset, f.file.size, f.filename);
    }
    stdio.printf("Total size %u\n", total_size);
}
#endif

public type Location struct {
    u32 line;
    u32 column;
    const char* filename;
    const char* line_start;
}

func File* SourceMgr.find_file(const SourceMgr* sm, u32 loc) {
    for (u32 i=0; i<sm.num_files; i++) {
        File* f = &sm.files[i];
        if (loc >= f.offset && loc < f.offset + f.file.size) return f;
    }
    return nil;
}

func void find_line_col(const char* data, u32 offset, Location* loc, u32 last_offset) {
    const char* line;
    u32 line_nr = loc.line;
    if (last_offset) {
        line = data + last_offset - loc.column + 1;
    } else {
        line = data;
    }
    for (u32 i=last_offset; i<offset; i++) {
        if (data[i] == '\n') {
            line_nr++;
            line = data + i + 1;
        }
    }
    loc.line = line_nr;
    loc.column = cast<u32>(&data[offset] - line) + 1;
    loc.line_start = line;
}

func Location SourceMgr.locate(SourceMgr* sm, u32 loc) {
    Location l = { 1, 1, nil }
    File* f = sm.find_file(loc);
    if (f) {
        l.filename = f.filename;
        u32 offset = loc - f.offset;
        u32 last_offset = 0;
        if (f.last_offset != 0 && offset > f.last_offset) {
            l = f.last_loc;
            last_offset = f.last_offset;
        }
        find_line_col(cast<char*>(f.file.data()), offset, &l, last_offset);

        f.last_offset = offset;
        f.last_loc = l;
    }
    return l;
}

public func Location SourceMgr.getLocation(SourceMgr* sm, u32 src_loc) {
    Location loc = { 0 }
    if (src_loc == 0) {
        loc.filename = "-";
    } else {
        loc = sm.locate(src_loc);
    }
    return loc;
}

public func const char* SourceMgr.loc2str(SourceMgr* sm, u32 src_loc) {
    local char[256] tmp;
    if (src_loc == 0) {
        string.strcpy(tmp, "-");
    } else {
        Location loc = sm.locate(src_loc);
        stdio.sprintf(tmp, "%s:%u:%u", loc.filename, loc.line, loc.column);
    }
    return tmp;
}

public func void SourceMgr.report(const SourceMgr* sm) {
    stdio.printf("files: %u sources (%u bytes), %u other (%u bytes)\n",
        sm.sources_count, sm.sources_size, sm.other_count, sm.other_size);
}


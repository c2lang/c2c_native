/* Copyright 2022 Bas van den Berg
*/

module component;

import ast;
import module_list;
import string_buffer;
import stdlib local;
import string;

import color;// TEMP
import stdio local; // TEMP

/*
    Represents a library or the main-component

    Used to:
    - create + store Modules
*/
public type Component struct {
    ast.Module** mods;
    u32 num_mods;
    u32 max_mods;
    module_list.ModList* globalList;
    const char* name;   // no ownership
} @(opaque)

public func Component* create(module_list.ModList* globalList, const char* name) {
    Component* c = calloc(1, sizeof(Component));
    c.resize(4);
    c.globalList = globalList;
    c.name = name;
    return c;
}

public func void Component.free(Component* c) {
    for (u32 i=0; i<c.num_mods; i++) {
        c.mods[i].free();
    }
    free(cast<void*>(c.mods));
    free(c);
}

public func const char* Component.getName(const Component* c) { return c.name; }

public type ModuleVisitor func void (void* arg, ast.Module* m);

public func void Component.visitModules(const Component* c, ModuleVisitor visitor, void* arg) {
    for (u32 i=0; i<c.num_mods; i++) {
        visitor(arg, c.mods[i]);
    }
}

public func void Component.visitImports(const Component* c, ast.ImportVisitor visitor, void* arg) {
    for (u32 i=0; i<c.num_mods; i++) {
        c.mods[i].visitImports(visitor, arg);
    }
}

public func ast.Module* Component.getModule(const Component* c, u32 idx) {
    return c.mods[idx];
}

public func ast.Module** Component.getModules(Component* c) {
    return c.mods;
}

public func u32 Component.getNumModules(const Component* c) {
    return c.num_mods;
}

func void Component.resize(Component* c, u32 cap) {
    c.max_mods = cap;
    void* buf = malloc(c.max_mods * sizeof(ast.Module*));
    if (c.mods) {
        void* old = cast<void*>(c.mods);
        string.memcpy(buf, old, c.num_mods * sizeof(ast.Module*));
        free(old);
    }
    c.mods = buf;
}

public func ast.Module* Component.getOrAddModule(Component* c, const char* modname) {
    for (u32 i=0; i<c.num_mods; i++) {
        ast.Module* m = c.mods[i];
        // Note: can do a pointer compare
        if (m.getName() == modname) return m;
    }

    ast.Module* m = c.globalList.find(modname);
    if (m) {
        fprintf(stderr, "%serror%s: module %s already defined in another component\n", color.Red, color.Normal, modname);
        // TODO need dest component
        // TODO need SourceMgr + SrcLoc here...nasty
        stdlib.exit(-1);
    }

    m = ast.Module.create(modname);

    if (c.num_mods == c.max_mods) c.resize(c.max_mods * 2);

    c.mods[c.num_mods] = m;
    c.num_mods++;
    return m;
}

// TEMP, this should be in a big list
public func ast.Module* Component.findModule(const Component* c, const char* name) {
    for (u32 i=0; i<c.num_mods; i++) {
        // Note: we can search by pointer compares
        if (c.mods[i].getName() == name) return c.mods[i];
    }
    return nil;
}

public func void Component.info(const Component* c) {
    string_buffer.Buf* out = string_buffer.create(64*1024);
    out.print("Component\n");
    for (u32 i=0; i<c.num_mods; i++) {
        c.mods[i].info(out);
    }
    stdio.printf("%s\n", out.data());
    out.free();
}

public func void Component.print(const Component* c) {
    string_buffer.Buf* out = string_buffer.create(128*1024, true);
    out.print("Component\n");
    for (u32 i=0; i<c.num_mods; i++) {
        c.mods[i].print(out);
    }
    stdio.puts(out.data());
    out.free();
}


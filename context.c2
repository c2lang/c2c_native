/* Copyright 2022 Bas van den Berg
*/

module ast_context;

import string local;
import stdlib local;
// TEMP
import stdio local;


type Block struct {
    u8* data;
    u32 size;
    Block* next;
}

func Block* Block.create(u32 blk_size) {
    Block* b = malloc(sizeof(Block));
    b.data = malloc(blk_size);
    b.size = 0;
    b.next = nil;
    return b;
}

func Block* Block.free(Block* b) {
    Block* next = b.next;
    free(b.data);
    free(b);
    return next;
}

func u32 Block.count(const Block* b) {
    u32 total = 0;
    const Block* blk = b;
    while (blk) {
        total ++;
        blk = blk.next;
    }
    return total;
}

func u32 Block.get_total(const Block* b) {
    u32 total = 0;
    const Block* blk = b;
    while (blk) {
        total += blk.size;
        blk = blk.next;
    }
    return total;
}

public type Context struct {
    Block* blk_head;
    Block* blk_tail;
    u32 blk_size;

    Block* str_blk_head;
    Block* str_blk_tail;
    u32 str_blk_size;
} @(opaque)

public func Context* Context.create(u32 blk_size, u32 str_blk_size) {
    Context* c = calloc(1, sizeof(Context));
    c.blk_size = blk_size;
    c.str_blk_size = str_blk_size;
    c.init();
    return c;
}

public func void Context.free(Context* c) {
    Block* blk = c.blk_head;
    while (blk) blk = blk.free();

    free(c);
}

func void Context.init(Context* c) {
    c.blk_head = Block.create(c.blk_size);
    c.blk_tail = c.blk_head;

    c.str_blk_head = Block.create(c.str_blk_size);
    c.str_blk_tail = c.str_blk_head;
}

public func void Context.clear(Context* c) {
    Block* blk = c.blk_head;
    while (blk) blk = blk.free();

    c.init();
}

public func void* Context.alloc(Context* c, u32 len) {
    // TODO always align as ptr size!!
    // assert(len * 0x3 == 0); // must be 8-byte multiple
    // assert(len < blk_size)
    Block* last = c.blk_tail;
    if (last.size + len >= c.blk_size) {
        c.blk_tail = Block.create(c.blk_size);
        last.next = c.blk_tail;
        last = last.next;
    }

    void* cur = last.data + last.size;
    last.size += len;
    return cur;
}

public func const char* Context.alloc_str(Context* c, const char* text, u32 len) @(inline) {
    // assert(len < strblk_size)
    len++;  // add 0-terminator

    Block* last = c.str_blk_tail;
    if (last.size + len >= c.str_blk_size) {
        c.str_blk_tail = Block.create(c.str_blk_size);
        last.next = c.str_blk_tail;
        last = last.next;
    }

    char* buf = last.data + last.size;
    last.size += len;

    len--;
    memcpy(buf, text, len);
    buf[len] = 0;
    return buf;
}

public func void Context.dump(const Context* c) {
    u32 num = c.blk_head.count();
    u32 total = c.blk_head.get_total();

    printf("Context:\n");
    printf("    blk size %u, %u blocks, total %u/%u\n", c.blk_size, num, total, num * c.blk_size);

    u32 str_num = c.str_blk_head.count();
    u32 str_total = c.str_blk_head.get_total();
    printf("    blk size %u, %u blocks, total %u/%u\n", c.str_blk_size, str_num, str_total, str_num * c.str_blk_size);

    printf("    total %u\n", total + str_total);
}

public func u32 Context.get_total(const Context* c) {
    return c.blk_head.get_total() + c.str_blk_head.get_total();
}


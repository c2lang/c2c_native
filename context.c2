/* Copyright 2022 Bas van den Berg
*/

module ast_context;

import string local;
import stdlib local;
// TEMP
import stdio local;

#if ContextDebug
u32 str_allocs;
u32 ast_allocs;
#endif

type Block struct {
    u8* data;
    u32 size;
    Block* next;
}

func Block* Block.create(u32 blk_size) {
    Block* b = malloc(sizeof(Block));
    b.data = malloc(blk_size);
    b.size = 0;
    b.next = nil;
    return b;
}

func Block* Block.free(Block* b) {
    Block* next = b.next;
    free(b.data);
    free(b);
    return next;
}

func u32 Block.count(const Block* b) {
    u32 total = 0;
    const Block* blk = b;
    while (blk) {
        total ++;
        blk = blk.next;
    }
    return total;
}

func u32 Block.get_total(const Block* b) {
    u32 total = 0;
    const Block* blk = b;
    while (blk) {
        total += blk.size;
        blk = blk.next;
    }
    return total;
}

public type Context struct {
    Block* blk_head;
    Block* blk_tail;
    u32 blk_size;

    Block* str_blk_head;
    Block* str_blk_tail;
    u32 str_blk_size;
} @(opaque)

public func Context* Context.create(u32 blk_size, u32 str_blk_size) {
    Context* c = calloc(1, sizeof(Context));
    c.blk_size = blk_size;
    c.str_blk_size = str_blk_size;
    c.init();
    return c;
}

func void Context.freeBlocks(Context* c) {
    Block* blk = c.blk_head;
    while (blk) blk = blk.free();

    blk = c.str_blk_head;
    while (blk) blk = blk.free();
}

public func void Context.free(Context* c) {
    c.freeBlocks();
    free(c);
}

func void Context.init(Context* c) {
    c.blk_head = Block.create(c.blk_size);
    c.blk_tail = c.blk_head;

    if (c.str_blk_size) {
        c.str_blk_head = Block.create(c.str_blk_size);
        c.str_blk_tail = c.str_blk_head;
    }
}

public func void Context.clear(Context* c) {
    c.freeBlocks();
    c.init();
}

public func void* Context.alloc(Context* c, u32 len) {
#if ContextDebug
    ast_allocs++;
#endif
    // assert(c.blk_head);
    // TODO always align as ptr size!!
    // assert(len * 0x3 == 0); // must be 8-byte multiple
    // assert(len < blk_size)
    Block* last = c.blk_tail;
    if (last.size + len >= c.blk_size) {
        c.blk_tail = Block.create(c.blk_size);
        last.next = c.blk_tail;
        last = last.next;
    }

    void* cur = last.data + last.size;
    last.size += len;
    return cur;
}

public func const char* Context.alloc_str(Context* c, const char* text, usize len) @(inline) {
    // assert(c.str_blk_head);
    // assert(len < strblk_size)
    len++;  // add 0-terminator
#if ContextDebug
    str_allocs++;
#endif

    Block* last = c.str_blk_tail;
    if (last.size + len >= c.str_blk_size) {
        c.str_blk_tail = Block.create(c.str_blk_size);
        last.next = c.str_blk_tail;
        last = last.next;
    }

    char* buf = cast<char*>(last.data + last.size);
    last.size += len;

    len--;
    memcpy(buf, text, len);
    buf[len] = 0;
    return buf;
}

public func void Context.dump(const Context* c) {
    u32 num = c.blk_head.count();
    u32 ast_total = c.blk_head.get_total();

    printf("Context:\n");
    printf("    AST blk size %u, %u blocks, total %u/%u\n", c.blk_size, num, ast_total, num * c.blk_size);
#if ContextDebug
    printf("    %u AST allocs (avg %u bytes)\n", ast_allocs, ast_total / ast_allocs);
#endif

    u32 str_num = c.str_blk_head.count();
    u32 str_total = c.str_blk_head.get_total();
    printf("    STR blk size %u, %u blocks, total %u/%u\n", c.str_blk_size, str_num, str_total, str_num * c.str_blk_size);

#if ContextDebug
    printf("    %u STR allocs (avg %u bytes)\n", str_allocs, str_total / str_allocs);
#endif

    printf("    total %u\n", ast_total + str_total);
}

public func u32 Context.get_total(const Context* c) {
    return c.blk_head.get_total() + c.str_blk_head.get_total();
}


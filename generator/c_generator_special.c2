/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module c_generator;

import ast;
import build_file;
import build_target;
import component;
import console;
import file_utils;
import module_list;
import string_buffer;

import string;
import stdio;

func void Generator.createMakefile(Generator* gen, const char* output_dir, component.List* comps, bool enable_asserts, bool fast_build) {
    string_buffer.Buf* out = gen.out;
    out.clear();
    out.add("# This makefile is auto-generated, any modifications will be lost\n\n");

    const char* cc = "gcc";
    const char* cflags = nil;
    const char* ldflags = "";
    const char* ldflags2 = "";

    if (gen.build_info) {
        const build_file.Info* info = gen.build_info;
        if (info.getCC()) cc = info.getCC();
        if (info.getCFlags()) cflags = info.getCFlags();
        if (info.getLdFlags()) ldflags = info.getLdFlags();
        if (info.getLdFlags2()) ldflags2 = info.getLdFlags2();
    }

    out.print("CC=%s\n", cc);

    out.add("CFLAGS=-Wall -Wextra -Wno-unused -Wno-switch -Wno-char-subscripts -Wno-zero-length-bounds -Wno-format-overflow -Wno-stringop-overflow\n");
    out.add("CFLAGS+=-pipe -std=c99 -Wno-missing-field-initializers\n");
    if (fast_build) out.add("CFLAGS+=-O0 -g\n");
    else out.add("CFLAGS+=-O2 -g\n");
    if (!enable_asserts) out.add("CFLAGS+=-DNDEBUG\n");
    if (cflags) out.print("CFLAGS+=%s\n", cflags);
    out.newline();

    out.print("LDFLAGS=%s\n", ldflags ? ldflags : "");
    out.print("LDFLAGS2=%s\n", ldflags2 ? ldflags2 : "");
    out.newline();

    char[128] target_name;

    switch (gen.target_kind) {
    case Executable:
        string.strcpy(target_name, gen.target);
        out.print("all: ../%s\n\n", target_name);
        out.print("../%s: build.c\n", target_name);
        out.print("\t\t$(CC) $(CFLAGS) -c build.c -o build.o\n");
        out.print("\t\t$(CC) $(LDFLAGS) -o ../%s build.o", target_name);

        const char* triplet = gen.targetInfo.str();

        // interate Components in reverse order
        for (u32 i=comps.size(); i != 0; i--) {
            component.Component* c = comps.get(i-1);
            if (!c.isExternal()) continue;
            if (c.isStaticLib()) {
                out.print(" -L%s/%s", c.getPath(), triplet);
            }
            const char* linkname = c.getLinkName();
            if (linkname) out.print(" -l%s", linkname);
        }
        out.add(" $(LDFLAGS2)\n");
        out.newline();
        break;
    case StaticLibrary:
        stdio.sprintf(target_name, "lib%s.a", gen.target);
        out.print("all: ../%s\n\n", target_name);
        out.print("../%s: build.c\n", target_name);
	    out.print("\t\t$(CC) $(CFLAGS) -c build.c -o %s.o\n", gen.target);
	    out.print("\t\tar rcs ../%s %s.o\n", target_name, gen.target);
        break;
    case DynamicLibrary:
        stdio.sprintf(target_name, "lib%s.so", gen.target);
        out.print("all: ../%s\n\n", target_name);
        out.print("../%s: build.c\n", target_name);
	    out.print("\t\t$(CC) $(CFLAGS) -c build.c -o %s.o\n", gen.target);
	    out.print("\t\t$(CC) $(LDFLAGS) %s.o -shared -o ../%s -Wl,-soname,%s.1 -Wl,--version-script=exports.version $(LDFLAGS2)\n",
            gen.target, target_name, target_name);
        break;
    }

    out.newline();
    out.add("symbols:\n");
    out.print("\t\tnm -g -D -C --defined-only ../%s\n\n", target_name);

    out.add("clean:\n");
    out.print("\t\trm -f *.o *.a ../%s\n\n", target_name);

    gen.write(output_dir, "Makefile");
}

func void Generator.createExportsFile(Generator* gen, const char* output_dir, component.Component* mainComp) {
    if (gen.target_kind != build_target.Kind.DynamicLibrary) return;

    string_buffer.Buf* out = gen.out;
    out.clear();

    out.add("LIB_1.0 {\n");
    out.add("\tglobal:\n");

    // iterate all mods in main Component
    module_list.List* mods = mainComp.getModules();
    u32 count = mods.length();

    for (u32 i=0; i<count; i++) {
        const ast.SymbolTable* symbols = mods.at(i).getSymbols();
        ast.Decl** decls = symbols.getDecls();
        u32 num_symbols = symbols.size();
        for (u32 j=0; j<num_symbols; j++) {
            ast.Decl* d = decls[j];
            if (!d.isExported()) continue;
            if (!d.isFunction() && !d.isVariable()) continue;
            out.add("\t\t");
            gen.emitCNameMod(out, d, d.getModule());
            out.add(";\n");
        }
    }

    out.add("\tlocal:\n\t\t*;\n");
    out.add("};\n");

    gen.write(output_dir, "exports.version");
}

func void Generator.generateC2TypesHeader(Generator* gen) {
    string_buffer.Buf* out = gen.c2i_file;
    out.clear();
    out.add("// WARNING: this file is auto-generated by the C2 compiler.\n");
    out.add("// Any changes you make might be lost!\n\n");

    out.add("#ifndef C2TYPES_H\n");
    out.add("#define C2TYPES_H\n");

    out.newline();
    out.add("#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");
    out.add("#define NULL ((void*)0)\n");
    // NOTE: might change for 32 bit?
    out.add("#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)\n");
    out.add("#define to_container(type, member, ptr) ((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))\n");

    out.newline();
    // NOTE: 64-bit only for now
    out.add("typedef signed char int8_t;\n");
    out.add("typedef unsigned char uint8_t;\n");
    out.add("typedef signed short int int16_t;\n");
    out.add("typedef unsigned short int uint16_t;\n");
    out.add("typedef signed int int32_t;\n");
    out.add("typedef unsigned int uint32_t;\n");
    out.add("typedef signed long int64_t;\n");
    out.add("typedef unsigned long uint64_t;\n");
    out.newline();
    out.add("#ifdef __cplusplus\n}\n#endif\n\n");

    out.add("#endif\n");

    char[256] fullname;
    // TODO use stringbuf for this
    stdio.sprintf(fullname, "%s/c2types.h", gen.results_dir);
    file_utils.Writer writer;
    if (!writer.write(fullname, cast<u8*>(out.data()), out.size())) {
        console.error(writer.getError());
    }
}


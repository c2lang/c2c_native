/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module c_generator;

import ast local;
import source_mgr;
import string_buffer;

import stdio;

func void Generator.emitStmt(Generator* gen, Stmt* s, u32 indent, bool newline) {
    string_buffer.Buf* out = gen.out;

    if (newline) out.indent(indent);

    switch (s.getKind()) {
    case Return:
        out.add("return");
        ReturnStmt* r = cast<ReturnStmt*>(s);
        ast.Expr* val = r.getValue();
        if (val) {
            out.space();
            gen.emitExpr(out, val);
        }
        out.add(";\n");
        break;
    case Expr:
        gen.emitExpr(out, cast<Expr*>(s));
        if (newline) out.add(";\n");
        break;
    case If:
        IfStmt* i = cast<IfStmt*>(s);
        Stmt* cond = i.getCond();
        bool is_decl = cond.isDecl();
        if (is_decl) {
            // TODO leave out init part
            gen.emitStmt(cond, 0, true);
            out.indent(indent);
            out.add("if (");
            DeclStmt* ds = cast<DeclStmt*>(cond);
            VarDecl* vd = ds.getDecl();
            out.add(vd.asDecl().getName());
            // TODO also add init part
        } else {
            out.add("if (");
            gen.emitStmt(cond, 0, false);
        }
        out.add(") ");
        Stmt* thenStmt = i.getThen();
        gen.emitStmt(thenStmt, indent, false);
        if (!thenStmt.isCompound()) {
            if (!out.endsWith('\n')) out.add1(';');
        }

        Stmt* elseStmt =  i.getElse();
        if (elseStmt) {
            if (thenStmt.isCompound()) {
                out.space();
            } else {
                if (!out.endsWith('\n')) out.newline();
                out.indent(indent);
            }
            out.add("else ");
            gen.emitStmt(elseStmt, indent, false);
            if (!elseStmt.isCompound()) {
                if (!out.endsWith('\n')) out.add1(';');
            }
        }
        out.newline();
        break;
    case While:
        WhileStmt* w = cast<WhileStmt*>(s);
        Stmt* cond = w.getCond();
        bool is_decl = cond.isDecl();
        if (is_decl) {
            // TODO leave out init part
            gen.emitStmt(cond, 0, true);
            out.indent(indent);
            out.add("while (");
            DeclStmt* ds = cast<DeclStmt*>(cond);
            VarDecl* vd = ds.getDecl();
            out.add(vd.asDecl().getName());
            // TODO also add init part
        } else {
            out.add("while (");
            gen.emitStmt(cond, 0, false);
        }
        out.add(") ");
        Stmt* body = w.getBody();
        gen.emitStmt(body, indent, false);
        if (!body.isCompound()) {
            out.add1(';');
        }
        out.newline();
        break;
    case Do:
        DoStmt* doStmt = cast<DoStmt*>(s);
        out.add("do ");
        Stmt* body = doStmt.getBody();
        gen.emitStmt(body, indent, false);
        if (body.isCompound()) {
            out.space();
        } else {
            out.add(";\n");
            out.indent(indent);
        }
        out.add("while (");
        gen.emitStmt(doStmt.getCond(), 0, false);
        out.add(");\n");
        break;
    case For:
        ForStmt* f = cast<ForStmt*>(s);
        out.add("for (");
        Stmt* initStmt = f.getInit();
        if (initStmt) {
            gen.emitStmt(initStmt, 0, false);
        }
        out.add1(';');
        if (f.getCond()) {
            out.space();
            gen.emitExpr(out, f.getCond());
        }
        out.add1(';');
        Expr* incr = f.getIncr();
        if (incr) {
            out.space();
            gen.emitExpr(out, incr);
        }
        out.add(") ");
        Stmt* body = f.getBody();
        gen.emitStmt(body, indent, false);
        if (!body.isCompound()) {
            out.add1(';');
        }
        out.newline();
        break;
    case Switch:
        gen.emitSwitchStmt(s, indent);
        break;
    case Break:
        out.add("break;\n");
        break;
    case Continue:
        out.add("continue;\n");
        break;
    case Fallthrough:
        out.add("__attribute__((fallthrough));\n");
        break;
    case Label:
        LabelStmt* l = cast<LabelStmt*>(s);
        out.add(l.getName());
        out.add(":\n");
        break;
    case Goto:
        GotoStmt* g = cast<GotoStmt*>(s);
        out.add("goto ");
        out.add(g.getName());
        out.add(";\n");
        break;
    case Compound:
        CompoundStmt* c = cast<CompoundStmt*>(s);

        out.add("{\n");

        u32 count = c.getCount();
        Stmt** stmts = c.getStmts();
        for (u32 i=0; i<count; i++) {
            gen.emitStmt(stmts[i], indent+1, true);
        }

        out.indent(indent);
        out.add1('}');
        if (newline) out.newline();
        break;
    case Decl:
        DeclStmt* ds = cast<DeclStmt*>(s);
        VarDecl* vd = ds.getDecl();
        Decl* d = cast<Decl*>(vd);
        if (vd.hasLocalQualifier()) out.add("static ");
        gen.emitTypePre(out, d.getType());
        out.space();
        out.add(d.getName());
        gen.emitTypePost(out, d.getType());
        d.setGenerated();
        Expr* ie = vd.getInit();
        if (ie) {
            out.add(" = ");
            gen.emitExpr(out, ie);
        }
        if (newline) out.add(";\n");
        break;
    case Asm:
        gen.emitAsmStmt(cast<AsmStmt*>(s), indent);
        break;
    case Assert:
        if (!gen.enable_asserts) break;

        AssertStmt* a = cast<AssertStmt*>(s);
        source_mgr.Location loc = gen.sm.getLocation(a.getLoc());
        const char* funcname = gen.cur_function.asDecl().getFullName();

        out.add("c2_assert((");
        char[512] location;
        stdio.sprintf(location, "%s:%u: %s", loc.filename, loc.line, funcname);
        Expr* inner = a.getInner();
        gen.emitExpr(out, inner);
        out.print(") != 0, \"");
        out.add(location);
        out.add("\", \"");
        inner.printLiteral(out);
        out.add("\");\n");
        break;
    }
}

func void emitAsmPart(string_buffer.Buf* out, bool multi_line, u32 indent) {
    if (multi_line) {
        out.newline();
        out.indent(indent);
    } else {
        out.space();
    }
    out.add(": ");
}


func void Generator.emitAsmOperand(Generator* gen, u32 name, const Expr* c, Expr* e) {
    string_buffer.Buf* out = gen.out;
    if (name) {
        out.print("[%s] ", ast.idx2name(name));
    }
    const StringLiteral* cs = cast<StringLiteral*>(c);
    cs.printLiteral(out);
    out.add(" (");
    gen.emitExpr(out, e);
    out.rparen();

}

func void Generator.emitAsmStmt(Generator* gen, AsmStmt* a, u32 indent) {
    string_buffer.Buf* out = gen.out;

    out.add("__asm__ ");
    if (a.isVolatile()) out.add("volatile ");

    out.lparen();
    StringLiteral* str = a.getString();
    str.printLiteral(out);

    u32 num_outputs = a.getNumOutputs();
    u32 num_inputs = a.getNumInputs();
    u32 num_clobbers = a.getNumClobbers();
    bool multi_line = false;
    if ((num_outputs + num_inputs + num_clobbers) > 4 || num_clobbers != 0) multi_line = true;

    if (num_outputs + num_inputs + num_clobbers) {
        u32* names = a.getNames();
        Expr** constraints = a.getConstraints();
        Expr** exprs = a.getExprs();
        // outputs
        emitAsmPart(out, multi_line, indent);
        for (u32 i=0; i<num_outputs; i++) {
            if (i!=0) out.add(", ");
            gen.emitAsmOperand(names[i], constraints[i], exprs[i]);
        }
        // inputs
        if (num_inputs | num_clobbers) {
            emitAsmPart(out, multi_line, indent);
            for (u32 i=0; i<num_inputs; i++) {
                if (i!=0) out.add(", ");
                u32 idx = i + num_outputs;
                gen.emitAsmOperand(names[idx], constraints[idx], exprs[idx]);
            }
        }
        // clobbers
        if (num_clobbers) {
            Expr** clobbers = a.getClobbers();
            emitAsmPart(out, multi_line, indent);
            for (u32 i=0; i<num_clobbers; i++) {
                if (i!=0) out.add(", ");
                StringLiteral* l = cast<StringLiteral*>(clobbers[i]);
                l.printLiteral(out);
            }
        }
    }

    out.rparen();
    out.add(";\n");
}

func void Generator.emitSwitchStmt(Generator* gen, Stmt* s, u32 indent) {
    string_buffer.Buf* out = gen.out;

    SwitchStmt* sw = cast<SwitchStmt*>(s);
    const u32 num_cases = sw.getNumCases();
    SwitchCase** cases = sw.getCases();

    if (sw.isSSwitch()) {
        out.add("do {\n");
        out.indent(indent+1);
        out.add("const char* _tmp = ");
        gen.emitExpr(out, sw.getCond());
        out.add(";\n");

        for (u32 i=0; i<num_cases; i++) {
            if (i==0) out.indent(indent+1);
            else out.add(" else ");

            SwitchCase* c = cases[i];

            if (c.isDefault()) {
                out.add("{\n");
            } else {
                Expr* cond = c.getCond();
                if (cond.isNil()) {
                    out.add("if (_tmp == NULL) {\n");
                } else {
                    out.add("if (strcmp(_tmp, ");
                    gen.emitExpr(out, cond);
                    out.add(") == 0) {\n");
                }
            }

            const u32 num_stmts = c.getNumStmts();
            Stmt** stmts = c.getStmts();
            for (u32 j=0; j<num_stmts; j++) {
                gen.emitStmt(stmts[j], indent+2, true);
            }

            out.indent(indent+1);
            out.add1('}');
        }
        out.newline();

        out.indent(indent);
        out.add("} while (0);\n");
    } else {
        out.add("switch (");
        gen.emitExpr(out, sw.getCond());
        out.add(") {\n");

        for (u32 i=0; i<num_cases; i++) {
            gen.emitCase(cases[i], indent);
        }

        out.indent(indent);
        out.add("}\n");
    }
}

func void Generator.emitCase(Generator* gen, SwitchCase* c, u32 indent) {
    string_buffer.Buf* out = gen.out;

    if (c.isDefault()) {
        out.add("default:");
    } else {
        out.add("case ");
        gen.emitExpr(out, c.getCond());
        out.add1(':');
    }

    if (c.hasDecls()) out.add(" {");
    out.newline();

    const u32 num_stmts = c.getNumStmts();
    Stmt** stmts = c.getStmts();
    for (u32 i=0; i<num_stmts; i++) {
        gen.emitStmt(stmts[i], indent+1, true);
    }

    if (c.hasDecls()) {
        out.indent(indent);
        out.add("}\n");
    }
}


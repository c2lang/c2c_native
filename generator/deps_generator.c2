/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module deps_generator;

import ast local;
import component;
import string_buffer;
import file_utils;
import ast_visitor;

//import string;
import stdio;

public func const char* getFullName(const Decl* d) {
    local char[64] fullname;

    switch (d.getKind()) {
    case Function:
        const FunctionDecl* fd = cast<FunctionDecl*>(d);
        if (fd.hasPrefix()) {
            stdio.sprintf(fullname, "%s.%s", fd.getPrefixName(), d.getName());
            return fullname;
        }
        break;
    case Import:
        break;
    case StructType:
        break;
    case EnumType:
        break;
    case EnumConstant:
        // Note: not used, since we do this in Enum Type
        break;
    case FunctionType:
        break;
    case AliasType:
        break;
    case Var:
        break;
    case StaticAssert:
        break;
    case ArrayValue:
        break;
    }
    return d.getName();
}

type Generator struct {
    const char* curfile;
    ast_visitor.Visitor* visitor;

    string_buffer.Buf* out;
    u32 indent;
}

func void Generator.on_decl(void* arg, const Decl* d, bool global) {
    Generator* gen = arg;

    const char* name = d.getName();
    if (name && global) {
        // ..
    }

    switch (d.getKind()) {
    case Function:
        FunctionDecl* fd = cast<FunctionDecl*>(d);
        // TODO prefix (optional)
        // TODO needed? (or already done by visitor?)
        gen.handleTypeRef(fd.getTypeRef());
        break;
    case Import:
        return;
    case StructType:
        StructTypeDecl* s = cast<StructTypeDecl*>(d);
        u32 num_members = s.getNumMembers();
        Decl** members = s.getMembers();
        for (u32 i=0; i<num_members; i++) {
            Generator.on_decl(arg, members[i], false);
        }
        break;
    case EnumType:
        // TODO let visitor do this
        EnumTypeDecl* etd = cast<EnumTypeDecl*>(d);
        EnumConstantDecl** constants = etd.getConstants();
        for (u32 i=0; i<etd.getNumConstants(); i++) {
            Decl* ecd = cast<Decl*>(constants[i]);
            // NOTE: we add the symbol here, since we have the EnumDecl here
            char[64] fullname;
            stdio.sprintf(fullname, "%s.%s", d.getName(), ecd.getName());
            //gen.refs.add_symbol(fullname, &dest);

            Generator.on_decl(arg, ecd, false);
        }
        break;
    case EnumConstant:
        break;
    case FunctionType:
        break;
    case AliasType:
        break;
    case Var:
        const VarDecl* v = cast<VarDecl*>(d);
        gen.handleTypeRef(v.getTypeRef());
        break;
    case StaticAssert:
        return;
    case ArrayValue:
        return;
    }

    gen.visitor.handle(d);
}

func void Generator.handleTypeRef(Generator* gen, const TypeRef* ref) {
    const Ref* prefix = ref.getPrefix();
    if (prefix) gen.handleRef(prefix);

    const Ref* user = ref.getUser();
    if (user) gen.handleRef(user);
}

func void Generator.handleRef(Generator* gen, const Ref* ref) {
    if (!ref.decl) {
        stdio.printf("refs: Decl not set!\n");
        return;
    }
    //gen.refs.add_tag(&src, &dest);
}

func void Generator.on_global_decl(void* arg, Decl* d) {
    Generator* gen = arg;

    gen.out.indent(gen.indent);
    const char* fullname = getFullName(d);
    gen.out.print("<atom name='%s' full='%s'>\n", fullname, fullname);

    gen.indent++;
    Generator.on_decl(arg, d, true);
    gen.indent--;

    gen.out.indent(gen.indent);
    gen.out.add("</atom>\n");
}

func void Generator.on_ast(void* arg, AST* a) {
    Generator* gen = arg;
    gen.curfile = a.getFilename();

    gen.out.indent(gen.indent);
    gen.out.print("<group name='%s' full='file:%s' collapsed='1'>\n", gen.curfile, gen.curfile);

    gen.indent++;
    a.visitDecls(Generator.on_global_decl, arg); // globals
    gen.indent--;

    gen.out.indent(gen.indent);
    gen.out.add("</group>\n");
}

func void Generator.on_module(void* arg, Module* m) {
    Generator* gen = arg;

    // TODO only skip for libs
    if (!m.isUsed()) return;

    gen.out.indent(gen.indent);
    gen.out.print("<group name='%s' full='module:%s' collapsed='1'>\n", m.getName(), m.getName());

    gen.indent++;
    m.visitASTs(Generator.on_ast, arg);
    gen.indent--;

    gen.out.indent(gen.indent);
    gen.out.add("</group>\n");
}

func void Generator.on_ref(void* arg, const Ref* ref) {
    Generator* gen = arg;
    gen.handleRef(ref);
}

public func void generate(const char* title, const char* output_dir, component.Component** c, u32 count) {
    Generator gen = { nil }
    gen.visitor = ast_visitor.create(&gen, Generator.on_ref);
    gen.out = string_buffer.create(1024*1024, false, 2);
    gen.indent = 0;

    string_buffer.Buf* out = gen.out;

    out.add("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    out.print("<dsm name='%s'>\n", title);
    gen.indent++;
    out.indent(gen.indent);
    out.add("<model>\n");

    gen.indent++;

    for (u32 i=0; i<count; i++) {
        const component.Component* comp = c[i];
        out.indent(gen.indent);
        out.print("<group name='%s' full='component:%s' collapsed='0'>\n", comp.getName(), comp.getName());
        gen.indent++;
        comp.visitModules(Generator.on_module, &gen);
        gen.indent--;
        out.indent(gen.indent);
        out.add("</group>\n");
    }

    gen.indent--;

    out.indent(gen.indent);
    out.add("</model>\n");
    gen.indent--;
    out.add("</dsm>\n");

    char[128] outfile;
    stdio.sprintf(outfile, "%s/%s", output_dir, "deps2.xml");
    file_utils.Writer file;
    file.write(outfile, cast<u8*>(out.data()), out.size());

    gen.out.free();

    gen.visitor.free();
}


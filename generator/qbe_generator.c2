module qbe_generator;

import ast local;
import component;
import string_buffer;
import file_utils;
import utils;

import string;
import stdio local;

type Generator struct {
    string_buffer.Buf* out;
    const char* output_dir;
    bool cur_external;  // whether current component is external
    u32 func_idx;   // also body idx
    u32 string_idx; // for string literals
}

type Param struct {
    void* ptr;
    u32 size;
    u32 align;
}

const char[] QBE_Dir = "qbe";
const char[] QBE_Filename = "main.qbe";

// TEMP HERE
u32 substruct_idx;  // for unnamed substructs/unions

/*
    TODO: use short names for struct, faster QBE parsing (just name sequenctially)
        -> need lookup then (name -> idx)

    - trailing comma is allowed
    - types must be declared before being used
    type :cryptovector = align 16 { w, w, l }

    nesting:
    type :outer = { :inner, h }

    return Outer -> function :outer $name() ..
    return Outer* -> function l $name() ..
    also for args

    global:
    Point[10] points -> export data $points = align 4 { z 80 }   # 80 is total size
*/

func void addStructName(string_buffer.Buf* out, Decl* d) {
    assert(d.getName());
    out.add1(':');
    out.add(d.getModuleName());
    out.add1('_');
    out.add(d.getName());
}

func void addGlobalName(string_buffer.Buf* out, Decl* d) {
    assert(d.getName());
    out.add1('$');
    out.add(d.getModuleName());
    out.add1('_');
    out.add(d.getName());
}

func void addType(string_buffer.Buf* out, QualType qt) {
    const StructType* s = qt.getStructTypeOrNil();
    if (s) {
        addStructName(out, cast<Decl*>(s.getDecl()));
    } else {
        if (qt.getAlignment() == 8) out.add1('l');
        else out.add1('w');
    }
}

func void addParam(string_buffer.Buf* out, Decl* p, Param* param) {
    QualType qt = p.getType();
    param.ptr = p;

    const StructType* s = qt.getStructTypeOrNil();
    if (s) {
        const StructTypeDecl* std = s.getDecl();
        addStructName(out, cast<Decl*>(std));
        param.size = std.getSize();
        param.align = std.getAlignment();
    } else {
        u32 w = qt.getAlignment();
        param.size = w;
        param.align = w;
        if (w == 8) out.add1('l');
        else out.add1('w');
    }
}

func char align2char(u32 align) {
    if (align == 8) return 'l';
    if (align == 4) return 'w';
    if (align == 2) return 's';
    if (align == 1) return 'b';
    printf("WIDTH %u\n", align);
    assert(0);
    return '?';
}

func char align2store(u32 align) {
    if (align == 4) return 'w';
    if (align == 2) return 'h';
    if (align == 1) return 'b';
    return 'l';
}
func void Generator.handleFunction(Generator* gen, Decl* d) {
    const FunctionDecl* fd = cast<FunctionDecl*>(d);
    string_buffer.Buf* out = gen.out;

    if (d.isPublic()) gen.out.add("export "); // TEMP not if  single file

    out.add("function ");

    if (fd.hasReturn()) {
        addType(out, fd.getRType());
        out.add1(' ');
    }

    out.add1('$');
    // TODO add module name, except for main
    // TEMP do smarter
    bool has_prefix = !d.isPublic() || (string.strcmp(d.getName(), "main") != 0);
    if (has_prefix) {
        out.add(d.getModuleName());
        out.add1('_');
    }
    const IdentifierExpr* prefix = fd.getPrefix();
    if (prefix) {
        out.add(prefix.getName());
        out.add1('_');
    }
    out.add(d.getName());
    out.add1('(');


    u32 num_params = fd.getNumParams();
    assert(num_params < 16);
    // STORE info about members here, use to generate start (also later body)
    Param[16] params;

    for (u32 i=1; i<=num_params; i++) {
        Decl* param = cast<Decl*>(fd.getParam(i-1));
        if (i != 1) out.add(", ");
        addParam(out, param, &params[i-1]);
        out.print(" %%a%u", i);
    }
    if (fd.isVariadic()) {
        if (num_params) out.add(", ");
        out.add("...");
    }
    out.add(") {\n");

    out.print("@start.%u\n", gen.func_idx);
    // for struct by Value, use alloc4 12 (12 = size), alloc4 for alignment
    for (u32 i=1; i<=num_params; i++) {
        const Param* p = &params[i-1];
        out.print("\t%%.%u = l alloc%u %u\n", i, p.align < 8 ? 4 : 8, p.size);
        // NOTE: not correct for StructValues yet!
        out.print("\tstore%c %%a%u, %%.%u\n", align2store(p.align), i, i);
    }

    u32 var_idx = num_params; // is first free number
    out.print("@body.%u\n", gen.func_idx);
    // TODO body

    out.add1('\t');
    if (fd.hasReturn()) {
        out.add("ret <TODO>\n");
    } else {
        out.add("ret\n");
    }
    out.add("}\n");
    gen.func_idx++;
}

func void generateArrayInit(string_buffer.Buf* out, const ArrayType* at, const Expr* e) {
    u32 size = at.getSize();
    if (e.getKind() == ExprKind.StringLiteral) {
        // IDEA: create insert function in stringBuffer to allow insertion of stuff afterwards.
        // This makes it much easier to do this
        // Depends on whether type is array or pointer, for array do inline, for ptr generate
        // string constant.
        return;
    }
    // TODO special case for StringLiteral
    assert(e.getKind() == ExprKind.InitList);
    const InitListExpr* ile = cast<InitListExpr*>(e);
}

func void generateStructInit(string_buffer.Buf* out, const StructType* st, const Expr* e) {
}

func void Generator.handleVarDecl(Generator* gen, Decl* d) {
    // Note: all struct types have been generated already
    const VarDecl* vd = cast<VarDecl*>(d);
    string_buffer.Buf* out = gen.out;
    QualType qt = d.getType();
    u32 align = qt.getAlignment();  // TODO add convenience function to Decl? (saves copies)
    u32 size = qt.getSize();  // TODO add convenience function to Decl? (saves copies)
    // TODO dont generate CTV variables (add bit in VarDecl? is_constant)

    if (d.isPublic()) out.add("export ");

    out.add("data ");
    addGlobalName(out, d);
    out.print(" = align %u { ", align);

    const Expr* initExpr = vd.getInit();
    if (initExpr) {
        ArrayType* at = qt.getArrayTypeOrNil();
        const StructType* st = qt.getStructTypeOrNil();
        if (at) {
            generateArrayInit(out, at, initExpr);
        } else if (st) {
            generateStructInit(out, st, initExpr);
        } else {
            out.print("z %u TODO", size);
        }
    } else {
        out.print("z %u", size);
    }

    out.add(" }\n");

}

func void addMember(string_buffer.Buf* out, QualType qt) {
    const StructType* s = qt.getStructTypeOrNil();
    if (s) {
        addStructName(out, cast<Decl*>(s.getDecl()));
        return;
    }
    const ArrayType* a = qt.getArrayTypeOrNil();
    u32 align = qt.getAlignment();
    if (a) {
        // note: for multi-dimensional arrays, multiply all sizes
        u32 size = a.getSize();
        while (1) {
            qt = a.getElemType();
            a = qt.getArrayTypeOrNil();
            if (!a) break;
            size *= a.getSize();
        }
        out.add1(align2char(align));
        out.print(" %u", size);
        return;
    }
    out.add1(align2char(align));
}

func void Generator.createStruct(Generator* gen, Decl* d, bool is_global) {
    //struct:  type :.2 = { w, w, b, }
    //union:  type :anon0 = { { w } { b } }
    StructTypeDecl* s = cast<StructTypeDecl*>(d);
    if (s.isGenerated()) return;
    string_buffer.Buf* out = gen.out;

    const u32 num_members = s.getNumMembers();
    Decl** members = s.getMembers();

    // 2-passes are needed: one to create sub-struct types one to create struct

    // pass 1: create sub-structs/unions (recursively) also create other (full)used structs
    // mark as generated (in AST)
    u32[20] subs; // max number of subscripts at one level
    u32 numsubs = 0;

    for (u32 i=0; i<num_members; i++) {
        Decl* member = members[i];
        if (member.getKind() == DeclKind.StructType) {
            gen.createStruct(member, false);
            subs[numsubs] = substruct_idx-1;
            numsubs++;
        } else {
            assert(member.getKind() == DeclKind.Var);
            // if VarDecl is StructType, generate that first (not if Struct*)
            QualType qt = member.getType();
            StructType* st = qt.getStructTypeOrNil();
            if (st) {
                StructTypeDecl* s2 = st.getDecl();
                if (!s2.isGenerated()) {
                    gen.createStruct(cast<Decl*>(s2), true);
                }
            }
        }
    }

    // pass 2: create this struct
    numsubs = 0;
    out.add("type ");
    if (is_global) {
        addStructName(out, cast<Decl*>(s));
    } else {
        out.print(":anon%u", substruct_idx);
        substruct_idx++;
    }
    out.add(" = { ");
    if (s.isStruct()) {
        for (u32 i=0; i<num_members; i++) {
            const Decl* member = members[i];
            if (i != 0) out.add(", ");
            if (member.getKind() == DeclKind.StructType) {
                out.print(":anon%u", subs[numsubs]);
                numsubs++;
            } else {
                addMember(out, member.getType());
            }
        }
    } else {
        // Union: type :test = { { w } { b 12 } }
        for (u32 i=0; i<num_members; i++) {
            const Decl* member = members[i];
            if (i != 0) out.add(" ");
            out.add("{ ");
            if (member.getKind() == DeclKind.StructType) {
                out.print(":anon%u", subs[numsubs]);
                numsubs++;
            } else {
                addMember(out, member.getType());
            }
            out.add(" }");
        }
    }
    s.setGenerated();
    out.add(" }\n");
}

func void Generator.handleStruct(Generator* gen, Decl* d) {
    gen.createStruct(d, true);
}

func void Generator.on_decl(void* arg, Decl* d) {
    Generator* gen = arg;
    switch (d.getKind()) {
    case Function:
        if (!gen.cur_external) gen.handleFunction(d);
        break;
    case Import:
        return;
    case StructType:
        gen.handleStruct(d);
        break;
    case EnumType:
        break;
    case EnumConstant:
        break;
    case FunctionType:
        break;
    case AliasType:
        break;
    case Var:
        gen.handleVarDecl(d);
        break;
    case StaticAssert:
        break;
    }
}

func void Generator.on_ast(void* arg, AST* a) {
    Generator* gen = arg;
    a.visitDecls(Generator.on_decl, arg);
}

func void Generator.on_module(void* arg, Module* m) {
    if (m.isUsed()) {
        Generator* gen = arg;
        gen.out.print("\n# --- module %s ---\n\n", m.getName());
        m.visitASTs(Generator.on_ast, arg);
    }
}

func void Generator.init(Generator* gen, const char* output_dir) {
    string.memset(gen, 0, sizeof(Generator));
    gen.out = string_buffer.create(256*1024, false);
    gen.output_dir = output_dir;
    gen.func_idx = 1;
}

func void Generator.free(Generator* gen) {
    gen.out.free();
}

func void Generator.write(Generator* gen, const char* output_dir, const char* filename) {
    //printf("%s\n", gen.out.data());

    char[256] fullname;
    sprintf(fullname, "%s/%s", output_dir, filename);

    file_utils.Writer writer;
    bool ok = writer.write(fullname, gen.out.data(), gen.out.size());
    // TODO check ok
}

func void Generator.createMakefile(Generator* gen, const char* output_dir) {
    string_buffer.Buf* out = gen.out;
    out.clear();
    out.add("# This makefile is auto-generated, any modifications will be lost\n\n");
    const char* target = "test";
    out.print("%s: main.o\n", target);
    out.print("\t\tgcc main.o -o %s\n\n", target);

    out.add("main.o: main.s\n");
    out.add("\t\tas main.s -o main.o\n\n");

    out.add("main.s: main.qbe\n");
    out.add("\t\tqbe -t amd64_sysv main.qbe -o main.s\n\n");

    // alt to avoid GCC: (Linux specific)
    // LIBDIR=/usr/lib/x86_64-linux-gnu
    // LOADER=/lib64/ld-linux-x86-64.so.2
    // ld -dynamic-linker $(LOADER) -o test main.o $(LIBDIR)/Scrt1.o $(LIBDIR)/libc.so $(LIBDIR)/crti.o $(LIBDIR)/crtn.o

    out.add("clean:\n");
    out.add("\t\trm -f main.o main.s test\n\n");

    gen.write(output_dir, "Makefile");
}

public func void generate(const char* output_dir, component.Component** comps, u32 count) {
    // TODO put in aux-pool? (lowers stack-size)
    char[256] qbe_dir;
    sprintf(qbe_dir, "%s/%s", output_dir, QBE_Dir);
    i32 err = file_utils.create_directory(qbe_dir);
    if (err) {
        fprintf(stderr, "Error creating directory %s: %s\n", qbe_dir, string.strerror(err));
        return;
    }

    Generator gen;
    gen.init(qbe_dir);

    for (u32 i=0; i<count; i++) {
        component.Component* c = comps[i];
        gen.cur_external = c.isExternal();
        c.visitModules(Generator.on_module, &gen);
    }

    gen.write(qbe_dir, QBE_Filename);

    gen.createMakefile(qbe_dir);

    gen.free();
}


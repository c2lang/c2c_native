/* Copyright 2022 Bas van den Berg
*/

module c2c_main;

import source_mgr;
import c2_parser;
import string_list;
import c2recipe;
import constants;
import ast_context;
import ast_builder;
import component;
import string_pool;
import ast;
import utils;

// for sort
import linked_list;
import stdlib;
import string;

import stdio local;

type ModuleSorter struct {
    u32 num_mods;
    ast.Module** modules;
    u8* array;
    u32 cur_mod_idx;
}

func void ModuleSorter.print(const ModuleSorter* s) {
    printf("                     |");
    for (u32 y=0; y<s.num_mods; y++) {
        printf(" %2u", y);
    }
    printf("\n");
    for (u32 y=0; y<s.num_mods; y++) {
        printf("%16s  %2u |", s.modules[y].getName(), y);
        for (u32 x=0; x<s.num_mods; x++) {
            u8 value = s.array[y * s.num_mods + x];
            printf("  %c", value ? 'X' : ' ');
        }
        printf("\n");
    }
}

func void ModuleSorter.sort(component.Component* c) {
    const u32 count = c.getNumModules();
    if (count <= 1) return;

    ModuleSorter s;
    s.num_mods = count;
    s.cur_mod_idx = 0;

    u64 t1 = utils.now();
    // preparation
    ast.Module** orig = c.getModules();
    s.modules = stdlib.malloc(count * sizeof(ast.Module*));
    string.memcpy(cast<void*>(s.modules), cast<void*>(orig), count*sizeof(ast.Module*));
    s.array = stdlib.calloc(1, count * (count + 2));  // one extra line for todo, one for results

    // fill deps
    c.visitModules(ModuleSorter.handleModule, &s);

    // sort
    u8* todo = &s.array[count*count];
    string.memset(todo, 1, count);
    u8* sorted = &s.array[count*(count+1)];
    u32 num_sorted = 0;
    //s.print();
    u32 left = count;
    while (left) {
        u32 start = left;
        for (u32 i=0; i<count; i++) {
            if (todo[i] == 0) continue;
            u32 offset = i*count;
            bool has_deps = false;
            for (u32 j=0; j<count; j++) {
                if (s.array[offset + j] != 0) {
                    has_deps = true;
                    break;
                }
            }
            if (!has_deps) {
                sorted[num_sorted] = cast<u8>(i);
                todo[i] = 0;
                num_sorted++;
                left--;
                for (u32 x=0; x<count; x++) s.array[x*count + i] = 0;
                //s.print();
            }
        }
        if (start == left) {
            fprintf(stderr, "circular dependency detected\n");
            // TODO print dependency
            goto out;
        }
    }
    u64 t2 = utils.now();
    printf("sorting %u modules took %lu usec\n", count, t2 - t1);

    // re-order results
    for (u32 i=0; i<count; i++) {
        orig[i] = s.modules[sorted[i]];
    }

out:
    stdlib.free(cast<void*>(s.modules));
    stdlib.free(s.array);
}

func void ModuleSorter.handleModule(void* arg, ast.Module* mod) {
    ModuleSorter* s = arg;
    mod.visitImports(ModuleSorter.handleImport, arg);
    s.cur_mod_idx++;
}

func void ModuleSorter.handleImport(void* arg, ast.ImportDecl* d) {
    ModuleSorter* s = arg;
    ast.Module* dest = d.asDecl().getModule();
    if (!dest) return;  // ignore for now, later, check if same Component

    u32 dest_idx = s.mod2idx(dest);
    u32 offset = s.cur_mod_idx * s.num_mods + dest_idx;
    s.array[offset] = 1;
}

func u32 ModuleSorter.mod2idx(const ModuleSorter* s, const ast.Module* mod) {
    for (u32 i=0; i<s.num_mods; i++) {
        if (s.modules[i] == mod) return i;
    }
    //assert(0);
    return 0;   // should not happen
}

func void handleImport(void* arg, ast.ImportDecl* d) {
    // TODO normally have list of all modules (of all Components)
    component.Component* c = arg;

    const char* name = d.asDecl().getName();
    ast.Module* m = c.findModule(name);
    if (m) {
        d.setModule(m);
    } else {
        // normally error, no external components yet
    }
}

public func void resolve_imports(component.Component* c) {
    c.visitImports(handleImport, c);
}

public func i32 main(i32 argc, char** argv) {
    bool single_file = false; // TODO parse

    if (argc > 2) {
        printf("usage: %s <file>\n", argv[0]);
        return -1;
    }

    if (argc > 1) single_file = true;

    // note: auxPool is used by recipe and build-file
    string_pool.Pool* auxPool = string_pool.create(64*1024, 0);

    source_mgr.SourceMgr* sm = source_mgr.create();

    // TODO add -f option. Still has recipe, only adds 1 target + file

    c2recipe.Recipe* recipe = c2recipe.create(sm, auxPool);

    i32 recipe_id = -1;

    if (single_file) {
        const char* filename = argv[1]; // TODO parse
        recipe.addDummyTarget(filename);
    } else {
        if (!utils.findProjectDir()) {
            fprintf(stderr, "c2c: error: cannot find C2 root dir\n");
            fprintf(stderr, "c2c requires a %s file in the project root\n", constants.recipe_name);
            fprintf(stderr, "Use argument -h for a list of available options and usage of c2c\n");
            return -1;
        }

        recipe_id = sm.open(constants.recipe_name, 0);
        if (recipe_id == -1) return -1;
        if (!recipe.parse(recipe_id)) return -1;
    }

    //recipe.dump();

    ast_context.Context* typeContext = ast_context.create(1024);
    // TODO re-init for each target, since the pointers to these types change!!
    ast.init(typeContext);

    for (u32 i=0; i<recipe.numTargets(); i++) {
        c2recipe.Target* target = recipe.getTarget(i);

        printf("building %s\n", target.getName());

        ast_context.Context* context = ast_context.create(16*1024);
        string_pool.Pool* pool = string_pool.create(1024*1024, 2048);
        component.Component* comp = component.create();
        ast_builder.Builder* builder = ast_builder.create(context, comp);

        // TODO get from recipe/target
        // TODO dynamic sizing
        string_list.List features;
        features.init(64);
        features.add("feature_a");

        u64 total_time = 0;
        for (u32 j=0; j<target.numFiles(); j++) {
            i32 file_id = target.openFile(j);
            if (file_id == -1) return -1;   // note: error already printed

            const char* filename = sm.getFileName(file_id);
            //printf("parsing %s\n", filename);


            c2_parser.Parser* parser = c2_parser.create(sm, file_id, builder, pool, &features, false);
            u64 t1 = utils.now();
            bool ok = parser.parse();
            u64 t2 = utils.now();
            total_time += (t2 - t1);
            //if (ok) parser.dump();
            //printf("parsing %s took %lu usec\n", sm.getFileName(file_id), t2 - t1);

            parser.free();
        }
        printf("parsing took %lu usec\n", total_time);
#if DumpTokens
#else
        context.dump();
        pool.dump();
#endif
        //comp.info();
        resolve_imports(comp);
        ModuleSorter.sort(comp);
        //comp.print();
        builder.free();
        comp.free();
        pool.free();
        context.free();
        if (recipe_id != -1) sm.clear(cast<u32>(recipe_id));
    }

    recipe.free();
    auxPool.free();
    typeContext.free();
    sm.free();

	return 0;
}


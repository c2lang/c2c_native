module c2c_main;

import c2_tokenizer local;
import c2_source_mgr local;
import color;

import stdio local;
import string local;
import sys_time;

// TODO move to utils
func u64 now() {
    sys_time.Timeval tv;
    sys_time.gettimeofday(&tv, nil);
    u64 now64 = cast<u64>(tv.tv_sec);
    now64 *= 1000000;
    now64 += tv.tv_usec;
    return now64;
}

// TEMP HERE
char[1024*1024] alloc_buf;
u32 alloc_idx;

func const char* alloc(void* arg, const char* value, u32 len) {
    char* start = alloc_buf + alloc_idx;
    memcpy(start, value, len);
    alloc_idx += len;
    alloc_buf[alloc_idx] = 0;
    alloc_idx++;
    return start;
}

SourceMgr* sm;

public func void dump_token(const Token* tok) {
    if (tok.kind >= TokenKind.KW_as && tok.kind <= TokenKind.KW_while) {
        printf("%s%10s%s", color.Green, tok.str(), color.Normal);
        return;
    }
    printf("%10s   %u TODO", tok.str(), tok.loc.loc);
    switch (tok.kind) {
    case TokenKind.Identifier:
        printf("  %s%s%s", color.Cyan, tok.text_value, color.Normal);
        break;
    case TokenKind.NumberLiteral:
        printf("  %s%s%s", color.Cyan, tok.text_value, color.Normal);
        break;
    case TokenKind.Error:
        printf("  %s%s%s", color.Red, tok.error_msg, color.Normal);
        break;
    default:
        break;
    }
    printf("\n");
}


func void parse_file(i32 sm_handle) {
    Tokenizer tokenizer;
    char[256] error_msg;
    error_msg[0] = 0;
    alloc_idx = 0;
    tokenizer.init(sm.get_content(sm_handle), sm.get_offset(sm_handle), error_msg, alloc, nil);
    Token tok;
    tok.init();

    u32[enum_max(TokenKind)] count = { 0 }

    u64 t1 = now();
    u32 token_count = 0;
    while (tok.more) {
        tokenizer.lex(&tok);
        //dump_token(&tok);
        //count[tok.kind]++;
        token_count++;
    }
    if (tok.kind == TokenKind.Error) {
        c2_source_mgr.Location loc = sm.locate(tok.loc.loc);
        printf("%s:%u:%u: %serror:%s %s\n",  loc.filename, loc.line, loc.column, color.Red, color.Normal, tok.error_msg);
    }
    u64 t2 = now();

    printf("--- %u tokens (%u alloc)  (%llu usec) ---\n", token_count, alloc_idx, t2 - t1);
    for (u8 i=0; i<elemsof(count); i++) {
        if (count[i] == 0) continue;
        printf("%5u  %10s  %4.1f %%\n", count[i], kind2str(i), count[i] * 100.0 / token_count);
    }
}

public func i32 main(i32 argc, char** argv) {
    if (argc < 2) {
        printf("usage: %s [file]\n", argv[0]);
        return -1;
    }

    sm = SourceMgr.create();

    for (i32 i=1; i<argc; i++) {
        const char* filename = argv[i];
        printf("------ %s ------\n", filename);

        i32 file_id = sm.open(filename);
        if (file_id == -1) {
            fprintf(stderr, "Error opening file: %s\n", sm.get_error());
            return -1;
        }

        for (i32 j=0; j<100; j++) {
            parse_file(file_id);
        }
    }

    sm.free();

	return 0;
}

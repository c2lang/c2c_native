/* Copyright 2022 Bas van den Berg
*/

module c2c_main;

import source_mgr local;
import c2_parser local;
import string_list;
import c2recipe;
import constants;
import ast_context local;
import string_pool;
import ast;
import utils;

import stdio local;

public func i32 main(i32 argc, char** argv) {
    bool single_file = false; // TODO parse

    if (argc > 2) {
        printf("usage: %s <file>\n", argv[0]);
        return -1;
    }

    if (argc > 1) single_file = true;

    // note: auxPool is used by recipe and build-file
    string_pool.Pool* auxPool = string_pool.Pool.create(1024, 0);

    SourceMgr* sm = SourceMgr.create();

    Context* typeContext = Context.create(1024);
    ast.init(typeContext);


    // TODO add -f option. Still has recipe, only adds 1 target + file

    c2recipe.Recipe* recipe = c2recipe.create(sm, auxPool);

    i32 recipe_id = -1;

    if (single_file) {
        const char* filename = argv[1]; // TODO parse
        recipe.addDummyTarget(filename);
    } else {
        if (!utils.findProjectDir()) {
            fprintf(stderr, "c2c: error: cannot find C2 root dir\n");
            fprintf(stderr, "c2c requires a %s file in the project root\n", constants.recipe_name);
            fprintf(stderr, "Use argument -h for a list of available options and usage of c2c\n");
            return -1;
        }

        recipe_id = sm.open(constants.recipe_name, 0);
        if (recipe_id == -1) return -1;
        if (!recipe.parse(recipe_id)) return -1;
    }

    //recipe.dump();

    for (u32 i=0; i<recipe.numTargets(); i++) {
        c2recipe.Target* target = recipe.getTarget(i);

        printf("building %s\n", target.getName());

        // TODO get from recipe/target
        string_list.List features;
        features.init(64);
        features.add("feature_a");

        Context* context = Context.create(16*1024);
        string_pool.Pool* pool = string_pool.Pool.create(8*1024, 2048);

        u64 total_time = 0;
        for (u32 j=0; j<target.numFiles(); j++) {
            i32 file_id = target.openFile(j);
            if (file_id == -1) return -1;   // note: error already printed

            //const char* filename = target.getFilename(j);
            Parser* parser = c2_parser.create(sm, file_id, context, pool, &features, false);
            u64 t1 = utils.now();
            bool ok = parser.parse();
/*
    parser parses file
    - builder get actOnModule()
        -> it gets module
        -> ast = module.createAST(filename, ..)
*/
            u64 t2 = utils.now();
            total_time += (t2 - t1);
            //if (ok) parser.dump();
            //printf("parsing %s took %lu usec\n", sm.getFileName(file_id), t2 - t1);

            parser.free();
            // Q: stop if !ok (or just parse all files)
        }
        printf("parsing took %lu usec\n", total_time);
#if DumpTokens
#else
            context.dump();
            pool.dump();
            //if (ok) parser.dump();
#endif
        pool.free();
        context.free();
        // TODO sm clear files upto recipe_id / build_file_id
    }

    recipe.free();
    auxPool.free();
    typeContext.free();
    sm.free();

	return 0;
}


/* Copyright 2022 Bas van den Berg
*/

module c2c_main;

import ast;
import ast_builder;
import ast_context;
import c2_parser;
import c2recipe;
import component;
import constants;
import manifest;
import module_list;
import module_sorter;
import source_mgr;
import string_list;
import string_pool;
import utils;

// for sort
import color;
import stdlib;

import stdio local;

// Q: put name in component?
// TODO or return/add Component?
func void parseLib(source_mgr.SourceMgr* sm,
                   string_pool.Pool* auxPool,
                   string_pool.Pool* astPool,
                   component.Component* comp,
                   const char* libname)
{
    const char* libdir = stdlib.getenv("C2_LIBDIR");
    if (!libdir) printf("Warning: environment variable C2_LIBDIR not set!\n");

    char[512] manifestFilename;
    i32 len = stdio.sprintf(manifestFilename, "%s/%s/manifest.yml", libdir, libname);
    const char* name = auxPool.add(manifestFilename, cast<usize>(len), 0);

    i32 file_id = sm.open(name, 0);
    if (file_id == -1) return;
    // TODO fill component with stuff from manifest
    //if (!recipe.parseYaml(file_id)) return;
    // NOTE: dont parse modules (interface files) yet, only if needed
    // TODO erro handling
    manifest.parse(sm, file_id, astPool, comp);
}

func void handleImport(void* arg, ast.ImportDecl* d) {
    // TODO normally have list of all modules (of all Components)
    component.Component* c = arg;

    const char* name = d.asDecl().getName();
    ast.Module* m = c.findModule(name);
    if (m) {
        d.setModule(m);
    } else {
        fprintf(stderr, "Error: Unknown module '%s'\n", name);
        stdlib.exit(-1);
    }
}

public func void resolve_imports(component.Component* c) {
    printf("%schecking imports%s\n", color.Yellow, color.Normal);
    c.visitImports(handleImport, c);
}


type Options struct {
    bool print_ast;
    const char* single_file;
}

func void usage(const char* me) {
    printf("Usage: %s <options> <filename>\n");
    stdlib.exit(-1);
}

func void parse_opts(i32 argc, char** argv, Options* opts) {
    for (i32 i=1; i<argc; i++) {
        const char* arg = argv[i];
        if (arg[0] == '-') {
            switch (arg[1]) {
            case 'a':
                opts.print_ast = true;
                break;
            }
        } else {
            if (opts.single_file) usage(argv[0]);
            opts.single_file = arg;
        }
    }
}

public func i32 main(i32 argc, char** argv) {
    Options opts = { 0 }

    parse_opts(argc, argv, &opts);

    // note: auxPool is used by recipe, build-file and manifests
    string_pool.Pool* auxPool = string_pool.create(64*1024, 0);

    source_mgr.SourceMgr* sm = source_mgr.create();

    // TODO add -f option. Still has recipe, only adds 1 target + file

    c2recipe.Recipe* recipe = c2recipe.create(sm, auxPool);

    i32 recipe_id = -1;

    if (opts.single_file) {
        recipe.addDummyTarget(opts.single_file);
    } else {
        if (!utils.findProjectDir()) {
            fprintf(stderr, "c2c: error: cannot find C2 root dir\n");
            fprintf(stderr, "c2c requires a %s file in the project root\n", constants.recipe_name);
            fprintf(stderr, "Use argument -h for a list of available opts and usage of c2c\n");
            return -1;
        }

        i32 yaml_id = sm.open(constants.recipe_name, 0);
        if (yaml_id == -1) return -1;
        if (!recipe.parse(yaml_id)) return -1;

        // TEMP also parse yaml version
        recipe_id = sm.open("c2recipe.yml", 0);
        if (recipe_id == -1) return -1;
        if (!recipe.parseYaml(recipe_id)) return -1;
    }

    //recipe.dump();

    for (u32 i=0; i<recipe.numTargets(); i++) {
        c2recipe.Target* target = recipe.getTarget(i);

        printf("building %s\n", target.getName());

        ast_context.Context* context = ast_context.create(16*1024);
        string_pool.Pool* astPool = string_pool.create(1024*1024, 2048);
        ast_builder.Builder* builder = ast_builder.create(context);
        ast.init(context, astPool.getStart(), astPool);

        module_list.ModList* modlist = module_list.create(false);

        component.Component* libcComponent = component.create(modlist);
        builder.setComponent(libcComponent);
        // TODO parse manifest
        // NOTE: HMM manifest filename should go into auxPool, module-names into normal astPool
        parseLib(sm, auxPool, astPool, libcComponent, "libc");

        component.Component* mainComp = component.create(modlist);
        builder.setComponent(mainComp);

        // TODO get from recipe/target
        // TODO dynamic sizing
        string_list.List features;
        features.init(64);
        features.add("feature_a");

        printf("%sparsing %s%s\n", color.Yellow, target.getName(), color.Normal);
        u64 total_time = 0;
        for (u32 j=0; j<target.numFiles(); j++) {
            i32 file_id = target.openFile(j);
            if (file_id == -1) return -1;   // note: error already printed

            const char* filename = sm.getFileName(file_id);
            //printf("parsing %s\n", filename);

            c2_parser.Parser* parser = c2_parser.create(sm, file_id, builder, astPool, &features, false);
            u64 t1 = utils.now();
            bool ok = parser.parse();
            u64 t2 = utils.now();
            total_time += (t2 - t1);
            //printf("parsing %s took %lu usec\n", sm.getFileName(file_id), t2 - t1);

            parser.free();
        }
        printf("parsing took %lu usec\n", total_time);
#if DumpTokens
#else
        context.dump();
        astPool.dump();
#endif
        //libcComponent.info();
        //mainComp.info();

        //resolve_imports(mainComp);
        //module_sorter.sort(mainComp);

        if (opts.print_ast) mainComp.print();

        modlist.free();
        builder.free();
        mainComp.free();
        astPool.free();
        context.free();
        if (recipe_id != -1) sm.clear(cast<u32>(recipe_id));
    }

    recipe.free();
    auxPool.free();
    sm.free();

	return 0;
}


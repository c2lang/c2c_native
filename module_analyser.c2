/* Copyright 2022 Bas van den Berg
*/

module module_analyser;

import source_mgr;
import ast;

import string;
import stdio local; // TEMP

type ModuleAnalyser struct {
    ast.Module* mod;
    source_mgr.SourceMgr* sm;
}

public func void check(source_mgr.SourceMgr* sm, ast.Module* mod) {
    ModuleAnalyser ma;
    string.memset(&ma, 0, sizeof(ma));
    ma.sm = sm;
    ma.mod = mod;

    // NOTE: C2C ModuleAnalyser::step1()
    // step 3a: collect incremental arrays
    // TODO use visitIncrArrays()
    // step 3b: collect struct functions
    // TODO use visitStructFunctions();
    mod.visitStructFunctions(ModuleAnalyser.handleStructFunc, &ma);

    // NOTE: C2C ModuleAnalyser::step2()
    // analyse types
    // analyse vars
    // analyse static asserts
    // analyse function protos

    // NOTE: C2C ModuleAnalyser::step3()
    // analyse functionbodies
}

func void ModuleAnalyser.handleStructFunc(void* arg, ast.FunctionDecl* d) {
    ModuleAnalyser* ma = arg;
    printf("analysing module %s\n", ma.mod.getName());
    ast.IdentifierExpr* prefix = d.getPrefix();
    const char* prefix_name = prefix.getName();
    // assert(prefix)
    printf("  %s %s\n", prefix_name, d.asDecl().getName());
    //d.asDecl().dump();

    /*
        TODO we need to put this inside ModuleAnalyser, so it knows which Module we are working on
        TODO also since we do symbol lookup, create Scope for Module?
            -> could be duplicates with 'local imported' modules, so need smart Scope

        search prefix_name in vector, compare by pointer
        if (found) {
            // TypeDecl already found, get it from 2nd vector
        } else {
            search Scope for prefix_name (not only TypeDecls!)
            search TypeDecl, check if struct/union
            add to data-structure.
        }
        add FunctionDecl in another vector with same index as name vector
            check for duplicate names
        set Decl inside (IdentifierExpr) prefix
    */
}

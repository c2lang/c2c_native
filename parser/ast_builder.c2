/* Copyright 2022 Bas van den Berg
*/

module ast_builder;

import ast local;
import ast_context local;
import component;
import diagnostics;
import token local;
import utils local;

import stdlib local;
import stdio;

public type Builder struct {
    Context* context;
    diagnostics.Diags* diags;
    component.Component* comp;
    Module* mod;
    AST* ast;
    u32 ast_idx;
    bool is_interface;
} @(opaque)

public func Builder* create(Context* context, diagnostics.Diags* diags) {
    Builder* b = calloc(1, sizeof(Builder));
    b.context = context;
    b.diags = diags;

    return b;
}

public func void Builder.free(Builder* b) {
    free(b);
}

public func void Builder.setComponent(Builder* b, component.Component* comp) {
    b.comp = comp;
    b.mod = nil;
    // TEMP
    b.is_interface = comp.isExternal();
}

public func void Builder.actOnModule(Builder* b, u32 mod_name, SrcLoc mod_loc, const char* filename) {
    assert(b.comp);
    b.mod = b.comp.getOrAddModule(mod_name);
    if (!b.mod) {
        b.diags.report(mod_loc, "module %s is already defined in another component", mod_name);
        stdlib.exit(-1);
    }
    b.ast = b.mod.add(filename);
    b.ast_idx = b.ast.getIdx();

    // NOTE: make special ImportDecl to add own symbols
    ImportDecl* i = ImportDecl.create(b.context, mod_name, mod_loc, 0, 0, b.ast_idx, true);
    Decl* d = cast<Decl*>(i);
    d.setUsed();
    d.setChecked();
    i.setDest(b.mod);
    d.setType(QualType.init(cast<Type*>(b.mod.getType())));
    b.ast.addImport(i);
}

public func void Builder.actOnImport(Builder* b, u32 mod_name, SrcLoc mod_loc, u32 alias_name, SrcLoc alias_loc, bool islocal) {
    // TODO check for duplicates
    ImportDecl* d = ImportDecl.create(b.context, mod_name, mod_loc, alias_name, alias_loc, b.ast_idx, islocal);
    b.ast.addImport(d);
}

public func Decl* Builder.actOnAliasType(Builder* b, u32 name, SrcLoc loc, bool is_public, const TypeRefHolder* ref) {
    is_public |= b.is_interface;
    AliasTypeDecl* d = AliasTypeDecl.create(b.context, name, loc, is_public, b.ast_idx, ref);
    b.ast.addTypeDecl(d.asDecl());
    Decl* dd = d.asDecl();
    b.addSymbol(name, dd);
    return dd;
}

public func Decl* Builder.actOnFunctionTypeDecl(Builder* b,
                                                u32 name,
                                                SrcLoc loc,
                                                bool is_public,
                                                const TypeRefHolder* rtype,
                                                VarDecl** params,
                                                u32 num_params,
                                                bool is_variadic)
{
    is_public |= b.is_interface;
    FunctionDecl* fn = FunctionDecl.create(b.context, name, loc, is_public, b.ast_idx, rtype, nil, params, num_params, is_variadic);

    FunctionTypeDecl* d = FunctionTypeDecl.create(b.context, fn);
    b.ast.addTypeDecl(d.asDecl());
    Decl* dd = d.asDecl();
    b.addSymbol(name, dd);
    return dd;
}

public func StructTypeDecl* Builder.actOnStructType(Builder* b,
                                                    u32 name,
                                                    SrcLoc loc,
                                                    bool is_public,
                                                    bool is_struct,
                                                    bool is_global,
                                                    VarDecl** members,
                                                    u32 num_members)
{
    is_public |= b.is_interface;
    StructTypeDecl* d = StructTypeDecl.create(b.context, name, loc, is_public, b.ast_idx, is_struct, is_global, members, num_members);
    if (is_global) {
        b.ast.addTypeDecl(d.asDecl());
        b.addSymbol(name, d.asDecl());
    }
    return d;
}

public func VarDecl* Builder.actOnStructMember(Builder* b,
                                               u32 name,
                                               SrcLoc loc,
                                               bool is_public,
                                               const TypeRefHolder* ref,
                                               Expr* bitfield)
{
    is_public |= b.is_interface;
    return VarDecl.createStructMember(b.context, name, loc, is_public, ref, b.ast_idx, bitfield);
}

public func void Builder.actOnGlobalVarDecl(Builder* b, u32 name, SrcLoc loc, bool is_public, TypeRefHolder* ref, Expr* initValue) {
    is_public |= b.is_interface;
    VarDecl* d = VarDecl.create(b.context, VarDeclKind.GlobalVar, name, loc, is_public, ref, b.ast_idx, initValue);
    Decl* dd = d.asDecl();
    b.ast.addVarDecl(dd);
    b.addSymbol(name, dd);
}

public func VarDecl* Builder.actOnFunctionParam(Builder* b, u32 name, SrcLoc loc, bool is_public, const TypeRefHolder* ref, Expr* initValue) {
    is_public |= b.is_interface;
    return VarDecl.create(b.context, VarDeclKind.FunctionParam, name, loc, is_public, ref, b.ast_idx, initValue);
}

public func Stmt* Builder.actOnVarDeclStmt(Builder* b, u32 name, SrcLoc loc, const TypeRefHolder* ref, Expr* initValue, bool has_local) {
    VarDecl* d = VarDecl.create(b.context, VarDeclKind.LocalVar, name, loc, false, ref, b.ast_idx, initValue);
    d.setLocal(has_local);

    return cast<Stmt*>(DeclStmt.create(b.context, d));
}

public func void Builder.actOnAttr(Builder* b, u32 name, SrcLoc begin_loc, SrcLoc end_loc) {
    //printf("ATTR  %s\n", name);
}

public func QualType Builder.actOnBuiltinType(Builder* b, BuiltinTypeKind kind) {
    //TODO convert to table (use kind as index)
    switch (kind) {
    case Char:      return g_char;
    case Int8:      return g_i8;
    case Int16:     return g_i16;
    case Int32:     return g_i32;
    case Int64:     return g_i64;
    case UInt8:     return g_u8;
    case UInt16:    return g_u16;
    case UInt32:    return g_u32;
    case UInt64:    return g_u64;
    case Float32:   return g_f32;
    case Float64:   return g_f64;
    case ISize:     return g_isize;
    case USize:     return g_usize;
    case Bool:      return g_bool;
    case Void:      return g_void;
    }
    assert(0);
    return QualType_Invalid;
}

public func QualType Builder.actOnPointerType(Builder* b, QualType inner) {
    QualType ptr = QualType.init(ast.getPointerType(inner));

    // canonical can be either self or a pointer to elem's canonical type
    QualType canon = inner.getCanonicalType();
    if (inner.getTypeOrNil() == canon.getTypeOrNil()) {
        canon = ptr;
    } else {
        canon = QualType.init(ast.getPointerType(canon));
    }
    ptr.setCanonicalType(canon);

    return ptr;
}

public func QualType Builder.actOnArrayType(Builder* b, QualType elem, bool has_size, u32 size) {
    ArrayType* t = ArrayType.create(b.context, elem, has_size, size);
    QualType a = QualType.init(cast<Type*>(t));

    // canonical can be either self or a pointer to elem's canonical type
    QualType canon = elem.getCanonicalType();
    if (elem.getTypeOrNil() == canon.getTypeOrNil()) {
        canon = a;
    } else {
        ArrayType* t2 = ArrayType.create(b.context, canon, has_size, size);
        // Note: keep same quals here, even if canonical type may be a PointerType!
        canon = QualType.init(cast<Type*>(t2));
    }
    a.setCanonicalType(canon);

    return a;
}

public func FunctionDecl* Builder.actOnFunctionDecl(Builder* b,
                                                    u32 name,
                                                    SrcLoc loc,
                                                    bool is_public,
                                                    const TypeRefHolder* rtype,
                                                    IdentifierExpr* prefix,
                                                    VarDecl** params,
                                                    u32 num_params,
                                                    bool is_variadic)
{
    FunctionDecl* f = FunctionDecl.create(b.context, name, loc, is_public, b.ast_idx, rtype, prefix, params, num_params, is_variadic);
    b.ast.addFunc(f);
    if (!prefix) b.addSymbol(name, f.asDecl());
    return f;
}

public func void Builder.actOnFunctionBody(Builder* b, FunctionDecl* f, CompoundStmt* body) {
    f.setBody(body);
}

public func EnumConstantDecl* Builder.actOnEnumConstant(Builder* b, u32 name, SrcLoc loc, bool is_public, Expr* init_expr) {
    return EnumConstantDecl.create(b.context, name, loc, is_public, b.ast_idx, init_expr);
}

public func void Builder.actOnEnumType(Builder* b,
                                       u32 name,
                                       SrcLoc loc,
                                       bool is_public,
                                       bool is_incr,
                                       QualType implType,
                                       EnumConstantDecl** constants,
                                       u32 num_constants)
{
    // TODO give error if zero constans
    EnumTypeDecl* d = EnumTypeDecl.create(b.context, name, loc, is_public, b.ast_idx, implType, is_incr, constants, num_constants);
    b.ast.addTypeDecl(d.asDecl());
    b.addSymbol(name, d.asDecl());
}

public func CompoundStmt* Builder.actOnCompoundStmt(Builder* b, Stmt** stmts, u32 count) {
    return CompoundStmt.create(b.context, stmts, count);
}

public func Stmt* Builder.actOnReturnStmt(Builder* b, SrcLoc loc, Expr* ret) {
    return cast<Stmt*>(ReturnStmt.create(b.context, loc, ret));
}

public func Stmt* Builder.actOnIfStmt(Builder* b, Stmt* cond, Stmt* then, Stmt* else_stmt) {
    return cast<Stmt*>(IfStmt.create(b.context, cond, then, else_stmt));
}

public func Stmt* Builder.actOnDoStmt(Builder* b, Stmt* cond, Stmt* then) {
    return cast<Stmt*>(DoStmt.create(b.context, cond, then));
}

public func Stmt* Builder.actOnWhileStmt(Builder* b, Stmt* cond, Stmt* then) {
    return cast<Stmt*>(WhileStmt.create(b.context, cond, then));
}

public func Stmt* Builder.actOnForStmt(Builder* b, Stmt* init_, Stmt* cond, Expr* incr, Stmt* body) {
    return cast<Stmt*>(ForStmt.create(b.context, init_, cond, incr, body));
}

public func Stmt* Builder.actOnSwitchStmt(Builder* b, Stmt* cond, Stmt** cases, u32 num_cases, bool is_sswitch) {
    return cast<Stmt*>(SwitchStmt.create(b.context, cond, cases, num_cases, is_sswitch));
}

public func Stmt* Builder.actOnDefaultStmt(Builder* b, SrcLoc loc, Stmt** stmts, u32 num_stmts) {
    return cast<Stmt*>(DefaultStmt.create(b.context, loc, stmts, num_stmts));
}

public func Stmt* Builder.actOnCaseStmt(Builder* b, SrcLoc loc, Expr* cond, Stmt** stmts, u32 num_stmts) {
    return cast<Stmt*>(CaseStmt.create(b.context, loc, cond, stmts, num_stmts));
}

public func Stmt* Builder.actOnAssertStmt(Builder* b, Expr* inner) {
    return cast<Stmt*>(AssertStmt.create(b.context, inner));
}

public func Stmt* Builder.actOnBreakStmt(Builder* b, SrcLoc loc) {
    return cast<Stmt*>(BreakStmt.create(b.context, loc));
}

public func Stmt* Builder.actOnContinueStmt(Builder* b, SrcLoc loc) {
    return cast<Stmt*>(ContinueStmt.create(b.context, loc));
}

public func Stmt* Builder.actOnFallthroughStmt(Builder* b, SrcLoc loc) {
    return cast<Stmt*>(FallthroughStmt.create(b.context, loc));
}

public func Stmt* Builder.actOnLabelStmt(Builder* b, u32 name, SrcLoc loc) {
    return cast<Stmt*>(LabelStmt.create(b.context, name, loc));
}

public func Stmt* Builder.actOnGotoStmt(Builder* b, u32 name, SrcLoc loc) {
    return cast<Stmt*>(GotoStmt.create(b.context, name, loc));
}

public func IdentifierExpr* Builder.actOnIdentifier(Builder* b, SrcLoc loc, u32 name) {
    return IdentifierExpr.create(b.context, loc, name);
}

public func Expr* Builder.actOnIntegerLiteral(Builder* b, SrcLoc loc, const char* text) {
    u64 val;
    if (text[1] == 0) { // fast single digit path
        // TEMP
        val = cast<u64>(text[0] - '0');
    } else {
        val = strtoull(text, nil, 10);
    }
    return cast<Expr*>(IntegerLiteral.create(b.context, loc, val));
}

public func Expr* Builder.actOnCharLiteral(Builder* b, SrcLoc loc, u8 value) {
    return cast<Expr*>(CharLiteral.create(b.context, loc, value));
}

public func Expr* Builder.actOnStringLiteral(Builder* b, SrcLoc loc, u32 value) {
    return cast<Expr*>(StringLiteral.create(b.context, loc, value));
}

public func Expr* Builder.actOnNilExpr(Builder* b, SrcLoc loc) {
    return cast<Expr*>(NilExpr.create(b.context, loc));
}

public func Expr* Builder.actOnParenExpr(Builder* b, SrcLoc loc, Expr* inner) {
    return cast<Expr*>(ParenExpr.create(b.context, loc, inner));
}

func UnaryOpcode convertTokenToUnaryOpcode(Kind kind) {
    switch (kind) {
    case Exclaim: return UnaryOpcode.LNot;
    case Star: return UnaryOpcode.Deref;
    case Amp: return UnaryOpcode.AddrOf;
    case PlusPlus:   return UnaryOpcode.PreInc;
    case Minus: return UnaryOpcode.Minus;
    case MinusMinus: return UnaryOpcode.PreDec;
    case Tilde: return UnaryOpcode.Not;
    default:
        break;
    }
    // TODO fatal error
    return UnaryOpcode.PreInc;
}

public func Expr* Builder.actOnUnaryOperator(Builder* b, SrcLoc loc, Kind kind, Expr* inner) {
    UnaryOpcode opcode = convertTokenToUnaryOpcode(kind);
    return cast<Expr*>(UnaryOperator.create(b.context, loc, opcode, inner));
}

public func Expr* Builder.actOnPostFixUnaryOperator(Builder* b, SrcLoc loc, Kind kind, Expr* inner) {
    // can only be PlusPlus / MinusMinus
    UnaryOpcode opcode = (kind == Kind.PlusPlus) ? UnaryOpcode.PostInc : UnaryOpcode.PostDec;
    return cast<Expr*>(UnaryOperator.create(b.context, loc, opcode, inner));
}

func BinaryOpcode convertTokenToBinaryOpcode(Kind kind) {
    // TODO use lookup table (or single table with multiple entries for conversions?)
    switch (kind) {
    case Star: return BinaryOpcode.Multiply;
    case Slash: return BinaryOpcode.Divide;
    case Percent: return BinaryOpcode.Reminder;
    case Plus: return BinaryOpcode.Add;
    case Minus: return BinaryOpcode.Subtract;
    case LessLess: return BinaryOpcode.ShiftLeft;
    case GreaterGreater: return BinaryOpcode.ShiftRight;
    case Less: return BinaryOpcode.LessThan;
    case Greater: return BinaryOpcode.GreaterThan;
    case LessEqual: return BinaryOpcode.LessEqual;
    case GreaterEqual: return BinaryOpcode.GreaterEqual;
    case EqualEqual: return BinaryOpcode.Equal;
    case ExclaimEqual: return BinaryOpcode.NotEqual;
    case Amp: return BinaryOpcode.And;
    case Caret: return BinaryOpcode.Xor;
    case Pipe: return BinaryOpcode.Or;
    case AmpAmp: return BinaryOpcode.LAnd;
    case PipePipe: return BinaryOpcode.LOr;
    case Equal: return BinaryOpcode.Assign;
    case StarEqual: return BinaryOpcode.MulAssign;
    case SlashEqual: return BinaryOpcode.DivAssign;
    case PercentEqual: return BinaryOpcode.RemAssign;
    case PlusEqual: return BinaryOpcode.AddAssign;
    case MinusEqual: return BinaryOpcode.SubASsign;
    case LessLessEqual: return BinaryOpcode.ShlAssign;
    case GreaterGreaterEqual: return BinaryOpcode.ShrASsign;
    case AmpEqual: return BinaryOpcode.AndAssign;
    case CaretEqual: return BinaryOpcode.XorAssign;
    case PipeEqual: return BinaryOpcode.OrAssign;
    //case Comma: return BinaryOpcode.Comma;
    default:
        break;
    }
    // TODO fatal error
    return BinaryOpcode.Multiply;
}

public func Expr* Builder.actOnBinaryOperator(Builder* b, SrcLoc loc, Kind kind, Expr* lhs, Expr* rhs) {
    BinaryOpcode opcode = convertTokenToBinaryOpcode(kind);
    return cast<Expr*>(BinaryOperator.create(b.context, loc, opcode, lhs, rhs));
}

public func Expr* Builder.actOnConditionalOperator(Builder* b, SrcLoc questionLoc, SrcLoc colonLoc, Expr* cond, Expr* lhs, Expr* rhs) {
    return cast<Expr*>(ConditionalOperator.create(b.context, questionLoc, colonLoc, cond, lhs, rhs));
}

public func Expr* Builder.actOnBooleanConstant(Builder* b, SrcLoc loc, bool value) {
    return cast<Expr*>(BooleanLiteral.create(b.context, loc, value));
}

public func Expr* Builder.actOnBuiltinExpr(Builder* b, SrcLoc loc, Expr* inner, BuiltinExprKind kind) {
    return cast<Expr*>(BuiltinExpr.create(b.context, loc, inner, kind));
}

public func Expr* Builder.actOnOffsetOfExpr(Builder* b, SrcLoc loc, Expr* structExpr, Expr* member) {
    return cast<Expr*>(BuiltinExpr.createOffsetOf(b.context, loc, structExpr, member));
}

public func Expr* Builder.actOnToContainerExpr(Builder* b, SrcLoc loc, Expr* structExpr, Expr* member, Expr* pointer) {
    return cast<Expr*>(BuiltinExpr.createToContainer(b.context, loc, structExpr, member, pointer));
}

public func Expr* Builder.actOnTypeExpr(Builder* b, SrcLoc loc, const TypeRefHolder* ref) {
    return cast<Expr*>(TypeExpr.create(b.context, loc, ref));
}

public func Expr* Builder.actOnBitOffsetExpr(Builder* b, SrcLoc loc, Expr* lhs, Expr* rhs) {
    return cast<Expr*>(BitOffsetExpr.create(b.context, loc, lhs, rhs));
}

public func Expr* Builder.actOnArraySubscriptExpr(Builder* b, SrcLoc loc, Expr* base, Expr* idx) {
    return cast<Expr*>(ArraySubscriptExpr.create(b.context, loc, base, idx));
}

public func Expr* Builder.actOnCallExpr(Builder* b, Expr* fn, Expr** args, u32 num_args) {
    return cast<Expr*>(CallExpr.create(b.context, fn, args, num_args));
}

public func Expr* Builder.actOnExplicitCast(Builder* b, SrcLoc loc, const TypeRefHolder* ref, Expr* inner) {
    return cast<Expr*>(ExplicitCastExpr.create(b.context, loc, ref, inner));
}

public func Expr* Builder.actOnMemberExpr(Builder* b, Expr* base, SrcLoc loc, u32 member_name) {
    return cast<Expr*>(MemberExpr.create(b.context, base, loc, member_name));
}

public func Expr* Builder.actOnMultiMemberExpr(Builder* b, const Ref* refs, u32 refcount) {
    return cast<Expr*>(MemberExpr.create2(b.context, refs, refcount));
}

public func Expr* Builder.actOnInitList(Builder* b, SrcLoc left, SrcLoc right, Expr** values, u32 num_values) {
    return cast<Expr*>(InitListExpr.create(b.context, left, right, values, num_values));
}

public func Expr* Builder.actOnFieldDesignatedInit(Builder* b, u32 field, SrcLoc loc, Expr* initValue) {
    return cast<Expr*>(FieldDesignatedInitExpr.create(b.context, field, loc, initValue));
}

public func Expr* Builder.actOnArrayDesignatedInit(Builder* b, SrcLoc loc, Expr* designator, Expr* initValue) {
    return cast<Expr*>(ArrayDesignatedInitExpr.create(b.context, loc, designator, initValue));
}

public func void Builder.actOnStaticAssert(Builder* b, SrcLoc loc, Expr* lhs, Expr* rhs) {
    StaticAssertDecl* d = StaticAssertDecl.create(b.context, b.ast_idx, loc, lhs, rhs);
    b.ast.addStaticAssert(d);
}


public func void Builder.insertImplicitCast(Builder* b, ImplicitCastKind kind, Expr** e_ptr, QualType qt) {
    Expr* inner = *e_ptr;
    Expr* ic = cast<Expr*>(ImplicitCastExpr.create(b.context, inner.getLoc(), kind, inner));
    ic.setType(qt);
    *e_ptr = ic;
}

func void Builder.addSymbol(Builder* b, u32 name_idx, Decl* d) {
    Decl* old = b.mod.findSymbol(name_idx);
    if (old) {
        b.diags.report(d.getLoc(), "redefinition of '%s'", idx2name(name_idx));
        b.diags.note(old.getLoc(), "previous definition is here");
    } else {
        b.mod.addSymbol(name_idx, d);
    }
}


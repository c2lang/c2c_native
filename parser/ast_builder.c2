/* Copyright 2022 Bas van den Berg
*/

module ast_builder;

import ast local;
import ast_context local;
import component;
import tokens local;
import utils local;

import stdlib local;

public type Builder struct {
    Context* context;
    component.Component* comp;
    Module* mod;
    AST* ast;
} @(opaque)

public func Builder* create(Context* context) {
    Builder* b = calloc(1, sizeof(Builder));
    b.context = context;

    return b;
}

public func void Builder.free(Builder* b) {
    free(b);
}

public func void Builder.setComponent(Builder* b, component.Component* comp) {
    b.comp = comp;
    b.mod = nil;
    b.ast = nil;
}

public func void Builder.actOnModule(Builder* b, const char* mod_name, SrcLoc mod_loc, const char* filename) {
    // assert(b.comp);
    b.mod = b.comp.getOrAddModule(mod_name);
    b.ast = b.mod.add(filename);

    // NOTE: make special ImportDecl to add own symbols
    ImportDecl* d = ImportDecl.create(b.context, mod_name, mod_loc, nil, 0, true);
    d.setModule(b.mod);
    b.ast.addImport(d);
}

public func void Builder.actOnImport(Builder* b, const char* mod_name, SrcLoc mod_loc, const char* alias_name, SrcLoc alias_loc, bool islocal) {
    // TODO check for duplicates

    ImportDecl* d = ImportDecl.create(b.context, mod_name, mod_loc, alias_name, alias_loc, islocal);
    b.ast.addImport(d);
}

public func Decl* Builder.actOnAliasType(Builder* b, const char* name, SrcLoc loc, bool is_public, QualType refType) {
    AliasTypeDecl* d = AliasTypeDecl.create(b.context, name, loc, is_public, b.mod, refType);
    b.ast.addTypeDecl(d.asDecl());
    return d.asDecl();
}

public func Decl* Builder.actOnFunctionTypeDecl(Builder* b, const char* name, SrcLoc loc, bool is_public, QualType rtype,
                                                VarDecl** params, u32 num_params, bool is_variadic) {
    FunctionDecl* fn = FunctionDecl.create(b.context, name, loc, is_public, b.mod, rtype, nil, params, num_params, is_variadic);

    FunctionTypeDecl* d = FunctionTypeDecl.create(b.context, fn);
    b.ast.addTypeDecl(d.asDecl());
    return d.asDecl();
}

public func StructTypeDecl* Builder.actOnStructType(Builder* b, const char* name, SrcLoc loc, bool is_public, bool is_struct, bool is_global,
                                                    VarDecl** members, u32 num_members) {
    StructTypeDecl* d = StructTypeDecl.create(b.context, name, loc, is_public, b.mod, is_struct, is_global, members, num_members);
    if (is_global) b.ast.addTypeDecl(d.asDecl());
    return d;
}

public func VarDecl* Builder.actOnStructMember(Builder* b, const char* name, SrcLoc loc, bool is_public, QualType qt, Expr* bitfield) {
    return VarDecl.createStructMember(b.context, name, loc, is_public, qt, b.mod, bitfield);
}

public func VarDecl* Builder.actOnStructVar(Builder* b, const char* name, SrcLoc loc, bool is_public, QualType qt, Expr* initValue) {
    return VarDecl.create(b.context, VarDeclKind.StructMember, name, loc, is_public, qt, b.mod, initValue);
}

public func void Builder.actOnGlobalVarDecl(Builder* b, const char* name, SrcLoc loc, bool is_public, QualType qt, Expr* initValue) {
    VarDecl* d = VarDecl.create(b.context, VarDeclKind.GlobalVar, name, loc, is_public, qt, b.mod, initValue);
    b.ast.addVarDecl(d.asDecl());
}

public func VarDecl* Builder.actOnFunctionParam(Builder* b, const char* name, SrcLoc loc, bool is_public, QualType qt, Expr* initValue) {
    return VarDecl.create(b.context, VarDeclKind.FunctionParam, name, loc, is_public, qt, b.mod, initValue);
}

public func Stmt* Builder.actOnVarDeclStmt(Builder* b, const char* name, SrcLoc loc, QualType qt, Expr* initValue, bool has_local) {
    VarDecl* d = VarDecl.create(b.context, VarDeclKind.LocalVar, name, loc, false, qt, b.mod, initValue);
    d.setLocal(has_local);

    return cast<Stmt*>(DeclStmt.create(b.context, d));
}

public func void Builder.actOnAttr(Builder* b, const char* name, SrcLoc begin_loc, SrcLoc end_loc) {
    //printf("ATTR  %s\n", name);
}


public func QualType Builder.actOnBuiltinType(Builder* b, tokens.Kind kind) {
    Type* t = nil;
    // TODO lookup table -> fill in init with correct width for usize/isize, fill with QualType
    switch (kind) {
    case Kind.KW_u8:
        t = cast<Type*>(g_u8);
        break;
    case Kind.KW_u16:
        t = cast<Type*>(g_u16);
        break;
    case Kind.KW_u32:
        t = cast<Type*>(g_u32);
        break;
    case Kind.KW_u64:
        t = cast<Type*>(g_u64);
        break;
    case Kind.KW_usize:
        // TODO targetInfo.intWidth
        t = cast<Type*>(g_u64);
        break;
    case Kind.KW_i8:
        t = cast<Type*>(g_i8);
        break;
    case Kind.KW_i16:
        t = cast<Type*>(g_i16);
        break;
    case Kind.KW_i32:
        t = cast<Type*>(g_i32);
        break;
    case Kind.KW_i64:
        t = cast<Type*>(g_i64);
        break;
    case Kind.KW_isize:
        // TODO targetInfo.intWidth
        t = cast<Type*>(g_i64);
        break;
/*
    case Kind.KW_f32:
    case Kind.KW_f64:
    case Kind.KW_reg8:
    case Kind.KW_reg16:
    case Kind.KW_reg32:
    case Kind.KW_reg64:
*/
    case Kind.KW_char:
        t = cast<Type*>(g_i8);
        break;
    case Kind.KW_void:
        t = cast<Type*>(g_void);
        break;
    case Kind.KW_bool:
        t = cast<Type*>(g_bool);
        break;
    default:
        // fatal error
        break;
    }

    return QualType.init2(t);
}

public func QualType Builder.actOnRefType(Builder* b, IdentifierExpr* id, IdentifierExpr* prefix) {
    RefType* t = RefType.create(b.context, prefix, id);
    return QualType.init2(cast<Type*>(t));
}

public func QualType Builder.actOnPointerType(Builder* b, QualType inner, u32 qualifiers) {
    // TODO lookup if already exsts in TypeContext -> (not a normal Context)
    PointerType* t = PointerType.create(b.context, inner);
    return QualType.init(t.asType(), qualifiers);
}

public func QualType Builder.actOnArrayType(Builder* b, QualType elem, bool is_incremental, Expr* sizeExpr) {
    // TODO get from TypeContext?
    ArrayType* t = ArrayType.create(b.context, elem, is_incremental, sizeExpr);
    // NOTE: Context doesn't know AST/Types, just allocates!
    return QualType.init2(t.asType());
}

public func QualType Builder.actOnTypeQualifier(Builder* b, QualType qt, u32 qualifier) {
    QualType res = { qt.ptr | (qualifier & QualType_Mask) }
    return res;
}

public func FunctionDecl* Builder.actOnFunctionDecl(Builder* b,
                                                    const char* name,
                                                    SrcLoc loc,
                                                    bool is_public,
                                                    QualType rtype,
                                                    IdentifierExpr* prefix,
                                                    VarDecl** params,
                                                    u32 num_params,
                                                    bool is_variadic)
{
    FunctionDecl* f = FunctionDecl.create(b.context, name, loc, is_public, b.mod, rtype, prefix, params, num_params, is_variadic);
    b.ast.addFunc(f);
    return f;
}

public func void Builder.actOnFunctionBody(Builder* b, FunctionDecl* f, CompoundStmt* body) {
    f.setBody(body);
}

public func EnumConstantDecl* Builder.actOnEnumConstant(Builder* b, const char* name, SrcLoc loc, bool is_public, QualType qt, Expr* initial) {
    return EnumConstantDecl.create(b.context, name, loc, is_public, qt, b.mod, initial);
}

public func void Builder.actOnEnumType(Builder* b,
                                       const char* name,
                                       SrcLoc loc,
                                       bool is_public,
                                       bool is_incr,
                                       QualType implType,
                                       EnumConstantDecl** constants,
                                       u32 num_constants)
{
    EnumTypeDecl* d = EnumTypeDecl.create(b.context, name, loc, is_public, b.mod, implType, is_incr, constants, num_constants);
    b.ast.addTypeDecl(d.asDecl());
}

public func CompoundStmt* Builder.actOnCompoundStmt(Builder* b, Stmt** stmts, u32 count) {
    return CompoundStmt.create(b.context, stmts, count);
}

public func Stmt* Builder.actOnReturnStmt(Builder* b, SrcLoc loc, Expr* ret) {
    return cast<Stmt*>(ReturnStmt.create(b.context, loc, ret));
}

public func Stmt* Builder.actOnIfStmt(Builder* b, Stmt* cond, Stmt* then, Stmt* else_stmt) {
    return cast<Stmt*>(IfStmt.create(b.context, cond, then, else_stmt));
}

public func Stmt* Builder.actOnDoStmt(Builder* b, Stmt* cond, Stmt* then) {
    return cast<Stmt*>(DoStmt.create(b.context, cond, then));
}

public func Stmt* Builder.actOnWhileStmt(Builder* b, Stmt* cond, Stmt* then) {
    return cast<Stmt*>(WhileStmt.create(b.context, cond, then));
}

public func Stmt* Builder.actOnForStmt(Builder* b, Stmt* init_, Stmt* cond, Expr* incr, Stmt* body) {
    return cast<Stmt*>(ForStmt.create(b.context, init_, cond, incr, body));
}

public func Stmt* Builder.actOnSwitchStmt(Builder* b, Stmt* cond, Stmt** cases, u32 num_cases, bool is_sswitch) {
    return cast<Stmt*>(SwitchStmt.create(b.context, cond, cases, num_cases, is_sswitch));
}

public func Stmt* Builder.actOnDefaultStmt(Builder* b, SrcLoc loc, Stmt** stmts, u32 num_stmts) {
    return cast<Stmt*>(DefaultStmt.create(b.context, loc, stmts, num_stmts));
}

public func Stmt* Builder.actOnCaseStmt(Builder* b, SrcLoc loc, Expr* cond, Stmt** stmts, u32 num_stmts) {
    return cast<Stmt*>(CaseStmt.create(b.context, loc, cond, stmts, num_stmts));
}

public func Stmt* Builder.actOnBreakStmt(Builder* b, SrcLoc loc) {
    return cast<Stmt*>(BreakStmt.create(b.context, loc));
}

public func Stmt* Builder.actOnContinueStmt(Builder* b, SrcLoc loc) {
    return cast<Stmt*>(ContinueStmt.create(b.context, loc));
}

public func Stmt* Builder.actOnFallthroughStmt(Builder* b, SrcLoc loc) {
    return cast<Stmt*>(FallthroughStmt.create(b.context, loc));
}

public func Stmt* Builder.actOnLabelStmt(Builder* b, const char* name, SrcLoc loc) {
    return cast<Stmt*>(LabelStmt.create(b.context, name, loc));
}

public func Stmt* Builder.actOnGotoStmt(Builder* b, const char* name, SrcLoc loc) {
    return cast<Stmt*>(GotoStmt.create(b.context, name, loc));
}

public func IdentifierExpr* Builder.actOnIdentifier(Builder* b, SrcLoc loc, const char* name) {
    return IdentifierExpr.create(b.context, loc, name);
}

public func Expr* Builder.actOnIntegerLiteral(Builder* b, SrcLoc loc, const char* text) {
    u64 val;
    if (text[1] == 0) { // fast single digit path
        // TEMP
        val = cast<u64>(text[0] - '0');
    } else {
        val = strtoull(text, nil, 10);
    }
    return cast<Expr*>(IntegerLiteral.create(b.context, loc, val));
}

public func Expr* Builder.actOnCharLiteral(Builder* b, SrcLoc loc, u8 value) {
    return cast<Expr*>(CharLiteral.create(b.context, loc, value));
}

public func Expr* Builder.actOnStringLiteral(Builder* b, SrcLoc loc, const char* value) {
    return cast<Expr*>(StringLiteral.create(b.context, loc, value));
}

public func Expr* Builder.actOnNilExpr(Builder* b, SrcLoc loc) {
    return cast<Expr*>(NilExpr.create(b.context, loc));
}

public func Expr* Builder.actOnParenExpr(Builder* b, SrcLoc loc, Expr* inner) {
    return cast<Expr*>(ParenExpr.create(b.context, loc, inner));
}

func UnaryOpcode convertTokenToUnaryOpcode(Kind kind) {
    switch (kind) {
    case Kind.Exclaim: return UnaryOpcode.LNot;
    case Kind.Star: return UnaryOpcode.Deref;
    case Kind.Amp: return UnaryOpcode.AddrOf;
    case Kind.PlusPlus:   return UnaryOpcode.PreInc;
    case Kind.Minus: return UnaryOpcode.Minus;
    case Kind.MinusMinus: return UnaryOpcode.PreDec;
    case Kind.Tilde: return UnaryOpcode.Not;
    default:
        break;
    }
    // TODO fatal error
    return UnaryOpcode.PreInc;
}

public func Expr* Builder.actOnUnaryOperator(Builder* b, SrcLoc loc, Kind kind, Expr* inner) {
    UnaryOpcode opcode = convertTokenToUnaryOpcode(kind);
    return cast<Expr*>(UnaryOperator.create(b.context, loc, opcode, inner));
}

public func Expr* Builder.actOnPostFixUnaryOperator(Builder* b, SrcLoc loc, Kind kind, Expr* inner) {
    // can only be PlusPlus / MinusMinus
    UnaryOpcode opcode = (kind == Kind.PlusPlus) ? UnaryOpcode.PostInc : UnaryOpcode.PostDec;
    return cast<Expr*>(UnaryOperator.create(b.context, loc, opcode, inner));
}

func BinaryOpcode convertTokenToBinaryOpcode(Kind kind) {
    // TODO use lookup table (or single table with multiple entries for conversions?)
    switch (kind) {
    case Kind.Star: return BinaryOpcode.Multiply;
    case Kind.Slash: return BinaryOpcode.Divide;
    case Kind.Percent: return BinaryOpcode.Reminder;
    case Kind.Plus: return BinaryOpcode.Add;
    case Kind.Minus: return BinaryOpcode.Subtract;
    case Kind.LessLess: return BinaryOpcode.ShiftLeft;
    case Kind.GreaterGreater: return BinaryOpcode.ShiftRight;
    case Kind.Less: return BinaryOpcode.LessThan;
    case Kind.Greater: return BinaryOpcode.GreaterThan;
    case Kind.LessEqual: return BinaryOpcode.LessEqual;
    case Kind.GreaterEqual: return BinaryOpcode.GreaterEqual;
    case Kind.EqualEqual: return BinaryOpcode.Equal;
    case Kind.ExclaimEqual: return BinaryOpcode.NotEqual;
    case Kind.Amp: return BinaryOpcode.And;
    case Kind.Caret: return BinaryOpcode.Xor;
    case Kind.Pipe: return BinaryOpcode.Or;
    case Kind.AmpAmp: return BinaryOpcode.LAnd;
    case Kind.PipePipe: return BinaryOpcode.LOr;
    case Kind.Equal: return BinaryOpcode.Assign;
    case Kind.StarEqual: return BinaryOpcode.MulAssign;
    case Kind.SlashEqual: return BinaryOpcode.DivAssign;
    case Kind.PercentEqual: return BinaryOpcode.RemAssign;
    case Kind.PlusEqual: return BinaryOpcode.AddAssign;
    case Kind.MinusEqual: return BinaryOpcode.SubASsign;
    case Kind.LessLessEqual: return BinaryOpcode.ShlAssign;
    case Kind.GreaterGreaterEqual: return BinaryOpcode.ShrASsign;
    case Kind.AmpEqual: return BinaryOpcode.AndAssign;
    case Kind.CaretEqual: return BinaryOpcode.XorAssign;
    case Kind.PipeEqual: return BinaryOpcode.OrAssign;
    //case Kind.Comma: return BinaryOpcode.Comma;
    default:
        break;
    }
    // TODO fatal error
    return BinaryOpcode.Multiply;
}

public func Expr* Builder.actOnBinaryOperator(Builder* b, SrcLoc loc, Kind kind, Expr* lhs, Expr* rhs) {
    BinaryOpcode opcode = convertTokenToBinaryOpcode(kind);
    return cast<Expr*>(BinaryOperator.create(b.context, loc, opcode, lhs, rhs));
}

public func Expr* Builder.actOnConditionalOperator(Builder* b, SrcLoc questionLoc, SrcLoc colonLoc, Expr* cond, Expr* lhs, Expr* rhs) {
    return cast<Expr*>(ConditionalOperator.create(b.context, questionLoc, colonLoc, cond, lhs, rhs));
}

public func Expr* Builder.actOnBooleanConstant(Builder* b, SrcLoc loc, bool value) {
    return cast<Expr*>(BooleanLiteral.create(b.context, loc, value));
}

public func Expr* Builder.actOnBuiltinExpr(Builder* b, SrcLoc loc, Expr* inner, BuiltinExprKind kind) {
    return cast<Expr*>(BuiltinExpr.create(b.context, loc, inner, kind));
}

public func Expr* Builder.actOnOffsetOfExpr(Builder* b, SrcLoc loc, Expr* structExpr, Expr* member) {
    return cast<Expr*>(BuiltinExpr.createOffsetOf(b.context, loc, structExpr, member));
}

public func Expr* Builder.actOnToContainerExpr(Builder* b, SrcLoc loc, Expr* structExpr, Expr* member, Expr* pointer) {
    return cast<Expr*>(BuiltinExpr.createToContainer(b.context, loc, structExpr, member, pointer));
}

public func Expr* Builder.actOnTypeExpr(Builder* b, SrcLoc loc, QualType qt) {
    return cast<Expr*>(TypeExpr.create(b.context, loc, qt));
}

public func Expr* Builder.actOnBitOffsetExpr(Builder* b, SrcLoc loc, Expr* lhs, Expr* rhs) {
    return cast<Expr*>(BitOffsetExpr.create(b.context, loc, lhs, rhs));
}

public func Expr* Builder.actOnArraySubscriptExpr(Builder* b, SrcLoc loc, Expr* base, Expr* idx) {
    return cast<Expr*>(ArraySubscriptExpr.create(b.context, loc, base, idx));
}

public func Expr* Builder.actOnCallExpr(Builder* b, Expr* fn, Expr** args, u32 num_args) {
    return cast<Expr*>(CallExpr.create(b.context, fn, args, num_args));
}

public func Expr* Builder.actOnExplicitCast(Builder* b, SrcLoc loc, QualType qt, Expr* inner) {
    return cast<Expr*>(ExplicitCastExpr.create(b.context, loc, qt, inner));
}

public func Expr* Builder.actOnMemberExpr(Builder* b, SrcLoc loc, Expr* base, IdentifierExpr* member) {
    return cast<Expr*>(MemberExpr.create(b.context, loc, base, member));
}

public func Expr* Builder.actOnInitList(Builder* b, SrcLoc left, SrcLoc right, Expr** values, u32 num_values) {
    return cast<Expr*>(InitListExpr.create(b.context, left, right, values, num_values));
}

public func Expr* Builder.actOnFieldDesignatedInit(Builder* b, const char* field, SrcLoc loc, Expr* initValue) {
    return cast<Expr*>(FieldDesignatedInitExpr.create(b.context, field, loc, initValue));
}

public func Expr* Builder.actOnArrayDesignatedInit(Builder* b, SrcLoc loc, Expr* designator, Expr* initValue) {
    return cast<Expr*>(ArrayDesignatedInitExpr.create(b.context, loc, designator, initValue));
}

public func void Builder.actOnStaticAssert(Builder* b, SrcLoc loc, Expr* lhs, Expr* rhs) {
    StaticAssertDecl* d = StaticAssertDecl.create(b.context, loc, lhs, rhs);
    b.ast.addStaticAssert(d);
}


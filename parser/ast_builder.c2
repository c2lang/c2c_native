/* Copyright 2022 Bas van den Berg
*/

module ast_builder;

import ast local;
import ast_context local;
import ast_list;
import tokens local;
import utils local;

import stdlib local;
import string local;
import stdio local;

public type Builder struct {
    Context* context;
    ast_list.AST* ast;
} @(opaque)

public func Builder* Builder.create(Context* c) {
    Builder* b = calloc(1, sizeof(Builder));
    b.context = c;
    // TEMP create AST here
    b.ast = ast_list.AST.create();
    return b;
}

public func void Builder.free(Builder* b) {
    free(b);
}

public func void Builder.dump(const Builder* b) {
    b.ast.print();
}

public func void Builder.actOnModule(Builder* b, const char* mod_name, SrcLoc mod_loc) {
    // TODO get AST, Module

    // NOTE: make special ImportDecl to add own symbols
    ImportDecl* d = ImportDecl.create(b.context, mod_name, mod_loc, nil, 0, true);
    b.ast.addImport(d);
}

public func void Builder.actOnImport(Builder* b, const char* mod_name, SrcLoc mod_loc, const char* alias_name, SrcLoc alias_loc, bool islocal) {
    // TODO check for duplicates

    ImportDecl* d = ImportDecl.create(b.context, mod_name, mod_loc, alias_name, alias_loc, islocal);
    b.ast.addImport(d);
}

public func StructTypeDecl* Builder.actOnStructType(Builder* b, const char* name, SrcLoc loc, bool is_public, bool is_struct, bool is_global) {
    StructTypeDecl* d = StructTypeDecl.create(b.context, name, loc, is_public, is_struct, is_global);
    b.ast.addTypeDecl(d.asDecl());
    return d;
}

public func void Builder.actOnStructMembers(Builder* b, StructTypeDecl* d, Decl** members, u32 count) {
    void* buf = b.context.alloc(count * sizeof(Decl*));
    memcpy(buf, cast<void*>(members), count * sizeof(Decl*));
    d.setMembers(buf, count);
}

public func VarDecl* Builder.actOnStructVar(Builder* b, const char* name, SrcLoc loc, bool is_public, QualType qt, Expr* initValue) {
    // TODO set vardecl type as StructMember
    return VarDecl.create(b.context, name, loc, is_public, qt, initValue);
}

public func void Builder.actOnAttr(Builder* b, const char* name, SrcLoc begin_loc, SrcLoc end_loc) {
    //printf("ATTR  %s\n", name);
}

public func QualType Builder.actOnBuiltinType(Builder* b, tokens.Kind kind) {
    Type* t;
    // TODO optimize (table?) -> fill in init with correct width for usize/isize, fill with QualType
    switch (kind) {
    case Kind.KW_u8:
        t = cast<Type*>(g_u8);
        break;
    case Kind.KW_u16:
        t = cast<Type*>(g_u16);
        break;
    case Kind.KW_u32:
        t = cast<Type*>(g_u32);
        break;
    case Kind.KW_u64:
        t = cast<Type*>(g_u64);
        break;
    case Kind.KW_usize:
        // TODO targetInfo.intWidth
        t = cast<Type*>(g_u64);
        break;
    case Kind.KW_i8:
        t = cast<Type*>(g_i8);
        break;
    case Kind.KW_i16:
        t = cast<Type*>(g_i16);
        break;
    case Kind.KW_i32:
        t = cast<Type*>(g_i32);
        break;
    case Kind.KW_i64:
        t = cast<Type*>(g_i64);
        break;
    case Kind.KW_isize:
        // TODO targetInfo.intWidth
        t = cast<Type*>(g_i64);
        break;
/*
    case Kind.KW_f32:
    case Kind.KW_f64:
    case Kind.KW_reg8:
    case Kind.KW_reg16:
    case Kind.KW_reg32:
    case Kind.KW_reg64:
*/
    case Kind.KW_char:
        t = cast<Type*>(g_i8);
        break;
    case Kind.KW_void:
        t = cast<Type*>(g_void);
        break;
    case Kind.KW_bool:
        t = cast<Type*>(g_bool);
        break;
    default:
        // fatal error
        break;
    }

    return QualType.init2(t);
}

public func QualType Builder.actOnRefType(Builder* b, Expr* id, Expr* prefix) {
    RefType* t = RefType.create(b.context, prefix, id);
    return QualType.init2(cast<Type*>(t));
}

public func QualType Builder.actOnPointerType(Builder* b, QualType qt, u32 qualifier) {
    //printf("POINTER\n");
    // TODO
    return qt;

}

public func QualType Builder.actOnTypeQualifier(Builder* b, QualType qt, u32 qualifier) {
    QualType res = { qt.ptr | (qualifier & QualType_Mask) }
    return res;
}

public func void Builder.actOnIdExpression(Builder* b, const char* name, SrcLoc loc) {
    //printf("ID %s\n", name);
}

public func FunctionDecl* Builder.actOnFuncDecl(Builder* b, const char* name, SrcLoc loc, bool is_public, QualType rtype) {
    FunctionDecl* f = FunctionDecl.create(b.context, name, loc, is_public, rtype);
    b.ast.addFunc(f);
    return f;
}

public func void Builder.actOnFunctionBody(Builder* b, FunctionDecl* f, CompoundStmt* body) {
    f.setBody(body);
}

// TODO extract Decl, Stmt parts to own file
public func Stmt* Builder.actOnCompoundStmt(Builder* b, Stmt** stmts, u32 count) {
    return cast<Stmt*>(CompoundStmt.create(b.context, stmts, count));
}

public func Stmt* Builder.actOnReturnStmt(Builder* b, SrcLoc loc, Expr* ret) {
    return cast<Stmt*>(ReturnStmt.create(b.context, loc, ret));
}

public func Stmt* Builder.actOnIfStmt(Builder* b, Expr* cond, Stmt* then, Stmt* else_stmt) {
    return cast<Stmt*>(IfStmt.create(b.context, cond, then, else_stmt));
}

public func Stmt* Builder.actOnDoStmt(Builder* b, Expr* cond, Stmt* then) {
    return cast<Stmt*>(DoStmt.create(b.context, cond, then));
}

public func Stmt* Builder.actOnWhileStmt(Builder* b, Expr* cond, Stmt* then) {
    return cast<Stmt*>(WhileStmt.create(b.context, cond, then));
}

public func Stmt* Builder.actOnForStmt(Builder* b, Stmt* init_, Expr* cond, Expr* incr, Stmt* body) {
    return cast<Stmt*>(ForStmt.create(b.context, init_, cond, incr, body));
}

public func Stmt* Builder.actOnSwitchStmt(Builder* b, Expr* cond, Decl** cases, u32 num_cases) {
    return cast<Stmt*>(SwitchStmt.create(b.context, cond, cases, num_cases));
}

public func Stmt* Builder.actOnDefaultStmt(Builder* b, SrcLoc loc, Stmt** stmts, u32 num_stmts) {
    return cast<Stmt*>(DefaultStmt.create(b.context, loc, stmts, num_stmts));
}

public func Stmt* Builder.actOnCaseStmt(Builder* b, SrcLoc loc, Expr* cond, Stmt** stmts, u32 num_stmts) {
    return cast<Stmt*>(CaseStmt.create(b.context, loc, cond, stmts, num_stmts));
}

public func Stmt* Builder.actOnBreakStmt(Builder* b, SrcLoc loc) {
    return cast<Stmt*>(BreakStmt.create(b.context, loc));
}

public func Stmt* Builder.actOnContinueStmt(Builder* b, SrcLoc loc) {
    return cast<Stmt*>(ContinueStmt.create(b.context, loc));
}

public func Stmt* Builder.actOnFallthroughStmt(Builder* b, SrcLoc loc) {
    return cast<Stmt*>(FallthroughStmt.create(b.context, loc));
}

public func Expr* Builder.actOnIdentifier(Builder* b, SrcLoc loc, const char* name) {
    return cast<Expr*>(IdentifierExpr.create(b.context, loc, name));
}

public func Expr* Builder.actOnIntegerLiteral(Builder* b, SrcLoc loc, const char* text) {
    u64 val;
    if (text[1] == 0) { // fast single digit path
        // TEMP
        val = cast<u64>(text[0] - '0');
    } else {
        val = strtoull(text, nil, 10);
    }
    return cast<Expr*>(IntegerLiteral.create(b.context, loc, val));
}

public func Expr* Builder.actOnCharLiteral(Builder* b, SrcLoc loc, u8 value) {
    return cast<Expr*>(CharLiteral.create(b.context, loc, value));
}

public func Expr* Builder.actOnStringLiteral(Builder* b, SrcLoc loc, const char* value) {
    return cast<Expr*>(StringLiteral.create(b.context, loc, value));
}

public func Expr* Builder.actOnNilExpr(Builder* b, SrcLoc loc) {
    return cast<Expr*>(NilExpr.create(b.context, loc));
}

public func Expr* Builder.actOnParenExpr(Builder* b, SrcLoc loc, Expr* inner) {
    return cast<Expr*>(ParenExpr.create(b.context, loc, inner));
}

func UnaryOpcode convertTokenToUnaryOpcode(Kind kind) {
    switch (kind) {
    case Kind.Exclaim: return UnaryOpcode.LNot;
    case Kind.Star: return UnaryOpcode.Deref;
    case Kind.Amp: return UnaryOpcode.AddrOf;
    case Kind.PlusPlus:   return UnaryOpcode.PreInc;
    case Kind.Minus: return UnaryOpcode.Minus;
    case Kind.MinusMinus: return UnaryOpcode.PreDec;
    case Kind.Tilde: return UnaryOpcode.Not;
    default:
        break;
    }
    // TODO fatal error
    return UnaryOpcode.PreInc;
}

public func Expr* Builder.actOnUnaryOperator(Builder* b, SrcLoc loc, Kind kind, Expr* inner) {
    UnaryOpcode opcode = convertTokenToUnaryOpcode(kind);
    return cast<Expr*>(UnaryOperator.create(b.context, loc, opcode, inner));
}

func UnaryOpcode convertTokenToBinaryOpcode(Kind kind) {
    switch (kind) {
    case Kind.Exclaim: return UnaryOpcode.LNot;
    case Kind.Star: return UnaryOpcode.Deref;
    case Kind.Amp: return UnaryOpcode.AddrOf;
    case Kind.PlusPlus:   return UnaryOpcode.PreInc;
    case Kind.Minus: return UnaryOpcode.Minus;
    case Kind.MinusMinus: return UnaryOpcode.PreDec;
    case Kind.Tilde: return UnaryOpcode.Not;
    default:
        break;
    }
    // TODO fatal error
    return UnaryOpcode.PreInc;
}

public func Expr* Builder.actOnBinaryOperator(Builder* b, SrcLoc loc, Kind kind, Expr* lhs, Expr* rhs) {
    BinaryOpcode opcode = convertTokenToBinaryOpcode(kind);
    return cast<Expr*>(BinaryOperator.create(b.context, loc, opcode, lhs, rhs));
}

public func Expr* Builder.actOnBooleanConstant(Builder* b, SrcLoc loc, bool value) {
    return cast<Expr*>(BooleanLiteral.create(b.context, loc, value));
}

public func Expr* Builder.actOnBuiltinExpr(Builder* b, SrcLoc loc, Expr* inner, BuiltinExprKind kind) {
    return cast<Expr*>(BuiltinExpr.create(b.context, loc, inner, kind));
}


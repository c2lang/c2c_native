/* Copyright 2022 Bas van den Berg
*/

module c2_parser;

import ast_builder local;
import ast local;
import ast_list;
import tokens local;
import utils local;

/// PrecedenceLevels - These have been altered from C99 to C2
/// In particular, addition now comes after bitwise and shifts
/// Bitwise is directly after shift and equality and relational have
/// the same precedence.

type PrecLevel enum u8 {
    Unknown         = 0,    // Not binary operator.
    Comma           = 1,    // ,
    Assignment      = 2,    // =, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |=
    Conditional     = 3,    // ?
    LogicalAndOr    = 4,    // &&, ||
    Relational      = 5,    // ==, !=, >=, <=, >, <
    Additive        = 6,    // -, +
    Bitwise         = 7,    // ^, |, &
    Shift           = 8,    // <<, >>
    Multiplicative  = 9,    // *, /, %
}

func Expr* Parser.parseExpr(Parser* p) {
    Expr* lhs = p.parseAssignmentExpression();
    return p.parseRHSOfBinaryExpression(lhs, PrecLevel.Comma);
}

func Expr* Parser.parseAssignmentExpression(Parser* p) {
    Expr* lhs = p.parseCastExpr(false, false);
    return p.parseRHSOfBinaryExpression(lhs, PrecLevel.Assignment);
}

func Expr* Parser.parseRHSOfBinaryExpression(Parser* p, Expr* lhs, PrecLevel minPrec) {
    // TODO
    return nil;
}

// NotCastExpr?
func Expr* Parser.parseCastExpr(Parser* p, bool isUnaryExpr, bool isAddrOfOp) {
    // This handles all of cast-expression, unary-expression, postfix-expression,
    // and primary-expression.  We handle them together like this for efficiency
    // and to simplify handling of an expression starting with a '(' token: which
    // may be one of a parenthesized expression, cast-expression, compound literal
    // expression, or statement expression.
    //
    // If the parsed tokens consist of a primary-expression, the cases below
    // break out of the switch;  at the end we call ParsePostfixExpressionSuffix
    // to handle the postfix expression suffixes.  Cases that cannot be followed
    // by postfix exprs should return without invoking
    // ParsePostfixExpressionSuffix.

    Kind savedKind = p.tok.kind;
    Expr* res = nil;

    // TODO order (or use 2nd jump table?) -> need table, because cannot be in order
    switch (savedKind) {
    case Kind.Identifier:
        res = p.parseIdentifier();
/*
        // Make sure to pass down the right value for isAddressOfOperand.
        if (isAddressOfOperand && isPostfixExpressionSuffixStart())
            isAddressOfOperand = false;
*/
        break;
    case Kind.NumberLiteral:
        // TODO pass radix, base, etc
        res = p.builder.actOnIntegerLiteral(p.tok.loc, p.tok.text_value);
        p.consumeToken();
        break;
    case Kind.CharLiteral:
        res = p.builder.actOnCharLiteral(p.tok.loc, p.tok.char_value);
        p.consumeToken();
        break;
    case Kind.StringLiteral:
        res = p.parseStringLiteral();
        break;
    case Kind.LParen:
        res = p.parseParenExpr();
        break;
    case Kind.Star: fallthrough;
    case Kind.Tilde: fallthrough;
    case Kind.Minus: fallthrough;
    case Kind.Exclaim:
        SrcLoc loc = p.tok.loc;
        p.consumeToken();
        return p.builder.actOnUnaryOperator(loc, savedKind, res);
    case Kind.Amp:
        SrcLoc loc = p.tok.loc;
        p.consumeToken();
        res = p.parseCastExpr(false, true);
        return p.builder.actOnUnaryOperator(loc, savedKind, res);
    case Kind.Plus:
        // ignore unary +
        p.consumeToken();
        return p.parseCastExpr(false, false);
    case Kind.PlusPlus: fallthrough;
    case Kind.MinusMinus:
        SrcLoc loc = p.tok.loc;
        p.consumeToken();
        res = p.parseCastExpr(false, false);
        return p.builder.actOnUnaryOperator(loc, savedKind, res);
    case Kind.KW_elemsof:
        res = p.parseElemsof();
        break;
    // TODO KW_enum_min
    // TODO KW_enum_max
    // TODO KW_offsetof
    // TODO KW_cast
    // TODO KW_to_container
    case Kind.KW_false:
        res = p.builder.actOnBooleanConstant(p.tok.loc, false);
        p.consumeToken();
        break;
    case Kind.KW_nil:
        res = p.builder.actOnNilExpr(p.tok.loc);
        p.consumeToken();
        break;
    case Kind.KW_sizeof:
        return p.parseSizeof();
    case Kind.KW_true:
        res = p.builder.actOnBooleanConstant(p.tok.loc, true);
        p.consumeToken();
        break;
    default:
        p.error("syntax error");
        break;
    }

    return p.parsePostfixExprSuffix(res);
}

func Expr* Parser.parsePostfixExprSuffix(Parser* p, Expr* lhs) {

    while (1) {
        switch (p.tok.kind) {
        case Kind.Identifier:
            return lhs;
        case Kind.LParen:
            // C2: can only be call expr?
            lhs = p.parseCallExpr(lhs);
            break;
        case Kind.LSquare:
            p.consumeToken();
            Expr* idx = p.parseExpr();
            if (p.tok.kind  == Kind.Colon) {
                // BitOffset <expr> : <expr>
                SrcLoc colLoc = p.tok.loc;
                p.consumeToken();
                Expr* rhs = p.parseExpr();
                // TODO need colLoc?
                idx = p.builder.actOnBitOffsetExpr(colLoc, idx, rhs);
            }
            SrcLoc rloc = p.tok.loc;
            p.expectAndConsume(Kind.RSquare);
            lhs = p.builder.actOnArraySubscriptExpr(rloc, lhs, idx);
            break;
        case Kind.Dot:
            SrcLoc dot_loc = p.tok.loc;
            p.consumeToken();
            p.expectIdentifier();
            Expr* rhs = p.parseIdentifier();
            lhs = p.builder.actOnMemberExpr(dot_loc, lhs, rhs);
            break;
        case Kind.PlusPlus: fallthrough;
        case Kind.MinusMinus:
            lhs = p.builder.actOnPostFixUnaryOperator(p.tok.loc, p.tok.kind, lhs);
            p.consumeToken();
            break;
        default:
            return lhs;
        }
    }
    // TODO should not come here
    return nil;
}

func Expr* Parser.parseCallExpr(Parser* p, Expr* fn) {
    p.consumeToken(); // '('

    ast_list.ExprList args;
    args.init();

    while (p.tok.kind != Kind.RParen) {

        args.add(p.parseExpr());

        if (p.tok.kind == Kind.RParen) break;
        p.expectAndConsume(Kind.Comma);
    }
    p.expectAndConsume(Kind.RParen);
    return p.builder.actOnCallExpr(fn, args.getExprs(), args.size());
}


func Expr* Parser.parseIdentifier(Parser* p) {
    Expr* e = p.builder.actOnIdentifier(p.tok.loc, p.tok.text_value);
    p.consumeToken();
    return e;
}

func Expr* Parser.parseStringLiteral(Parser* p) {
    Expr* e = p.builder.actOnStringLiteral(p.tok.loc, p.tok.text_value);
    p.consumeToken();
    return e;
}

func Expr* Parser.parseParenExpr(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    Expr* res = p.parseExpr();
    p.expectAndConsume(Kind.RParen);

    return p.builder.actOnParenExpr(p.tok.loc, res);
}

func Expr* Parser.parseSizeof(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    p.expectAndConsume(Kind.LParen);

    Expr* res = nil;

    switch (p.tok.kind) {
    case Kind.Identifier:
/*
    if (canBeParsedAsStructType()) {
            Res = ParseTypeSpecifier(false);
            break;
        }
    }
*/
        fallthrough;
    case Kind.KW_char: fallthrough;
    case Kind.KW_f32: fallthrough;
    case Kind.KW_f64: fallthrough;
    case Kind.KW_i8:  fallthrough;
    case Kind.KW_i16: fallthrough;
    case Kind.KW_i32: fallthrough;
    case Kind.KW_i64: fallthrough;
    case Kind.KW_isize: fallthrough;
    case Kind.KW_reg8:  fallthrough;
    case Kind.KW_reg16: fallthrough;
    case Kind.KW_reg32: fallthrough;
    case Kind.KW_reg64: fallthrough;
    case Kind.KW_u8:  fallthrough;
    case Kind.KW_u16: fallthrough;
    case Kind.KW_u32: fallthrough;
    case Kind.KW_u64: fallthrough;
    case Kind.KW_usize: fallthrough;
    case Kind.KW_void:
        res = p.builder.actOnTypeExpr(p.tok.loc, p.parseTypeSpecifier(false));
        break;
    default:
        res = p.parseExpr();
        break;
    }

    p.expectAndConsume(Kind.RParen);
    return p.builder.actOnBuiltinExpr(loc, res, BuiltinExprKind.Sizeof);
}

func Expr* Parser.parseElemsof(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    p.expectAndConsume(Kind.LParen);

    p.expectIdentifier();

    Expr* res = p.parseIdentifier();
    res = p.parsePostfixExprSuffix(res);

    p.expectAndConsume(Kind.RParen);
    return p.builder.actOnBuiltinExpr(loc, res, BuiltinExprKind.Elemsof);
}


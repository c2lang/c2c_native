/* Copyright 2022 Bas van den Berg
*/

module c2_parser;

import ast_builder local;
import ast_utils local;
import ast local;
import tokens local;
import utils local;

import stdio local; // TEMP

func Stmt* Parser.parseStmt(Parser* p) {
#if DebugParser
    printf("parseStmt\n");
#endif
    // TODO use Jump Table (combined one for multiple purposes?)
    switch (p.tok.kind) {
    case Kind.LBrace:
        return cast<Stmt*>(p.parseCompoundStmt());
    case Kind.RBrace:
        p.error("expected stmt");
        break;
    case Kind.KW_break:
        return p.parseBreakStmt();
    case Kind.KW_continue:
        return p.parseContinueStmt();
    case Kind.KW_do:
        return p.parseDoStmt();
    case Kind.KW_fallthrough:
        return p.parseFallthroughStmt();
    case Kind.KW_for:
        return p.parseForStmt();
    case Kind.KW_if:
        return p.parseIfStmt();
    case Kind.KW_return:
        return p.parseReturnStmt();
    case Kind.KW_switch:
        return p.parseSwitchStmt();
    case Kind.KW_bool:   fallthrough;
    case Kind.KW_char:   fallthrough;
    case Kind.KW_const:   fallthrough;
    case Kind.KW_i8:    fallthrough;
    case Kind.KW_i16:   fallthrough;
    case Kind.KW_i32:   fallthrough;
    case Kind.KW_i64:   fallthrough;
    case Kind.KW_isize:   fallthrough;
    case Kind.KW_f32:   fallthrough;
    case Kind.KW_f64:   fallthrough;
    case Kind.KW_local:   fallthrough;
    case Kind.KW_reg8:    fallthrough;
    case Kind.KW_reg16:   fallthrough;
    case Kind.KW_reg32:   fallthrough;
    case Kind.KW_reg64:   fallthrough;
    case Kind.KW_u8:    fallthrough;
    case Kind.KW_u16:   fallthrough;
    case Kind.KW_u32:   fallthrough;
    case Kind.KW_u64:   fallthrough;
    case Kind.KW_usize:   fallthrough;
    case Kind.KW_volatile:   fallthrough;
    case Kind.KW_void:
        return p.parseDeclStmt(true, true);
    case Kind.KW_while:
        return p.parseWhileStmt();
    default:
        return p.parseExprStmt();
    }
    return nil;
}

func CompoundStmt* Parser.parseCompoundStmt(Parser* p) {
#if DebugParser
    printf("parseCompoundStmt\n");
#endif
    p.expectAndConsume(Kind.LBrace);

    StmtList stmts;
    stmts.init();   // TODO register somewhere to free memory on error (register handler?)

    while (1) {
        if (p.tok.kind == Kind.RBrace) break;

        Stmt* s = p.parseStmt();
        stmts.add(s);
    }

    p.expectAndConsume(Kind.RBrace);

    CompoundStmt* s = p.builder.actOnCompoundStmt(stmts.getData(), stmts.size());
    stmts.free();

    return s;
}

func Stmt* Parser.parseBreakStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnBreakStmt(loc);
}

func Stmt* Parser.parseContinueStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnContinueStmt(loc);
}

func Stmt* Parser.parseFallthroughStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnFallthroughStmt(loc);
}

func Expr* Parser.parseCondition(Parser* p) {
    p.expectAndConsume(Kind.LParen);
    Expr* cond = p.parseExpr();
    p.expectAndConsume(Kind.RParen);
    return cond;
}

func Stmt* Parser.parseIfStmt(Parser* p) {
    p.consumeToken();

    Expr* cond = p.parseCondition();
    Stmt* then = p.parseStmt();

    Stmt* else_stmt = nil;
    if (p.tok.kind == Kind.KW_else) {
        p.consumeToken();
        else_stmt = p.parseStmt();
    }

    return p.builder.actOnIfStmt(cond, then, else_stmt);
}

func Stmt* Parser.parseReturnStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    Expr* ret = nil;
    if (p.tok.kind != Kind.Semicolon) {
        ret = p.parseExpr();
    }

    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnReturnStmt(loc, ret);
}

func Stmt* Parser.parseSwitchStmt(Parser* p) {
    p.consumeToken();
    Expr* cond = p.parseCondition();

    p.expectAndConsume(Kind.LBrace);

    StmtList cases;
    cases.init();

    while (p.tok.kind != Kind.RBrace) {
        Stmt* c;
        switch (p.tok.kind) {
        case Kind.KW_case:
            c = p.parseCaseStmt();
            break;
        case Kind.KW_default:
            c = p.parseDefaultStmt();
            break;
        default:
            p.error("expected case or default");
            break;
        }
        cases.add(c);
    }

    p.expectAndConsume(Kind.RBrace);

    Stmt* s = p.builder.actOnSwitchStmt(cond, cases.getData(), cases.size());
    cases.free();
    return s;
}

func Stmt* Parser.parseCaseStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    Expr* cond = p.parseExpr();

    p.expectAndConsume(Kind.Colon);

    StmtList stmts;
    stmts.init();

    bool more = true;
    while (more) {
        switch (p.tok.kind) {
        case Kind.RBrace: fallthrough;
        case Kind.KW_case:  fallthrough;
        case Kind.KW_default:
            more = false;
            break;
        default:
            stmts.add(p.parseStmt());
            break;
        }
    }

    Stmt* s = p.builder.actOnCaseStmt(loc, cond, stmts.getData(), stmts.size());
    stmts.free();
    return s;
}

func Stmt* Parser.parseDefaultStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    p.expectAndConsume(Kind.Colon);

    StmtList stmts;
    stmts.init();

    bool more = true;
    while (more) {
        switch (p.tok.kind) {
        case Kind.RBrace: fallthrough;
        case Kind.KW_case:  fallthrough;
        case Kind.KW_default:
            more = false;
            break;
        default:
            stmts.add(p.parseStmt());
            break;
        }
    }

    Stmt* s = p.builder.actOnDefaultStmt(loc, stmts.getData(), stmts.size());
    stmts.free();
    return s;
}

func Stmt* Parser.parseDoStmt(Parser* p) {
    p.consumeToken();

    Stmt* then = p.parseStmt();
    p.expectAndConsume(Kind.KW_while);
    Expr* cond = p.parseCondition();

    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnDoStmt(cond, then);
}

func Stmt* Parser.parseForStmt(Parser* p) {
    p.consumeToken();

    p.expectAndConsume(Kind.LParen);

    // init
    Stmt* init_ = nil;
    if (p.tok.kind != Kind.Semicolon) {
        // TODO check if declaration
        init_ = p.parseStmt();
    }
    p.expectAndConsume(Kind.Semicolon);

    // cond
    Expr* cond = nil;
    if (p.tok.kind != Kind.Semicolon) {
        cond = p.parseExpr();
    }
    p.expectAndConsume(Kind.Semicolon);

    // incr
    Expr* incr = nil;
    if (p.tok.kind != Kind.RParen) {
        incr = p.parseExpr();
    }
    p.expectAndConsume(Kind.RParen);

    Stmt* body = p.parseStmt();

    return p.builder.actOnForStmt(init_, cond, incr, body);
}

func Stmt* Parser.parseWhileStmt(Parser* p) {
    p.consumeToken();

    Expr* cond = p.parseCondition();
    Stmt* then = p.parseStmt();

    return p.builder.actOnWhileStmt(cond, then);
}

func Stmt* Parser.parseDeclStmt(Parser* p, bool checkSemi, bool allowLocal) {
#if DebugParser
    printf("parseDeclStmt\n");
#endif
    p.error("TODO parseDeclStmt");
    return nil;
}

func Stmt* Parser.parseExprStmt(Parser* p) {
    Expr* e = p.parseExpr();
    p.expectAndConsume(Kind.Semicolon);
    return e.asStmt();
}


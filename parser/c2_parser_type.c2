/* Copyright 2022 Bas van den Berg
*/

module c2_parser;

import ast_builder local;
import ast local;
import tokens local;
import utils local;

import ctype local;

func void Parser.parseTypeDef(Parser* p, bool is_public) {
    p.consumeToken();
    p.expectIdentifier();
    const char* type_name = p.tok.text_value;
    u32 type_loc = p.tok.loc;
    p.consumeToken();

    if (!isupper(type_name[0])) p.error("type name must start with upper-case character");

    switch (p.tok.kind) {
    case Kind.KW_func:
        p.parseFunctionType(type_name, type_loc, is_public);
        break;
    case Kind.KW_struct:
        p.parseStructType(true, type_name, type_loc, is_public);
        break;
    case Kind.KW_union:
        p.parseStructType(false, type_name, type_loc, is_public);
        break;
    case Kind.KW_enum:
        p.parseEnumType(type_name, type_loc, is_public);
        break;
    default:
        p.parseAliasType(type_name, type_loc, is_public);
        break;
    }
}

func void Parser.parseFunctionType(Parser* p, const char* name, u32 loc, bool is_public) {
    p.consumeToken(); // func

    QualType rtype = p.parseSingleTypeSpecifier(true);

    DeclList params;
    params.init(4);

    bool is_variadic = p.parseFunctionParams(&params, is_public, false);
    Decl* f = p.builder.actOnFunctionTypeDecl(name, loc, is_public, rtype, cast<VarDecl**>(params.getDecls()), params.size(), is_variadic);
    p.parseOptionalAttributes(); // (f)
    params.free();
    p.expectAndConsume(Kind.Semicolon);
}

func void Parser.parseStructType(Parser* p, bool is_struct, const char* name, u32 loc, bool is_public) {
    p.consumeToken();

    DeclList members;
    members.init(8);
    p.parseStructBlock(&members, is_public);
    StructTypeDecl* d = p.builder.actOnStructType(name, loc, is_public, is_struct, true, cast<VarDecl**>(members.getDecls()), members.size());
    members.free();

    p.parseOptionalAttributes(); // (d)
}

func void Parser.parseStructBlock(Parser* p, DeclList* members, bool is_public) {
    p.expectAndConsume(Kind.LBrace);

    while (1) {
        //Syntax:
        // struct_member ::= type_qualifier type_specifier.
        // struct_member ::= STRUCT <IDENTIFIER> LBRACE struct_block RBRACE.
        // struct_member ::= UNION <IDENTIFIER> LBRACE struct_block RBRACE.

        if (p.tok.kind == Kind.RBrace) break;
        if (p.tok.kind == Kind.KW_union || p.tok.kind == Kind.KW_struct) {
            bool is_struct = p.tok.kind == Kind.KW_struct;
            p.consumeToken();
            // name is optional
            const char* name = nil;
            u32 loc = 0;
            if (p.tok.kind == Kind.Identifier) {
                name = p.tok.text_value;
                loc = p.tok.loc;
                p.consumeToken();
            }

            DeclList sub_members;
            sub_members.init(4);

            p.parseStructBlock(&sub_members, is_public);
            StructTypeDecl* member = p.builder.actOnStructType(name, loc, is_public, is_struct, false, cast<VarDecl**>(sub_members.getDecls()), sub_members.size());
            sub_members.free();
            members.add(member.asDecl());
        } else {
            QualType qt = p.parseTypeSpecifier(true);

            const char* name = nil;
            SrcLoc loc;
            if (p.tok.kind == Kind.Colon) { // anonymous bit-field
                loc = p.tok.loc;
            } else {
                p.expectIdentifier();
                name = p.tok.text_value;
                loc = p.tok.loc;
                p.consumeToken();
            }

            Expr* bitfield = nil;
            if (p.tok.kind == Kind.Colon) {
                p.consumeToken();
                bitfield = p.parseExpr();
            }
            VarDecl* member = p.builder.actOnStructMember(name, loc, is_public, qt, bitfield);
            members.add(member.asDecl());

            p.expectAndConsume(Kind.Semicolon);
        }
    }

    p.expectAndConsume(Kind.RBrace);
}

func void Parser.parseEnumType(Parser* p, const char* name, u32 loc, bool is_public) {
    p.consumeToken();

    // TODO lookup table (is_type?)
    switch (p.tok.kind) {
    case Kind.KW_char:
        break;
    case Kind.KW_f32: fallthrough;
    case Kind.KW_f64:
        p.error("enum type must be an integer");
        break;
    case Kind.KW_i8:  fallthrough;
    case Kind.KW_i16: fallthrough;
    case Kind.KW_i32: fallthrough;
    case Kind.KW_i64: fallthrough;
    case Kind.KW_isize:
        break;
    case Kind.KW_reg8:  fallthrough;
    case Kind.KW_reg16: fallthrough;
    case Kind.KW_reg32: fallthrough;
    case Kind.KW_reg64:
        p.error("enum type must be an integer");
        break;
    case Kind.KW_u8:  fallthrough;
    case Kind.KW_u16: fallthrough;
    case Kind.KW_u32: fallthrough;
    case Kind.KW_u64: fallthrough;
    case Kind.KW_usize:
        break;
    case Kind.KW_void:
        p.error("enum type must be an integer");
        break;
    default:
        p.error("expected enum type");
        break;
    }
    QualType qt = p.builder.actOnBuiltinType(p.tok.kind);
    p.consumeToken();

    p.expectAndConsume(Kind.LBrace);

    bool is_incr = false;

    DeclList constants;
    constants.init(16);

    if (p.tok.kind == Kind.Plus) {
        is_incr = true;
        p.consumeToken();
        p.error("TODO incremental enum");
    } else {

        while (p.tok.kind == Kind.Identifier) {
            const char* const_name = p.tok.text_value;
            SrcLoc const_loc = p.tok.loc;
            p.consumeToken();

            Expr* initial = nil;
            if (p.tok.kind == Kind.Equal) {
                p.consumeToken();
                initial = p.parseExpr(); // p.parseConstantExpr()
            }

            EnumConstantDecl* constant = p.builder.actOnEnumConstant(const_name, const_loc, is_public, qt, initial);
            constants.add(constant.asDecl());

            if (p.tok.kind != Kind.Comma) break;
            p.consumeToken();
        }
    }

    p.expectAndConsume(Kind.RBrace);

    p.builder.actOnEnumType(name, loc, is_public, is_incr, qt, cast<EnumConstantDecl**>(constants.getDecls()), constants.size());

    constants.free();
}

func void Parser.parseAliasType(Parser* p, const char* name, u32 loc, bool is_public) {
    QualType qt = p.parseTypeSpecifier(true);

    Decl* d = p.builder.actOnAliasType(name, loc, is_public, qt);
    p.parseOptionalAttributes();
    p.expectAndConsume(Kind.Semicolon);
}


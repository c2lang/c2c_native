/* Copyright 2022 Bas van den Berg
*/

module source_mgr;

import file_utils;
import stdlib;
import string;
import utils;
import color;

import stdio local; // for dump()

const u32 InitialMaxFiles = 8;

type File struct {
    const char* filename;   // no ownership
    u32 offset;
    file_utils.Reader file;

    u32 last_offset;
    Location last_loc;
}

public type SourceMgr struct {
    File* files;
    u32 num_files;
    u32 max_files;
} @(opaque)

public func SourceMgr* SourceMgr.create() {
    SourceMgr* sm = stdlib.calloc(1, sizeof(SourceMgr));
    sm.max_files = InitialMaxFiles;
    sm.files = stdlib.malloc(sizeof(File) * sm.max_files);
    return sm;
}

public func void SourceMgr.free(SourceMgr* sm) {
    for (u32 i=0; i<sm.num_files; i++) {
        File* f = &sm.files[i];
        f.file.close();
    }
    stdlib.free(sm.files);
    stdlib.free(sm);
}

public func i32 SourceMgr.open(SourceMgr* sm, const char* filename, utils.SrcLoc loc) {
    file_utils.Reader file;
    if (!file.open(filename)) {
        char[256] error_msg;
        if (file.errno == file_utils.Err_not_a_file) {
            sprintf(error_msg, "cannot open %s: %s", filename, "not a regular file");
        } else {
            sprintf(error_msg, "cannot open %s: %s", filename, string.strerror(file.errno));
        }
        if (loc) {
            fprintf(stderr, "%s: %serror:%s %s", sm.loc2str(loc), color.Red, color.Normal, error_msg);
        } else {
            fprintf(stderr, "%serror%s: %s\n", color.Red, color.Normal, error_msg);
        }
        return -1;
    }

    if (sm.num_files == sm.max_files) {
        sm.max_files *= 2;
        File* files2 = stdlib.malloc(sizeof(File) * sm.max_files);
        string.memcpy(files2, sm.files, sm.num_files * sizeof(File));
        stdlib.free(sm.files);
        sm.files = files2;
    }

    i32 file_id = cast<i32>(sm.num_files);
    File* f = &sm.files[sm.num_files];
    string.memset(f, 0, sizeof(File));

    u32 offset = 1;
    if (sm.num_files) offset = sm.files[sm.num_files-1].offset + sm.files[sm.num_files-1].file.size;
    f.filename = filename;
    f.offset = offset;
    f.file = file;

    sm.num_files++;
    //sm.dump();
    return file_id;
}

public func const char* SourceMgr.get_content(SourceMgr* sm, i32 handle) {
    return cast<char*>(sm.files[handle].file.data());
}

public func u32 SourceMgr.get_offset(SourceMgr* sm, i32 handle) {
    return sm.files[handle].offset;
}

func void SourceMgr.dump(const SourceMgr* sm) {
    printf("SourceMgr  files %u\n", sm.num_files);
    for (u32 i=0; i<sm.num_files; i++) {
        File* f = &sm.files[i];
        printf("  [%2u]  %7u  %7u %s\n", i, f.offset, f.file.size, f.filename);
    }
}

type Location struct {
    u32 line;
    u32 column;
    const char* filename;   // no ownership
}

func File* find_file(const SourceMgr* sm, u32 loc) {
    for (u32 i=0; i<sm.num_files; i++) {
        File* f = &sm.files[i];
        if (loc >= f.offset && loc < f.offset + f.file.size) return f;
    }
    return nil;
}

func void find_line_col(const char* data, u32 offset, Location* loc, u32 last_offset) {
    const char* line;
    u32 line_nr = loc.line;
    if (last_offset) {
        line = data + last_offset - loc.column + 1;
    } else {
        line = data;
    }
    for (u32 i=last_offset; i<offset; i++) {
        if (data[i] == '\n') {
            line_nr++;
            line = data + i + 1;
        }
    }
    loc.line = line_nr;
    loc.column = cast<u32>(&data[offset] - line) + 1;
}

func Location SourceMgr.locate(SourceMgr* sm, u32 loc) {
    Location l = { 1, 1, nil }
    File* f = find_file(sm, loc);
    if (f) {
        l.filename = f.filename;
        u32 offset = loc - f.offset;
        u32 last_offset = 0;
        if (f.last_offset != 0 && offset > f.last_offset) {
            l = f.last_loc;
            last_offset = f.last_offset;
        }
        find_line_col(cast<char*>(f.file.data()), offset, &l, last_offset);

        f.last_offset = offset;
        f.last_loc = l;
    }
    return l;
}

public func const char* SourceMgr.loc2str(SourceMgr* sm, u32 src_loc) {
    local char[256] tmp;
    if (src_loc == 0) {
        string.strcpy(tmp, "-");
    } else {
        source_mgr.Location loc = sm.locate(src_loc);
        sprintf(tmp, "%s:%u:%u", loc.filename, loc.line, loc.column);
    }
    return tmp;
}


/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module refs_main;

import c2refs local;
import constants;
import utils;

import c_errno local;
import stdio local;
import stdlib local;
import string local;
#if MeasureTime
import sys_time;
#endif

type Options struct {
    const char* refsfile;
    const char* target;
    const char* symbolname;
    const char* filename;
    u32 line;
    u16 column;
    bool reverse;
    bool dump;
    bool verbose;
}

Options opts;

#if MeasureTime
public func u64 getCurrentTime() {
    sys_time.Timeval tv;
    sys_time.gettimeofday(&tv, nil);
    u64 now64 = cast<u64>(tv.tv_sec);
    now64 *= 1000000;
    now64 += tv.tv_usec;
    return now64;
}
#endif

func void usage(const char* me) {
    printf("Usage: %s [mode] <opts>\n", me);
    printf("  Modes:\n");
    printf("    [name]                  find def. of symbol specified by name\n");
    printf("    [file] [line] [col]     find def. of symbol specify by position\n");
    printf("    -d                      dump refs\n");
    printf("    -D                      dump refs (verbose)\n");
    printf("  Options:\n");
    printf("    -r                      find uses of symbol (specified by name/position)\n");
    printf("    -f [reffile]            use alternative refs file (cannot be combined with -t)\n");
    printf("    -t [target]             use [target] (cannot be combined with -f)\n");
    exit(-1);
}

func void parse_options(i32 argc, const char** argv) {
    const char*[3] args = { nil }
    u32 pos_count = 0;
    i32 i= 1;
    while (i<argc) {
        const char* arg = argv[i];
        if (arg[0] == '-') {
            switch (arg[1]) {
            case 'd':
                opts.dump = 1;
                break;
            case 'D':
                opts.dump = 1;
                opts.verbose = 1;
                break;
            case 'f':
                i++;
                if (i == argc) usage(argv[0]);
                opts.refsfile = argv[i];
                break;
            case 'r':
                opts.reverse = 1;
                break;
            case 't':
                i++;
                if (i == argc) usage(argv[0]);
                opts.target = argv[i];
                break;
            default:
                usage(argv[0]);
                break;
            }
        } else {
            if (pos_count >= 3) usage(argv[0]);
            args[pos_count] = arg;
            pos_count++;
        }
        i++;
    }
    if (opts.refsfile && opts.target) usage(argv[0]);
    if (opts.dump) {
        if (pos_count != 0) usage(argv[0]);
        return;
    }
    if (pos_count == 1) {
        opts.symbolname = args[0];
    } else if (pos_count == 3) {
        opts.filename = args[0];
        opts.line = cast<u32>(atoi(args[1]));
        opts.column = cast<u16>(atoi(args[2]));
    } else {
        usage(argv[0]);
    }
}

func void printDest(const Dest* res) {
    if (res.filename) printf("found %s %u %u\n", res.filename, res.line, res.col);
    else printf("no result found\n");
}

func void use_fn(void* arg, const Dest* res) {
    u32* count = arg;
    (*count)++;
    printDest(res);
}

public func i32 main(i32 argc, const char** argv)
{
    parse_options(argc, argv);

    if (!utils.findProjectDir()) {
        fprintf(stderr, "cannot find C2 root dir\n");
        return -1;
    }
#if MeasureTime
    u64 t1 = getCurrentTime();
#endif
    char[256] refsname;
    if (opts.target) {
        snprintf(refsname, 256, "%s/%s/%s", constants.output_dir, opts.target, constants.refs_filename);
        refsname[255] = 0;
        opts.refsfile = refsname;
    } else {
        if (!opts.refsfile) {
            // TODO use refs_finder
            assert(0); // TODO
        }
    }
    Refs* r = Refs.load(opts.refsfile);
    if (!r) {
        fprintf(stderr, "error loading %s: %s\n", opts.refsfile, strerror(*errno2()));
        return -1;
    }

    if (opts.dump) {
        r.dump(opts.verbose);
        r.free();
        return 0;
    }
    if (opts.filename) {
        Dest origin = { opts.filename, opts.line, opts.column }
        if (opts.reverse) {
            u32 count = 0;
            u16 old_len = 0;
            r.findRefUses(&origin, use_fn, &count, &old_len);
            printf("%u uses\n", count);
        } else {
            Dest result = r.findRef(&origin);
            printDest(&result);
        }
    } else {
        if (opts.reverse) {
            u32 count = 0;
            u16 symbol_len = 0;
            r.findSymbolUses(opts.filename, use_fn, &count, &symbol_len);
            printf("%u uses\n", count);
        } else {
            Dest result = r.findSymbol(opts.symbolname);
            printDest(&result);
        }
    }
#if MeasureTime
    u64 t2 = getCurrentTime();
    printf("  took %lu usec\n", t2 - t1);
#endif

    r.free();
    return 0;
}


/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module test_db;

import c_errno local;
import stdio local;
import stdlib local;
import string local;
import unistd local;

import color;
import expect_file local;
import file_utils;
import string_buffer;
import test_utils local;

public const u32 MAX_LINE = 512;

// TODO move to tester.c2
const char* c2c_cmd = "build/c2c/c2c";

// TEMP here since C2C doesn't support implemented functions in libs (yet)
func bool doWIFSIGNALED(i32 state) {
    return ((state & 0x7F) > 0 && (state & 0x7F) < 0x7F);
}

func bool doWIFEXITED(i32 state) {
    return ((state & 0xff) == 0);
}

func char getWEXITSTATUS(i32 state) {
    return cast<char>((state >> 8) & 0xff);
}


public type TestKind enum u8 {
    C2,
    C2T,
    C2A,
}

public type Mode enum u8 {
    Outside,
    Infile,
    InExpectFile,
}

// TODO rename
type Type enum u8 { ERROR, WARNING, NOTE }

public type Db struct {
    string_buffer.Buf* output;  // no ownership
    file_utils.Reader* file;    // no ownership
    TestKind kind;
    const char* tmp_dir;

    // TODO use vector<ExpectFile>
    ExpectFile** expectedFiles;
    u32 expectedCount;
    u32 expectedCapacity;
    ExpectFile* currentExpect;  // points into expectedFiles

    Mode mode;
    u32 line_offset;
    bool hasErrors;
    bool skip;
    bool runSkipped;        // TODO pass from init
    const char* cur;
    u32 line_nr;
    string_buffer.Buf* errorMsg;    // ownership
    string_buffer.Buf* recipe;      // ownership
    char[256] current_file;
    char[64] target;

    char[32] word_buffer;
    char[MAX_LINE] line_buffer;
    char[128] until_buffer;
}

public func void Db.init(Db* db,
                         string_buffer.Buf* output,
                         file_utils.Reader* file,
                         const char* filename,
                         TestKind kind,
                         const char* tmp_dir,
                         const char* cwd)
{
    memset(db, 0, sizeof(Db));
    db.output = output;
    db.file = file;
    db.kind = kind;
    db.tmp_dir = tmp_dir;

    db.line_nr = 1;
    db.errorMsg = string_buffer.create(128, false, 2);
    db.recipe = string_buffer.create(4096, false, 2);

    if (kind == TestKind.C2) { // only for single file test
        sprintf(db.current_file, "%s/%s", cwd, filename);
    }
}

public func void Db.destroy(Db* db) {

    for (u32 i=0; i<db.expectedCount; i++) {
        db.expectedFiles[i].destroy();
    }
    free(cast<void*>(db.expectedFiles));
    db.errorMsg.free();
    db.recipe.free();
}

public func bool Db.haveErrors(const Db* db) {
    return db.hasErrors;
}

func void Db.addExpected(Db* db, ExpectFile* f) {
    if (db.expectedCount == db.expectedCapacity) {
        db.expectedCapacity += 4;
        ExpectFile* exp2 = malloc(db.expectedCapacity * sizeof(ExpectFile*));
        if (db.expectedCount) {
            memcpy(exp2, cast<void*>(db.expectedFiles), db.expectedCount * sizeof(ExpectFile*));
            free(cast<void*>(db.expectedFiles));
        }
        db.expectedFiles = cast<ExpectFile**>(exp2);
    }

    db.expectedFiles[db.expectedCount] = f;
    db.expectedCount++;
}

func void Db.matchNote(Db* db, const char* filename, i32 linenr, const char* msg) {
    // TODO BB
/*
    for (IssuesIter iter = notes.begin(); iter != notes.end(); ++iter) {
        if (iter->line_nr != linenr) continue;
        if (iter->filename == filename) {
            if (iter->msg != msg) {
                color_print2(output, COL_ERROR, "  wrong note at %s:%d:", filename, linenr);
                color_print2(output, COL_ERROR, "     expected: %s", iter->msg.c_str());
                color_print2(output, COL_ERROR, "     got: %s", msg);
                hasErrors = true;
            }
            notes.erase(iter);
            return;
        }
    }
*/
    // not expected
    color_print2(db.output, colError, "  unexpected note on line %d: %s", linenr, msg);
    db.hasErrors = true;
}

func void Db.matchWarning(Db* db, const char* filename, i32 linenr, const char* msg) {
    // TODO BB
/*
    for (IssuesIter iter = warnings.begin(); iter != warnings.end(); ++iter) {
        if (iter->line_nr != linenr) continue;
        if (iter->filename == filename) {
            if (iter->msg != msg) {
                color_print2(output, COL_ERROR, "  wrong warning at %s:%d:", filename, linenr);
                color_print2(output, COL_ERROR, "     expected: %s", iter->msg.c_str());
                color_print2(output, COL_ERROR, "     got: %s", msg);
                hasErrors = true;
            }
            warnings.erase(iter);
            return;
        }
    }
*/
    // not expected
    color_print2(db.output, colError, "  unexpected warning on line %d: %s", linenr, msg);
    db.hasErrors = true;
}

func void Db.matchError(Db* db, const char* filename, i32 linenr, const char* msg) {
    // TODO BB
/*
    for (IssuesIter iter = errors.begin(); iter != errors.end(); ++iter) {
        if (iter->line_nr != linenr) continue;
        if (iter->filename == filename) {
            if (iter->msg != msg) {
                color_print2(output, COL_ERROR, "  wrong error at %s:%d:", filename, linenr);
                color_print2(output, COL_ERROR, "     expected: %s", iter->msg.c_str());
                color_print2(output, COL_ERROR, "     got: %s", msg);
                hasErrors = true;
            }
            errors.erase(iter);
            return;
        }
    }
*/
    // not expected
    color_print2(db.output, colError, "  unexpected error on line %d: %s", linenr, msg);
    fflush(stdout);
    db.hasErrors = true;
}

func void Db.writeFile(Db* db, const char* filename, const char* data, u32 len) {
    char[128] fullname;
    sprintf(fullname, "%s/%s", db.tmp_dir, filename);
    file_utils.Writer writer;
    bool ok = writer.write(fullname, cast<u8*>(data), len);
    if (!ok) {
        print_error("error writing %s: %s", fullname, strerror(*errno2()));
        exit(EXIT_FAILURE);
    }
}

func void Db.skipLine(Db* db) {
    while (*db.cur != 0) {
        if (*db.cur == '\n') {
            db.line_nr++;
            db.cur++;
            return;
        }
        db.cur++;
    }
}

func const char* Db.findEndOfLine(Db* db) {
    const char* cp = db.cur;
    while (*cp != 0 && *cp != '\n') {
        cp++;
    }
    return cp;
}

func const char* Db.readWord(Db* db) {
    const char* cp = db.cur;
    while (*cp != 0 && cp - db.cur < 31) {
        if ((*cp < 'a' || *cp > 'z') && *cp != '-' && *cp != '_') break;
        cp++;
    }
    u32 len = cast<u32>(cp - db.cur);
    memcpy(db.word_buffer, db.cur, len);
    db.word_buffer[len] = 0;
    return db.word_buffer;
}

func const char* Db.readLine(Db* db) {
    const char* cp = db.cur;
    while (*cp != 0 && cp - db.cur < MAX_LINE) {
        if (*cp == 0 || *cp == '\n') break;
        cp++;
    }
    u32 len = cast<u32>(cp - db.cur);
    memcpy(db.line_buffer, db.cur, len);
    db.line_buffer[len] = 0;
    return db.line_buffer;
}

func char* Db.readUntil(Db* db, char delim) {
    const char* cp = db.cur;
    while (1) {
        if (*cp == 0) return 0;
        if (*cp == delim) break;
        if (cp - db.cur > 127) return 0;
        cp++;
    }
    u32 len = cast<u32>(cp - db.cur);
    memcpy(db.until_buffer, db.cur, len);
    db.until_buffer[len] = 0;
    return db.until_buffer;
}

func bool Db.parseRecipe(Db* db) {
    if (strncmp(db.cur, "bin", 3) == 0) {
        db.recipe.add("executable test\n");
    } else if (strncmp(db.cur, "lib", 3) == 0) {
        db.cur += 4;
        // Syntax lib shared/static
        const char* libtype = db.readWord();
        if (strcmp(libtype, "shared") == 0 || strcmp(libtype, "static") == 0) {
        } else {
            db.errorMsg.print("unknown library type '%s'", libtype);
            return false;
        }
        db.recipe.print("lib test %s\n", libtype);
    } else {
        db.errorMsg.print("unknown target type '%s'", db.readWord());
        return false;
    }
    db.skipLine();
    // TODO check that each line starts with $? (after optional whitespace)
    while (1) {
        if (*db.cur == 0 || strncmp(db.cur, "// @", 4) == 0) return true;

        if (*db.cur != '\n') {
            db.recipe.add(db.readLine());
            db.recipe.add1('\n');
        }
        db.skipLine();
    }

    return true;
}

func bool Db.parseFile(Db* db) {
    // Syntax file{name}
    if (*db.cur != '{') {
        db.errorMsg.add("expected { after file");
        return false;
    }
    db.cur++;

    char* filename = db.readUntil('}');
    if (filename[0] == 0) {
        db.errorMsg.add("expected filename");
        return false;
    }
    // NOTE: we know filename is allocated in until_buffer, so we can add
    if (!endsWith(filename, ".c2")) append(filename, ".c2");
    db.recipe.print("    %s\n", filename);
    db.line_offset = db.line_nr;
    strcpy(db.current_file, filename);
    db.skipLine();
    const char* start = db.cur;
    while (1) {
        if (*db.cur == 0 || strncmp(db.cur, "// @", 4) == 0) {
            const char* end = db.cur;
            db.writeFile(db.current_file, start, cast<u32>(end - start));
            break;
        }
        db.parseTags(db.cur, db.findEndOfLine());
        db.skipLine();
    }
    return true;
}

func bool Db.parseExpect(Db* db) {
    // Syntax expect{mode, name}
    if (*db.cur != '{') {
        db.errorMsg.add("expected { after expect");
        return false;
    }
    db.cur++;
    const char* modeStr = db.readWord();
    ExpectMode em = ExpectMode.ATLEAST;
    if (strcmp(modeStr, "atleast") == 0) {
        em = ExpectMode.ATLEAST;
    } else if (strcmp(modeStr, "complete") == 0) {
        em = ExpectMode.COMPLETE;
    } else {
        db.errorMsg.print("unknown mode: %s", modeStr);
        return false;
    }

    db.cur += strlen(modeStr);
    if (*db.cur != ',') {
        db.errorMsg.add("expected comma");
        return false;
    }
    db.cur++;

    while (*db.cur == ' ') db.cur++;

    const char* filename = db.readUntil('}');
    if (filename[0] == 0) {
        db.errorMsg.add("expected filename");
        return false;
    }
    db.skipLine(); // skip rest of the line

    db.currentExpect = expect_file.create(filename, em);
    // TODO check for name duplicates
    db.addExpected(db.currentExpect);
    while (*db.cur != 0) {
        if (strncmp(db.cur, "// @", 4) == 0) {
            break;
        }

        if (*db.cur == '\n') {
            db.skipLine();
            continue;
        }

        const char* end = db.cur;
        while (*end != 0 && *end != '\n') end++;
        db.currentExpect.addLine(db.line_nr, db.cur, end);
        db.skipLine();
    }
    db.currentExpect = nil;
    return true;
}

func bool Db.parseKeyword(Db* db) {
    // NOTE: cur points to start of keyword after // @
    const char* keyword = db.readWord();

    if (strcmp(keyword, "skip") == 0) {
        if (!db.runSkipped) db.skip = true;
        return true;
    } else if (strcmp(keyword, "recipe") == 0) {
        if (db.kind != TestKind.C2T) {
            db.errorMsg.add("keyword 'recipe' only allowed in .c2t files");
            return false;
        }
        db.cur += 7;
        return db.parseRecipe();
    } else if (strcmp(keyword, "warnings") == 0) {
        if (db.kind != TestKind.C2) {
            db.errorMsg.add("keyword 'warnings' only allowed in .c2 files");
            return false;
        }
        db.recipe.print("\t$warnings %s\n", db.readLine());
        db.skipLine();
    } else if (strcmp(keyword, "file") == 0) {
        if (db.kind == TestKind.C2) {
            db.errorMsg.add("keyword 'file' only allowed in .c2t/.c2a files");
            return false;
        }
        db.cur += 4;
        return db.parseFile();
    } else if (strcmp(keyword, "expect") == 0) {
        if (db.kind != TestKind.C2T && db.kind != TestKind.C2A) {
            db.errorMsg.add("keyword 'expect' only allowed in .c2t/.c2a files");
            return false;
        }
        db.cur += 6;
        return db.parseExpect();
    } else {
        db.errorMsg.print("unknown keyword '%s'", keyword);
        return false;
    }
    return true;
}

// returns if OK
func bool Db.parseOuter(Db* db) {
    // NOTE: cur always points to beginning of line

    while (*db.cur != 0) {
        if (*db.cur == '\n') {
            db.skipLine();
            continue;
        }
        // search for lines starting with // @..
        if (strncmp(db.cur, "// @", 4) == 0) {
            db.cur += 4;
            if (!db.parseKeyword()) return false;
            continue;
        }

        // TODO give error on non-empty lines
        db.skipLine();
    }
    return true;
}


// TODO use errorMsg.print()? and wrap that?
func void Db.error(Db* db, const char* msg) {
    // TODO use colError?
    // TODO BB filename
    //color_print2(db.output, ANSI_BRED, "%s:%d: %s", file.filename.c_str(), line_nr, msg);
    color_print2(db.output, color.Bred, "%s:%d: %s", "TODO BB", db.line_nr, msg);
    db.hasErrors = true;
}

func void Db.parseTags(Db* db, const char* start, const char* end) {
    // if finding '// @' somewhere else, it's a note/warning/error
    const char* cp = find(start, end, "// ");
    if (!cp) return;
    cp += 3;    // skip "// ";

    const char* msg_start;

    // search for @
    if (*cp != '@') return;
    cp++;   // skip @

    Type kind = Type.ERROR;
    if (strncmp(cp, "error{", 6) == 0) {
        cp += 6;
        kind = Type.ERROR;
        goto parse_msg;
    }
    if (strncmp(cp, "warning{", 8) == 0) {
        cp += 8;
        kind = Type.WARNING;
        goto parse_msg;
    }
    if (strncmp(cp, "note{", 5) == 0) {
        cp += 5;
        kind = Type.NOTE;
        goto parse_msg;
    }
    db.error("unknown note/warning/error tag");
    return;
parse_msg:
    // todo extract to function
    msg_start = cp;
    while (*cp != '}') {
        if (cp == end) {
            db.error("missing '}'");
            exit(EXIT_FAILURE);
        }
        cp++;
    }
    char[128] msg;
    memcpy(msg, msg_start, cast<u32>(cp - msg_start));
    msg[cp - msg_start] = 0;
    switch (kind) {
    case ERROR:
#if DEBUG
        printf(ANSI_BLUE"  expecting error '%s' at %d" ANSI_NORMAL"\n", msg, line_nr - line_offset);
#endif
        // TODO BB
        //errors.push_back(Issue(current_file, line_nr - line_offset, msg));
        break;
    case WARNING:
#if DEBUG
        printf(ANSI_BLUE"  expecting warning '%s' at %d " ANSI_NORMAL"\n", msg, line_nr - line_offset);
#endif
        // TODO BB
        //warnings.push_back(Issue(current_file, line_nr - line_offset, msg));
        break;
    case NOTE:
#if DEBUG
        printf(ANSI_BLUE"  expecting note '%s' at %d" ANSI_NORMAL"\n", msg, line_nr - line_offset);
#endif
        // TODO BB
        //notes.push_back(Issue(current_file, line_nr - line_offset, msg));
        break;
    }
}

public func void Db.parseLineOutside(Db* db, const char* start, const char* end) {
    // TODO
}

public func void Db.parseLineFile(Db* db, const char* start, const char* end) {
    // TODO
}

public func void Db.parseLineExpect(Db* db, const char* start, const char* end) {
    // if line starts with '// @' stop filemode
    if (strncmp(start, "// @", 4) == 0) {
        //db.currentExpect = nil;
        db.mode = Mode.Outside;
        db.parseLine(start, end);
        return;
    }
    //currentExpect->addLine(line_nr, start, end);

    // add non-empty lines (stripped of heading+trailing whitespace) to list
    // TODO
}

public func void Db.parseLine(Db* db, const char* start, const char* end) {
    switch (db.mode) {
    case Outside:
        db.parseLineOutside(start, end);
        break;
    case Infile:
        db.parseLineFile(start, end);
        break;
    case InExpectFile:
        db.parseLineExpect(start, end);
        break;
    }
}

public func bool Db.parse(Db* db) {
    const char* cp = cast<char*>(db.file.data());
    db.cur = cp;
    db.line_nr = 1;
    switch (db.kind) {
    case C2:
        const char* end = cp + db.file.size;
        const char* line_start = cp;
        db.recipe.add("executable test\n");
        db.recipe.add("  $warnings no-unused-module\n");
        db.recipe.add("  $generate-c skip\n");

        bool hasSkip = (strncmp(cp, "// @skip", 8) == 0);
        if (db.runSkipped != hasSkip) return true;
        while (cp != end) {
            while (*cp != '\n' && cp != end) cp++;
            if (cp != line_start) db.parseLine(line_start, cp);
            db.line_nr++;
            if (*cp == '\n') cp++;
            line_start = cp;
        }

        db.recipe.print("  %s\n", db.current_file);
        if (db.target[0] != 0) {
            string_buffer.Buf* build = string_buffer.create(1024, 0, 0);
            build.print("target: \"%s\"\n", db.target);
            build.add("libdir:\n");
            build.add("   - \"$C2_LIBDIR\"\n");
            db.writeFile("build.yaml", build.data(), build.size());
            build.free();
        }
        db.recipe.add("end\n");
        db.writeFile("recipe.txt", db.recipe.data(), db.recipe.size());
        return false;
    case C2T:
        if (!db.parseOuter()) {
            print_error("error in recipe: %s on line %d", db.errorMsg.data(), db.line_nr);
            return false;
        }
        db.recipe.add("end\n");
        db.writeFile("recipe.txt", db.recipe.data(), db.recipe.size());
        break;
    case C2A:
        db.recipe.add("executable test\n");
        db.recipe.add("  $warnings no-unused\n");
        db.recipe.add("  $generate-c skip\n");
        db.recipe.add("  $write-AST\n");
        if (!db.parseOuter()) {
            print_error("error in recipe: %s on line %d", db.errorMsg.data(), db.line_nr);
            return false;
        }
        db.recipe.add("end\n");
        db.writeFile("recipe.txt", db.recipe.data(), db.recipe.size());
        break;
    }

    return db.skip;
}

public func void Db.testFile(Db* db) {
    i32[2] pipe_stdout;
    if (pipe(pipe_stdout) == -1) {
        fprintf(stderr, "pipe() failed: %s\n", strerror(*errno2()));
        exit(1);
    }
    i32[2] pipe_stderr;
    if (pipe(pipe_stderr) == -1) {
        fprintf(stderr, "pipe() failed: %s\n", strerror(*errno2()));
        exit(1);
    }

    // spawn a child to run c2c
    Pid pid = fork();
    if (pid == -1) {
        fprintf(stderr, "fork() failed: %s\n", strerror(*errno2()));
        exit(1);
    }
    if (pid==0) { // child
        while ((dup2(pipe_stdout[1], STDOUT_FILENO) == -1) && (errno == EINTR)) {}
        close(pipe_stdout[1]);
        close(pipe_stdout[0]);
        while ((dup2(pipe_stderr[1], STDERR_FILENO) == -1) && (errno == EINTR)) {}
        close(pipe_stderr[1]);
        close(pipe_stderr[0]);
        execl(c2c_cmd, "c2c", "-d", db.tmp_dir, "--test", 0);
        fprintf(stderr, "execl() failed: %s\n", strerror(*errno2()));
        exit(127); /* only if execv fails */
    } else { // parent
        close(pipe_stdout[1]);
        close(pipe_stderr[1]);
        i32 status = 0;
        waitpid(pid, &status, 0);
        if (!doWIFEXITED(status)) {  // child exited abnormally
            // TODO print pipe_stderr
            db.output.color(colError);
            db.output.add("c2c crashed!");
            db.output.color(color.Normal);
            db.output.add1('\n');
            db.hasErrors = true;
            return;
        }
        // check return code
        i32 retcode = getWEXITSTATUS(status);
        if (retcode == 127) {
            color_print2(db.output, colError, "Error spawning compiler '%s'", c2c_cmd);
            exit(EXIT_FAILURE);
        }
        if (retcode == 254) { // from TODO/FATAL_ERROR macros
            db.output.color(colError);
            db.output.add("c2c returned error");
            db.output.color(color.Normal);
            db.output.add1('\n');
            db.hasErrors = true;
            return;
        }
        // check output
        char[1024*1024] buffer;
        while (1) {
            isize count = read(pipe_stderr[0], buffer, sizeof(buffer)-1);
            if (count == -1) {
                if (errno == EINTR) continue;
                perror("read");
                exit(1);
            }
            if (count == 0) break;
            if (count == sizeof(buffer)-1) color_print2(db.output, colError, "Too many error messages for single read!");
            buffer[count] = 0;
            db.checkErrors(buffer, cast<u32>(count));
        }
        close(pipe_stdout[0]);
        close(pipe_stderr[0]);
        wait(0);
        db.checkExpectedFiles();
        // TODO BB
        //if (!errors.empty() || !warnings.empty()) hasErrors = true;
    }
}

func void Db.checkDiagnosticLine(Db* db, const char* line) {
#if DEBUG
    printf(ANSI_WHITE"line: '%s'" ANSI_NORMAL"\n", line);
#endif
    // line syntax: '<filename>.c2:<linenr>:<offset>: error/warning/note: <msg>\n'
    char[128] filename;
    char[128] msg;
    i32 error_line = 0;
    i32 col = 0;
    memset(filename, 0, sizeof(filename));
    memset(msg, 0, sizeof(msg));

    i32 res = sscanf(line, "%[^: ]:%d:%d: error: %[^\n]\n", filename, &error_line, &col, msg);
    if (res == 4) {
        // found error
#if DEBUG
        printf(ANSI_CYAN"%s", filename);
        printf("  %d:%d", error_line, col);
        printf("  '%s'" ANSI_NORMAL"\n", msg);
#endif
        db.matchError(filename, error_line, msg);
    } else {
        res = sscanf(line, "%[^: ]:%d:%d: warning: %[^\n]\n", filename, &error_line, &col, msg);
        if (res == 4) {
            // found warning
#if DEBUG
            printf(ANSI_CYAN"%s", filename);
            printf("  %d:%d", error_line, col);
            printf("  '%s'" ANSI_NORMAL"\n", msg);
#endif
            db.matchWarning(filename, error_line, msg);
        } else {
            res = sscanf(line, "%[^: ]:%d:%d: note: %[^\n]\n", filename, &error_line, &col, msg);
            if (res == 4) {
                // found note
#if DEBUG
                printf(ANSI_CYAN"%s", filename);
                printf("  %d:%d", error_line, col);
                printf("  '%s'" ANSI_NORMAL"\n", msg);
#endif
                db.matchNote(filename, error_line, msg);
            }
        }
    }

    if (res == 4) {
        // match msg string and set cp to that to avoid duplicates on empty lines
        const char* found = strstr(line, msg);
        assert(found);
        line = found;
    }
}

func void Db.checkErrors(Db* db, char* buffer, u32 size) {
#if DEBUG
    printf(ANSI_MAGENTA"stderr:\n%s" ANSI_NORMAL"\n", buffer);
#endif
    const char* cp = buffer;
    const char* end = cp + size;
    const char* line = cp;
    bool haveColon = false;
    while (cp != end) {
        // cut up into lines
        if (*cp == ':') haveColon = true;
        if (*cp == '\n') {
            char[512] data;
            u32 len = cast<u32>(cp - line);
            assert(len < sizeof(data));
            memcpy(data, line, len);
            data[len] = 0;
            if (haveColon) db.checkDiagnosticLine(data);
            cp++;
            line = cp;
            haveColon = false;
        } else {
            cp++;
        }
    }
}

func void Db.checkExpectedFiles(Db* db) {
    char[256] basedir;
    sprintf(basedir, "%s/output/test/", db.tmp_dir);
    for (u32 i=0; i<db.expectedCount; ++i) {
        ExpectFile* e = db.expectedFiles[i];
        if (!e.check(db.output, basedir)) db.hasErrors = true;
    }
}

public func void Db.printIssues(const Db* db) {
    // TODO BB
/*
    for (IssuesConstIter iter = errors.begin(); iter != errors.end(); ++iter) {
        output.setColor(COL_ERROR);
        output.print("  expected error '%s' at %s:%d",
                    iter->msg.c_str(), iter->filename.c_str(), iter->line_nr);
        output.setColor(COL_NORM);
        output << '\n';
    }
    for (IssuesConstIter iter = warnings.begin(); iter != warnings.end(); ++iter) {
        output.setColor(COL_ERROR);
        output.print("  expected warning '%s' at %s:%d",
                    iter->msg.c_str(), iter->filename.c_str(), iter->line_nr);
        output.setColor(COL_NORM);
        output << '\n';
    }
    for (IssuesConstIter iter = notes.begin(); iter != notes.end(); ++iter) {
        output.setColor(COL_ERROR);
        output.print("  expected note '%s' at %s:%d",
                    iter->msg.c_str(), iter->filename.c_str(), iter->line_nr);
        output.setColor(COL_NORM);
        output << '\n';
    }
*/
}


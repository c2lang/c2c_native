/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module tester_main;

import stdio local;
import stdlib local;
import string local;
import sys_stat local;
import sys_time;
import libc_dirent local;
import c_errno local;
import unistd;
import pthread;

import color;
import test_utils local;
import test_db local;
import string_buffer;
import file_utils;

/*
    Syntax:
    .c2:
        (optional) // @warnings{..}
        (optional) // @skip
        (optional) // @target{target-triplet}
    .c2t:  test generation of specified files
        (required) // @recipe bin/lib shared/static
        (optional) // @skip
        (required) // @file{filename}
        (optional) // @expect{atleast/complete, filename}
    .c2a: test AST of parsed file (no unused)
        (optional) // @skip
        (required) // @file{filename}   allowed ONCE
        (required) // @expect{atleast/complete}  allowed ONCE
*/

const u32 MAX_THREADS = 32;

bool color_output = true;
const char* c2c_cmd = "build/c2c/c2c";
bool runSkipped;

// TODO move test + queue to own file
type Test struct {
    char* filename;
    TestKind kind;
    bool failed;
    Test* next;
}

func Test* Test.create(const char* filename, TestKind kind) {
    Test* t = calloc(1, sizeof(Test));
    t.filename = strdup(filename);
    t.kind = kind;
    return t;
}

func void Test.destroy(Test* t) {
    free(t.filename);
    free(t);
}

type TestQueue struct {
    pthread.Mutex lock;
    Test* head;
    Test* tail;
    Test* cur;
    u32 count;
}

func TestQueue* TestQueue.create() {
    TestQueue* q = calloc(1, sizeof(TestQueue));
    q.lock.init(nil);
    return q;
}

func void TestQueue.destroy(TestQueue* q) {
    Test* cur = q.head;
    while (cur) {
        Test* next = cur.next;
        cur.destroy();
        cur = next;
    }
    free(q);
}

func void TestQueue.add(TestQueue* q, const char* filename, TestKind kind) {
    Test* t = Test.create(filename, kind);
    q.lock.lock();
    if (q.tail) {
        q.tail.next = t;
    } else {
        q.head = t;
        q.cur = t;
    }
    q.tail = t;
    q.count++;
    q.lock.unlock();
}

func Test* TestQueue.get(TestQueue* q) {
    Test* t = nil;
    q.lock.lock();
    if (q.cur) {
        t = q.cur;
        q.cur = q.cur.next;
    }
    q.lock.unlock();
    return t;
}

func void TestQueue.summarizeFailed(const TestQueue* q) {
    printf("\nFailed test summary:\n");
    const Test* t = q.head;
    while (t) {
        if (t.failed) color_print(colError, "%s", t.filename);
        t = t.next;
    }
}

func i32 online_cpus() {
    i64 ncpus = unistd.sysconf(unistd._SC_NPROCESSORS_ONLN);
    if (ncpus > 0) return cast<i32>(ncpus);
    return 1;
}

func void handle_file(TestQueue* queue, const char* filename) {
    TestKind kind;
    if (endsWith(filename, ".c2")) {
        kind = TestKind.C2;
    } else if (endsWith(filename, ".c2t")) {
        kind = TestKind.C2T;
    } else if (endsWith(filename, ".c2a")) {
        kind = TestKind.C2A;
    } else {
        return;
    }

    queue.add(filename, kind);
}

func void handle_dir(TestQueue* queue, const char* path) {
    DIR* dir = opendir(path);
    if (dir == nil) {
        color_print(colError, "cannot open dir '%s': %s", path, strerror(*errno2()));
        return;
    }
    Dirent* dir2 = readdir(dir);
    char[test_db.MAX_LINE] temp;
    while (dir2 != nil) {
        sprintf(temp, "%s/%s", path, dir2.d_name);
        switch (dir2.d_type) {
        case DT_REG:
            handle_file(queue, temp);
            break;
        case DT_DIR:
            if (strcmp(dir2.d_name, ".") != 0 && strcmp(dir2.d_name, "..") != 0) {
                handle_dir(queue, temp);
            }
            break;
        default:
            break;
        }
        dir2 = readdir(dir);
    }
    closedir(dir);
}


type Tester struct {
    u32 numtests;
    u32 numerrors;
    u32 numskipped;

    u32 index;
    TestQueue* queue;
    pthread.Pthread thread;
    char[32] tmp_dir;
    const char* cwd;    // no ownership
}

func void* tester_thread_main(void* arg) {
    Tester* t = arg;
    t.run();
    return 0;
}

func Tester* Tester.create(u32 idx, TestQueue* q, const char* cwd) {
    Tester* t = calloc(1, sizeof(Tester));
    t.index = idx;
    t.queue = q;
    t.cwd = cwd;
    sprintf(t.tmp_dir, "/tmp/tester%u", idx);
    pthread.create(&t.thread, 0, tester_thread_main, t);
    return t;
}

func void Tester.destroy(Tester* t) {
    free(t);
}

func void Tester.join(Tester* t) {
    pthread.join(t.thread, 0);
}

func void Tester.run(Tester* t) {
    while (1) {
        Test* test = t.queue.get();
        if (!test) break;
        t.run_test(test);
    }
}

func void Tester.run_test(Tester* t, Test* test) {
    // setup dir
    // temp, just delete this way
    char[64] cmd;
    sprintf(cmd, "rm -rf %s", t.tmp_dir);
    i32 err = system(cmd);
    if (err != 0 && *errno2() != 10) {
        i32 saved = *errno2();
        fprintf(stderr, "error running '%s': %s, %d\n", cmd, strerror(saved), saved);
        exit(EXIT_FAILURE);
    }
    // create test dir
    err = mkdir(t.tmp_dir, 0777);
    if (err) {
        fprintf(stderr, "error creating %s: %s\n", t.tmp_dir, strerror(*errno2()));
        exit(EXIT_FAILURE);
    }

    t.numtests++;

    string_buffer.Buf* buf = string_buffer.create(4096, true, 2);
    buf.print("%s ", test.filename);

    file_utils.Reader file;
    bool ok = file.open(test.filename);
    if (!ok) {
        fprintf(stderr, "error opening %s: %s\n", test.filename, strerror(*errno2()));
        exit(EXIT_FAILURE);
    }

    test_db.Db db;
    db.init(buf, &file, test.filename, test.kind, t.tmp_dir, t.cwd);
    bool skip = db.parse();
    if (skip) {
        t.numskipped++;
        buf.clear();
        color_print2(buf, colSkip, "%s SKIPPED", test.filename);
        printf("%s", buf.data());
    } else {
        buf.add1('\n');

        if (!db.haveErrors()) {
            db.testFile();
            db.printIssues();
        }
        printf("%s", buf.data());


        if (db.haveErrors()) {
            test.failed = true;
            t.numerrors++;
        }
    }
    db.destroy();
    file.close();
    buf.free();
}

func void usage(const char* name) {
    printf("Usage: %s [file/dir] <options>\n", name);
    printf("    -s    only run skipped tests\n");
    printf("    -n    no multi-threading\n");
    exit(EXIT_FAILURE);
}

public func u64 now() {
    sys_time.Timeval tv;
    sys_time.gettimeofday(&tv, nil);
    u64 now64 = cast<u64>(tv.tv_sec);
    now64 *= 1000000;
    now64 += tv.tv_usec;
    return now64;
}

public func i32 main(i32 argc, char** argv) {
    set_color_output(unistd.isatty(1));

    i32 num_threads = online_cpus();
    if (num_threads > MAX_THREADS) num_threads = MAX_THREADS;

    if (argc == 1 || argc > 3) usage(argv[0]);
    const char* target = argv[1];

    if (argc == 3) {
        if (strcmp(argv[2], "-s") == 0) {
            runSkipped = true;
        } else if (strcmp(argv[2], "-n") == 0) {
            num_threads = 1;
        } else {
            usage(argv[0]);
        }
    }

    color_output = unistd.isatty(1);

    Stat statbuf;
    if (stat(target, &statbuf)) {
        perror("stat");
        return -1;
    }

    // strip off trailing '/'
    if (target[strlen(target) -1] == '/') {
        char* end = cast<char*>(&target[strlen(target) -1]);
        *end = 0;
    }

    char* cwd = unistd.getcwd(0, 0);
    if (cwd == 0) {
        perror("getcwd");
        exit(EXIT_FAILURE);
    }

    TestQueue* queue = TestQueue.create();

    u64 t1 = now();

    if (statbuf.st_mode & S_IFMT == S_IFREG) {
        num_threads = 1;
        handle_file(queue, target);
    } else if (statbuf.st_mode & S_IFMT == S_IFDIR) {
        // TODO strip off optional trailing '/'
        handle_dir(queue, target);
    } else {
        usage(argv[0]);
    }

    Tester*[MAX_THREADS] testers = { nil }
    for (i32 i=0; i<num_threads; i++) {
        testers[i] = Tester.create(cast<u32>(i), queue, cwd);
    }

    // TODO handle Ctrl-C

    u32 numtests = 0;
    u32 numerrors = 0;
    u32 numskipped = 0;

    for (i32 i=0; i<num_threads; i++) {
        Tester* t = testers[i];
        t.join();
        numtests += t.numtests;
        numerrors += t.numerrors;
        numskipped += t.numskipped;
        t.destroy();
    }

    u64 t2 = now();

    const char* col = (numerrors ? colError : colOk);
    color_print(col, "RESULTS: %u test%s, %u threads (%u ok, %u failed, %u skipped) ran in %llu ms",
        numtests, numtests == 1 ? "" : "s", num_threads, numtests - (numerrors+numskipped), numerrors, numskipped, (t2-t1)/1000);
    if (numerrors) queue.summarizeFailed();

    queue.destroy();
    free(cwd);

	return 0;
}


module ast_attr;

import string_pool;

import string;

// note: keep Attr prefix because Kind already exists a lot
public type AttrKind enum u8 {
    Export,
    Packed,
    Unused,
    UnusedParams,
    Section,
    NoReturn,
    Inline,
    Aligned,
    Weak,
    Opaque,
    CName,      // cname="othername" only allowed in interface files
    NoTypeDef,  // only allowed in interface files, don't generate typedef for struct/union
}

const char*[] attrKind_names = {
    "export",
    "packed",
    "unused",
    "unused_params",
    "section",
    "noreturn",
    "inline",
    "aligned",
    "weak",
    "opaque",
    "cname",
    "no_typedef",
}

static_assert(elemsof(AttrKind), elemsof(attrKind_names));

public type AttrInfo struct {
    AttrKind kind;
    bool requiresArg;
    u8 alowedDecls;
} //@(opaque)

const u32 Type = 0x1;
const u32 Func = 0x2;
const u32 Var  = 0x4;

// TODO remove RHS (Type | Func | Var)
const AttrInfo[] Info = {
    { AttrKind.Export,       false, Type | Func | Var }, // Decl
    { AttrKind.Packed,       false, Type              },
    { AttrKind.Unused,       false, Type | Func | Var }, // Decl
    { AttrKind.UnusedParams, false, Type | Func       },
    { AttrKind.Section,      true,         Func | Var },
    { AttrKind.NoReturn,     false,        Func       },
    { AttrKind.Inline,       false,        Func       },
    { AttrKind.Aligned,      true,  Type | Func | Var }, // TODO allowed for var/func??
    { AttrKind.Weak,         false,        Func | Var },
    { AttrKind.Opaque,       false, Type              },
    { AttrKind.CName,        true,  Type | Func | Var }, // store in AST, note in Decl
    { AttrKind.NoTypeDef,    false, Type              },
}

static_assert(elemsof(AttrKind), elemsof(Info));

u32[elemsof(AttrKind)] name_indexes;

// Note: only meant for printing (since not allocated in StringPool)
public func const char* AttrInfo.getName(const AttrInfo* i) {
    return attrKind_names[i.kind];
}

public func void init(string_pool.Pool* pool) {
    for (u32 i=0; i<elemsof(Info); i++) {
        name_indexes[i] = pool.addStr(attrKind_names[i], true);
    }
}

public func const AttrInfo* find(u32 name_idx) {
    for (u32 i=0; i<elemsof(Info); i++) {
        if (name_idx == name_indexes[i]) return &Info[i];
    }
    return nil;
}

